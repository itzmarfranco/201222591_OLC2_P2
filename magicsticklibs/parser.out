Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMA
    COMMENT
    QUOTE_1
    QUOTE_2
    XOR

Grammar

Rule 0     S' -> start
Rule 1     start -> MAIN COLON body
Rule 2     body -> goto body
Rule 3     body -> unset body
Rule 4     body -> print body
Rule 5     body -> exit body
Rule 6     body -> tag body
Rule 7     body -> if body
Rule 8     body -> assign body
Rule 9     body -> declaration body
Rule 10    body -> empty
Rule 11    goto -> GOTO NAME SEMICOLON
Rule 12    unset -> UNSET L_PAR TVAR R_PAR SEMICOLON
Rule 13    unset -> UNSET L_PAR AVAR R_PAR SEMICOLON
Rule 14    unset -> UNSET L_PAR VVAR R_PAR SEMICOLON
Rule 15    unset -> UNSET L_PAR SVAR R_PAR SEMICOLON
Rule 16    unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON
Rule 17    unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON
Rule 18    print -> PRINT L_PAR TVAR R_PAR SEMICOLON
Rule 19    print -> PRINT L_PAR AVAR R_PAR SEMICOLON
Rule 20    print -> PRINT L_PAR VVAR R_PAR SEMICOLON
Rule 21    print -> PRINT L_PAR SVAR R_PAR SEMICOLON
Rule 22    print -> PRINT L_PAR SPVAR R_PAR SEMICOLON
Rule 23    print -> PRINT L_PAR RAVAR R_PAR SEMICOLON
Rule 24    print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
Rule 25    print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
Rule 26    print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
Rule 27    print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
Rule 28    print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
Rule 29    print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
Rule 30    print -> PRINT L_PAR STRING R_PAR SEMICOLON
Rule 31    exit -> EXIT SEMICOLON
Rule 32    tag -> NAME COLON
Rule 33    if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON
Rule 34    condition -> condition AND condition
Rule 35    condition -> condition OR condition
Rule 36    condition -> NOT condition
Rule 37    condition -> relational
Rule 38    relational -> arithmetic EQUAL arithmetic
Rule 39    relational -> arithmetic NOT_EQUAL arithmetic
Rule 40    relational -> arithmetic GREATER arithmetic
Rule 41    relational -> arithmetic LESS arithmetic
Rule 42    relational -> arithmetic GREATER_EQUAL arithmetic
Rule 43    relational -> arithmetic LESS_EQUAL arithmetic
Rule 44    relational -> arithmetic
Rule 45    arithmetic -> arithmetic PLUS arithmetic
Rule 46    arithmetic -> arithmetic MINUS arithmetic
Rule 47    arithmetic -> arithmetic MULTIPLY arithmetic
Rule 48    arithmetic -> arithmetic DIVIDE arithmetic
Rule 49    arithmetic -> arithmetic REMAINDER arithmetic
Rule 50    arithmetic -> INTEGER
Rule 51    arithmetic -> DECIMAL
Rule 52    arithmetic -> STRING
Rule 53    arithmetic -> var
Rule 54    arithmetic -> array_access
Rule 55    arithmetic -> MINUS arithmetic
Rule 56    var -> TVAR
Rule 57    var -> AVAR
Rule 58    var -> VVAR
Rule 59    var -> SVAR
Rule 60    var -> RAVAR
Rule 61    var -> SPVAR
Rule 62    array_access -> <empty>
Rule 63    assign -> TVAR ASSIGN condition SEMICOLON
Rule 64    assign -> AVAR ASSIGN condition SEMICOLON
Rule 65    assign -> VVAR ASSIGN condition SEMICOLON
Rule 66    assign -> SVAR ASSIGN condition SEMICOLON
Rule 67    assign -> TVAR ASSIGN conversion SEMICOLON
Rule 68    assign -> AVAR ASSIGN conversion SEMICOLON
Rule 69    assign -> VVAR ASSIGN conversion SEMICOLON
Rule 70    assign -> SVAR ASSIGN conversion SEMICOLON
Rule 71    assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
Rule 72    assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
Rule 73    assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
Rule 74    assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
Rule 75    assign -> TVAR ASSIGN bitwise SEMICOLON
Rule 76    assign -> AVAR ASSIGN bitwise SEMICOLON
Rule 77    assign -> VVAR ASSIGN bitwise SEMICOLON
Rule 78    assign -> SVAR ASSIGN bitwise SEMICOLON
Rule 79    assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
Rule 80    assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
Rule 81    assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
Rule 82    assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
Rule 83    assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
Rule 84    assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
Rule 85    assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
Rule 86    assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
Rule 87    assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
Rule 88    assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
Rule 89    bitwise -> var AND_B var
Rule 90    bitwise -> var OR_B var
Rule 91    bitwise -> var XOR_B var
Rule 92    bitwise -> var SHIFT_L var
Rule 93    bitwise -> var SHIFT_R var
Rule 94    bitwise -> NOT_B TVAR
Rule 95    bitwise -> NOT_B AVAR
Rule 96    bitwise -> NOT_B VVAR
Rule 97    bitwise -> NOT_B SVAR
Rule 98    conversion -> L_PAR type R_PAR var
Rule 99    type -> INT
Rule 100   type -> FLOAT
Rule 101   type -> CHAR
Rule 102   declaration -> var
Rule 103   declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
Rule 104   declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
Rule 105   declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
Rule 106   declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
Rule 107   declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
Rule 108   declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
Rule 109   declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
Rule 110   declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
Rule 111   declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
Rule 112   declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
Rule 113   declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
Rule 114   declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
Rule 115   empty -> <empty>

Terminals, with rules where they appear

ABS                  : 85 86 87 88
AND                  : 34
AND_B                : 89
ARRAY                : 103 104 105 106 107 108
ASSIGN               : 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 103 104 105 106 107 108
AVAR                 : 13 19 25 57 64 68 72 76 80 86 95 104 110
CHAR                 : 101
COLON                : 1 32
COMMA                : 
COMMENT              : 
DECIMAL              : 51
DIVIDE               : 48
EQUAL                : 38
EXIT                 : 31
FLOAT                : 100
GOTO                 : 11 33
GREATER              : 40
GREATER_EQUAL        : 42
IF                   : 33
INT                  : 99
INTEGER              : 50
LESS                 : 41
LESS_EQUAL           : 43
L_BRACKET            : 24 25 26 27 28 29 79 80 81 82 83 84 109 110 111 112 113 114
L_PAR                : 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 33 71 72 73 74 85 86 87 88 98 103 104 105 106 107 108
MAIN                 : 1
MINUS                : 46 55
MULTIPLY             : 47
NAME                 : 11 32 33
NOT                  : 36
NOT_B                : 94 95 96 97
NOT_EQUAL            : 39
OR                   : 35
OR_B                 : 90
PLUS                 : 45
PRINT                : 18 19 20 21 22 23 24 25 26 27 28 29 30
QUOTE_1              : 
QUOTE_2              : 
RAVAR                : 17 23 29 60 84 108 114
READ                 : 71 72 73 74
REMAINDER            : 49
R_BRACKET            : 24 25 26 27 28 29 79 80 81 82 83 84 109 110 111 112 113 114
R_PAR                : 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 33 71 72 73 74 85 86 87 88 98 103 104 105 106 107 108
SEMICOLON            : 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 33 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 103 104 105 106 107 108 109 110 111 112 113 114
SHIFT_L              : 92
SHIFT_R              : 93
SPVAR                : 16 22 28 61 83 107 113
STRING               : 30 52
SVAR                 : 15 21 27 59 66 70 74 78 82 88 97 106 112
TVAR                 : 12 18 24 56 63 67 71 75 79 85 94 103 109
UNSET                : 12 13 14 15 16 17
VVAR                 : 14 20 26 58 65 69 73 77 81 87 96 105 111
XOR                  : 
XOR_B                : 91
error                : 

Nonterminals, with rules where they appear

arithmetic           : 24 25 26 27 28 29 38 38 39 39 40 40 41 41 42 42 43 43 44 45 45 46 46 47 47 48 48 49 49 55 79 80 81 82 83 84 109 110 111 112 113 114
array_access         : 54
assign               : 8
bitwise              : 75 76 77 78
body                 : 1 2 3 4 5 6 7 8 9
condition            : 33 34 34 35 35 36 63 64 65 66 79 80 81 82 83 84
conversion           : 67 68 69 70
declaration          : 9
empty                : 10
exit                 : 5
goto                 : 2
if                   : 7
print                : 4
relational           : 37
start                : 0
tag                  : 6
type                 : 98
unset                : 3
var                  : 53 85 86 87 88 89 89 90 90 91 91 92 92 93 93 98 102

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . MAIN COLON body

    MAIN            shift and go to state 2

    start                          shift and go to state 1

state 1

    (0) S' -> start .



state 2

    (1) start -> MAIN . COLON body

    COLON           shift and go to state 3


state 3

    (1) start -> MAIN COLON . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) print -> . PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (25) print -> . PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (26) print -> . PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (27) print -> . PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (28) print -> . PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (29) print -> . PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (30) print -> . PRINT L_PAR STRING R_PAR SEMICOLON
    (31) exit -> . EXIT SEMICOLON
    (32) tag -> . NAME COLON
    (33) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (63) assign -> . TVAR ASSIGN condition SEMICOLON
    (64) assign -> . AVAR ASSIGN condition SEMICOLON
    (65) assign -> . VVAR ASSIGN condition SEMICOLON
    (66) assign -> . SVAR ASSIGN condition SEMICOLON
    (67) assign -> . TVAR ASSIGN conversion SEMICOLON
    (68) assign -> . AVAR ASSIGN conversion SEMICOLON
    (69) assign -> . VVAR ASSIGN conversion SEMICOLON
    (70) assign -> . SVAR ASSIGN conversion SEMICOLON
    (71) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (72) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (73) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (74) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (75) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (76) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (77) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (78) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (79) assign -> . TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (80) assign -> . AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (81) assign -> . VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (82) assign -> . SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (83) assign -> . SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (84) assign -> . RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (85) assign -> . TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (86) assign -> . AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (87) assign -> . VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (88) assign -> . SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (102) declaration -> . var
    (103) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (104) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (105) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (106) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (107) declaration -> . SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (108) declaration -> . RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (109) declaration -> . TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (110) declaration -> . AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (111) declaration -> . VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (112) declaration -> . SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (113) declaration -> . SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (114) declaration -> . RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (115) empty -> .
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    SPVAR           shift and go to state 21
    RAVAR           shift and go to state 22
    $end            reduce using rule 115 (empty -> .)

    body                           shift and go to state 4
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    print                          shift and go to state 7
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    if                             shift and go to state 10
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 4

    (1) start -> MAIN COLON body .

    $end            reduce using rule 1 (start -> MAIN COLON body .)


state 5

    (2) body -> goto . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) print -> . PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (25) print -> . PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (26) print -> . PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (27) print -> . PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (28) print -> . PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (29) print -> . PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (30) print -> . PRINT L_PAR STRING R_PAR SEMICOLON
    (31) exit -> . EXIT SEMICOLON
    (32) tag -> . NAME COLON
    (33) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (63) assign -> . TVAR ASSIGN condition SEMICOLON
    (64) assign -> . AVAR ASSIGN condition SEMICOLON
    (65) assign -> . VVAR ASSIGN condition SEMICOLON
    (66) assign -> . SVAR ASSIGN condition SEMICOLON
    (67) assign -> . TVAR ASSIGN conversion SEMICOLON
    (68) assign -> . AVAR ASSIGN conversion SEMICOLON
    (69) assign -> . VVAR ASSIGN conversion SEMICOLON
    (70) assign -> . SVAR ASSIGN conversion SEMICOLON
    (71) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (72) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (73) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (74) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (75) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (76) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (77) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (78) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (79) assign -> . TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (80) assign -> . AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (81) assign -> . VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (82) assign -> . SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (83) assign -> . SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (84) assign -> . RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (85) assign -> . TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (86) assign -> . AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (87) assign -> . VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (88) assign -> . SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (102) declaration -> . var
    (103) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (104) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (105) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (106) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (107) declaration -> . SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (108) declaration -> . RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (109) declaration -> . TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (110) declaration -> . AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (111) declaration -> . VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (112) declaration -> . SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (113) declaration -> . SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (114) declaration -> . RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (115) empty -> .
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    SPVAR           shift and go to state 21
    RAVAR           shift and go to state 22
    $end            reduce using rule 115 (empty -> .)

    goto                           shift and go to state 5
    body                           shift and go to state 27
    unset                          shift and go to state 6
    print                          shift and go to state 7
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    if                             shift and go to state 10
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 6

    (3) body -> unset . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) print -> . PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (25) print -> . PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (26) print -> . PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (27) print -> . PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (28) print -> . PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (29) print -> . PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (30) print -> . PRINT L_PAR STRING R_PAR SEMICOLON
    (31) exit -> . EXIT SEMICOLON
    (32) tag -> . NAME COLON
    (33) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (63) assign -> . TVAR ASSIGN condition SEMICOLON
    (64) assign -> . AVAR ASSIGN condition SEMICOLON
    (65) assign -> . VVAR ASSIGN condition SEMICOLON
    (66) assign -> . SVAR ASSIGN condition SEMICOLON
    (67) assign -> . TVAR ASSIGN conversion SEMICOLON
    (68) assign -> . AVAR ASSIGN conversion SEMICOLON
    (69) assign -> . VVAR ASSIGN conversion SEMICOLON
    (70) assign -> . SVAR ASSIGN conversion SEMICOLON
    (71) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (72) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (73) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (74) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (75) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (76) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (77) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (78) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (79) assign -> . TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (80) assign -> . AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (81) assign -> . VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (82) assign -> . SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (83) assign -> . SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (84) assign -> . RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (85) assign -> . TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (86) assign -> . AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (87) assign -> . VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (88) assign -> . SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (102) declaration -> . var
    (103) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (104) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (105) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (106) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (107) declaration -> . SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (108) declaration -> . RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (109) declaration -> . TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (110) declaration -> . AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (111) declaration -> . VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (112) declaration -> . SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (113) declaration -> . SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (114) declaration -> . RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (115) empty -> .
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    SPVAR           shift and go to state 21
    RAVAR           shift and go to state 22
    $end            reduce using rule 115 (empty -> .)

    unset                          shift and go to state 6
    body                           shift and go to state 28
    goto                           shift and go to state 5
    print                          shift and go to state 7
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    if                             shift and go to state 10
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 7

    (4) body -> print . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) print -> . PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (25) print -> . PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (26) print -> . PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (27) print -> . PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (28) print -> . PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (29) print -> . PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (30) print -> . PRINT L_PAR STRING R_PAR SEMICOLON
    (31) exit -> . EXIT SEMICOLON
    (32) tag -> . NAME COLON
    (33) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (63) assign -> . TVAR ASSIGN condition SEMICOLON
    (64) assign -> . AVAR ASSIGN condition SEMICOLON
    (65) assign -> . VVAR ASSIGN condition SEMICOLON
    (66) assign -> . SVAR ASSIGN condition SEMICOLON
    (67) assign -> . TVAR ASSIGN conversion SEMICOLON
    (68) assign -> . AVAR ASSIGN conversion SEMICOLON
    (69) assign -> . VVAR ASSIGN conversion SEMICOLON
    (70) assign -> . SVAR ASSIGN conversion SEMICOLON
    (71) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (72) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (73) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (74) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (75) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (76) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (77) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (78) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (79) assign -> . TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (80) assign -> . AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (81) assign -> . VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (82) assign -> . SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (83) assign -> . SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (84) assign -> . RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (85) assign -> . TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (86) assign -> . AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (87) assign -> . VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (88) assign -> . SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (102) declaration -> . var
    (103) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (104) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (105) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (106) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (107) declaration -> . SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (108) declaration -> . RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (109) declaration -> . TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (110) declaration -> . AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (111) declaration -> . VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (112) declaration -> . SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (113) declaration -> . SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (114) declaration -> . RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (115) empty -> .
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    SPVAR           shift and go to state 21
    RAVAR           shift and go to state 22
    $end            reduce using rule 115 (empty -> .)

    print                          shift and go to state 7
    body                           shift and go to state 29
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    if                             shift and go to state 10
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 8

    (5) body -> exit . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) print -> . PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (25) print -> . PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (26) print -> . PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (27) print -> . PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (28) print -> . PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (29) print -> . PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (30) print -> . PRINT L_PAR STRING R_PAR SEMICOLON
    (31) exit -> . EXIT SEMICOLON
    (32) tag -> . NAME COLON
    (33) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (63) assign -> . TVAR ASSIGN condition SEMICOLON
    (64) assign -> . AVAR ASSIGN condition SEMICOLON
    (65) assign -> . VVAR ASSIGN condition SEMICOLON
    (66) assign -> . SVAR ASSIGN condition SEMICOLON
    (67) assign -> . TVAR ASSIGN conversion SEMICOLON
    (68) assign -> . AVAR ASSIGN conversion SEMICOLON
    (69) assign -> . VVAR ASSIGN conversion SEMICOLON
    (70) assign -> . SVAR ASSIGN conversion SEMICOLON
    (71) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (72) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (73) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (74) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (75) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (76) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (77) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (78) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (79) assign -> . TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (80) assign -> . AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (81) assign -> . VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (82) assign -> . SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (83) assign -> . SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (84) assign -> . RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (85) assign -> . TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (86) assign -> . AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (87) assign -> . VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (88) assign -> . SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (102) declaration -> . var
    (103) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (104) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (105) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (106) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (107) declaration -> . SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (108) declaration -> . RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (109) declaration -> . TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (110) declaration -> . AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (111) declaration -> . VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (112) declaration -> . SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (113) declaration -> . SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (114) declaration -> . RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (115) empty -> .
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    SPVAR           shift and go to state 21
    RAVAR           shift and go to state 22
    $end            reduce using rule 115 (empty -> .)

    exit                           shift and go to state 8
    body                           shift and go to state 30
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    print                          shift and go to state 7
    tag                            shift and go to state 9
    if                             shift and go to state 10
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 9

    (6) body -> tag . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) print -> . PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (25) print -> . PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (26) print -> . PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (27) print -> . PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (28) print -> . PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (29) print -> . PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (30) print -> . PRINT L_PAR STRING R_PAR SEMICOLON
    (31) exit -> . EXIT SEMICOLON
    (32) tag -> . NAME COLON
    (33) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (63) assign -> . TVAR ASSIGN condition SEMICOLON
    (64) assign -> . AVAR ASSIGN condition SEMICOLON
    (65) assign -> . VVAR ASSIGN condition SEMICOLON
    (66) assign -> . SVAR ASSIGN condition SEMICOLON
    (67) assign -> . TVAR ASSIGN conversion SEMICOLON
    (68) assign -> . AVAR ASSIGN conversion SEMICOLON
    (69) assign -> . VVAR ASSIGN conversion SEMICOLON
    (70) assign -> . SVAR ASSIGN conversion SEMICOLON
    (71) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (72) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (73) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (74) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (75) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (76) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (77) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (78) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (79) assign -> . TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (80) assign -> . AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (81) assign -> . VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (82) assign -> . SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (83) assign -> . SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (84) assign -> . RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (85) assign -> . TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (86) assign -> . AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (87) assign -> . VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (88) assign -> . SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (102) declaration -> . var
    (103) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (104) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (105) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (106) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (107) declaration -> . SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (108) declaration -> . RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (109) declaration -> . TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (110) declaration -> . AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (111) declaration -> . VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (112) declaration -> . SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (113) declaration -> . SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (114) declaration -> . RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (115) empty -> .
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    SPVAR           shift and go to state 21
    RAVAR           shift and go to state 22
    $end            reduce using rule 115 (empty -> .)

    tag                            shift and go to state 9
    body                           shift and go to state 31
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    print                          shift and go to state 7
    exit                           shift and go to state 8
    if                             shift and go to state 10
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 10

    (7) body -> if . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) print -> . PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (25) print -> . PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (26) print -> . PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (27) print -> . PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (28) print -> . PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (29) print -> . PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (30) print -> . PRINT L_PAR STRING R_PAR SEMICOLON
    (31) exit -> . EXIT SEMICOLON
    (32) tag -> . NAME COLON
    (33) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (63) assign -> . TVAR ASSIGN condition SEMICOLON
    (64) assign -> . AVAR ASSIGN condition SEMICOLON
    (65) assign -> . VVAR ASSIGN condition SEMICOLON
    (66) assign -> . SVAR ASSIGN condition SEMICOLON
    (67) assign -> . TVAR ASSIGN conversion SEMICOLON
    (68) assign -> . AVAR ASSIGN conversion SEMICOLON
    (69) assign -> . VVAR ASSIGN conversion SEMICOLON
    (70) assign -> . SVAR ASSIGN conversion SEMICOLON
    (71) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (72) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (73) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (74) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (75) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (76) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (77) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (78) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (79) assign -> . TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (80) assign -> . AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (81) assign -> . VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (82) assign -> . SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (83) assign -> . SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (84) assign -> . RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (85) assign -> . TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (86) assign -> . AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (87) assign -> . VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (88) assign -> . SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (102) declaration -> . var
    (103) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (104) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (105) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (106) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (107) declaration -> . SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (108) declaration -> . RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (109) declaration -> . TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (110) declaration -> . AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (111) declaration -> . VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (112) declaration -> . SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (113) declaration -> . SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (114) declaration -> . RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (115) empty -> .
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    SPVAR           shift and go to state 21
    RAVAR           shift and go to state 22
    $end            reduce using rule 115 (empty -> .)

    if                             shift and go to state 10
    body                           shift and go to state 32
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    print                          shift and go to state 7
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 11

    (8) body -> assign . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) print -> . PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (25) print -> . PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (26) print -> . PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (27) print -> . PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (28) print -> . PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (29) print -> . PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (30) print -> . PRINT L_PAR STRING R_PAR SEMICOLON
    (31) exit -> . EXIT SEMICOLON
    (32) tag -> . NAME COLON
    (33) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (63) assign -> . TVAR ASSIGN condition SEMICOLON
    (64) assign -> . AVAR ASSIGN condition SEMICOLON
    (65) assign -> . VVAR ASSIGN condition SEMICOLON
    (66) assign -> . SVAR ASSIGN condition SEMICOLON
    (67) assign -> . TVAR ASSIGN conversion SEMICOLON
    (68) assign -> . AVAR ASSIGN conversion SEMICOLON
    (69) assign -> . VVAR ASSIGN conversion SEMICOLON
    (70) assign -> . SVAR ASSIGN conversion SEMICOLON
    (71) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (72) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (73) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (74) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (75) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (76) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (77) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (78) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (79) assign -> . TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (80) assign -> . AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (81) assign -> . VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (82) assign -> . SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (83) assign -> . SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (84) assign -> . RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (85) assign -> . TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (86) assign -> . AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (87) assign -> . VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (88) assign -> . SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (102) declaration -> . var
    (103) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (104) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (105) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (106) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (107) declaration -> . SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (108) declaration -> . RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (109) declaration -> . TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (110) declaration -> . AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (111) declaration -> . VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (112) declaration -> . SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (113) declaration -> . SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (114) declaration -> . RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (115) empty -> .
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    SPVAR           shift and go to state 21
    RAVAR           shift and go to state 22
    $end            reduce using rule 115 (empty -> .)

    assign                         shift and go to state 11
    body                           shift and go to state 33
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    print                          shift and go to state 7
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    if                             shift and go to state 10
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 12

    (9) body -> declaration . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) print -> . PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (25) print -> . PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (26) print -> . PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (27) print -> . PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (28) print -> . PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (29) print -> . PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (30) print -> . PRINT L_PAR STRING R_PAR SEMICOLON
    (31) exit -> . EXIT SEMICOLON
    (32) tag -> . NAME COLON
    (33) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (63) assign -> . TVAR ASSIGN condition SEMICOLON
    (64) assign -> . AVAR ASSIGN condition SEMICOLON
    (65) assign -> . VVAR ASSIGN condition SEMICOLON
    (66) assign -> . SVAR ASSIGN condition SEMICOLON
    (67) assign -> . TVAR ASSIGN conversion SEMICOLON
    (68) assign -> . AVAR ASSIGN conversion SEMICOLON
    (69) assign -> . VVAR ASSIGN conversion SEMICOLON
    (70) assign -> . SVAR ASSIGN conversion SEMICOLON
    (71) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (72) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (73) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (74) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (75) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (76) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (77) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (78) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (79) assign -> . TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (80) assign -> . AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (81) assign -> . VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (82) assign -> . SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (83) assign -> . SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (84) assign -> . RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (85) assign -> . TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (86) assign -> . AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (87) assign -> . VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (88) assign -> . SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (102) declaration -> . var
    (103) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (104) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (105) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (106) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (107) declaration -> . SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (108) declaration -> . RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (109) declaration -> . TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (110) declaration -> . AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (111) declaration -> . VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (112) declaration -> . SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (113) declaration -> . SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (114) declaration -> . RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON
    (115) empty -> .
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    SPVAR           shift and go to state 21
    RAVAR           shift and go to state 22
    $end            reduce using rule 115 (empty -> .)

    declaration                    shift and go to state 12
    body                           shift and go to state 34
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    print                          shift and go to state 7
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    if                             shift and go to state 10
    assign                         shift and go to state 11
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 13

    (10) body -> empty .

    $end            reduce using rule 10 (body -> empty .)


state 14

    (11) goto -> GOTO . NAME SEMICOLON

    NAME            shift and go to state 35


state 15

    (32) tag -> NAME . COLON

    COLON           shift and go to state 36


state 16

    (12) unset -> UNSET . L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> UNSET . L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> UNSET . L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> UNSET . L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> UNSET . L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> UNSET . L_PAR RAVAR R_PAR SEMICOLON

    L_PAR           shift and go to state 37


state 17

    (63) assign -> TVAR . ASSIGN condition SEMICOLON
    (67) assign -> TVAR . ASSIGN conversion SEMICOLON
    (71) assign -> TVAR . ASSIGN READ L_PAR R_PAR SEMICOLON
    (75) assign -> TVAR . ASSIGN bitwise SEMICOLON
    (79) assign -> TVAR . L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (85) assign -> TVAR . ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (103) declaration -> TVAR . ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (109) declaration -> TVAR . L_BRACKET arithmetic R_BRACKET SEMICOLON
    (56) var -> TVAR .

    ASSIGN          shift and go to state 38
    L_BRACKET       shift and go to state 39
    GOTO            reduce using rule 56 (var -> TVAR .)
    UNSET           reduce using rule 56 (var -> TVAR .)
    PRINT           reduce using rule 56 (var -> TVAR .)
    EXIT            reduce using rule 56 (var -> TVAR .)
    NAME            reduce using rule 56 (var -> TVAR .)
    IF              reduce using rule 56 (var -> TVAR .)
    TVAR            reduce using rule 56 (var -> TVAR .)
    AVAR            reduce using rule 56 (var -> TVAR .)
    VVAR            reduce using rule 56 (var -> TVAR .)
    SVAR            reduce using rule 56 (var -> TVAR .)
    SPVAR           reduce using rule 56 (var -> TVAR .)
    RAVAR           reduce using rule 56 (var -> TVAR .)
    $end            reduce using rule 56 (var -> TVAR .)


state 18

    (64) assign -> AVAR . ASSIGN condition SEMICOLON
    (68) assign -> AVAR . ASSIGN conversion SEMICOLON
    (72) assign -> AVAR . ASSIGN READ L_PAR R_PAR SEMICOLON
    (76) assign -> AVAR . ASSIGN bitwise SEMICOLON
    (80) assign -> AVAR . L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (86) assign -> AVAR . ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (104) declaration -> AVAR . ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (110) declaration -> AVAR . L_BRACKET arithmetic R_BRACKET SEMICOLON
    (57) var -> AVAR .

    ASSIGN          shift and go to state 40
    L_BRACKET       shift and go to state 41
    GOTO            reduce using rule 57 (var -> AVAR .)
    UNSET           reduce using rule 57 (var -> AVAR .)
    PRINT           reduce using rule 57 (var -> AVAR .)
    EXIT            reduce using rule 57 (var -> AVAR .)
    NAME            reduce using rule 57 (var -> AVAR .)
    IF              reduce using rule 57 (var -> AVAR .)
    TVAR            reduce using rule 57 (var -> AVAR .)
    AVAR            reduce using rule 57 (var -> AVAR .)
    VVAR            reduce using rule 57 (var -> AVAR .)
    SVAR            reduce using rule 57 (var -> AVAR .)
    SPVAR           reduce using rule 57 (var -> AVAR .)
    RAVAR           reduce using rule 57 (var -> AVAR .)
    $end            reduce using rule 57 (var -> AVAR .)


state 19

    (65) assign -> VVAR . ASSIGN condition SEMICOLON
    (69) assign -> VVAR . ASSIGN conversion SEMICOLON
    (73) assign -> VVAR . ASSIGN READ L_PAR R_PAR SEMICOLON
    (77) assign -> VVAR . ASSIGN bitwise SEMICOLON
    (81) assign -> VVAR . L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (87) assign -> VVAR . ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (105) declaration -> VVAR . ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (111) declaration -> VVAR . L_BRACKET arithmetic R_BRACKET SEMICOLON
    (58) var -> VVAR .

    ASSIGN          shift and go to state 42
    L_BRACKET       shift and go to state 43
    GOTO            reduce using rule 58 (var -> VVAR .)
    UNSET           reduce using rule 58 (var -> VVAR .)
    PRINT           reduce using rule 58 (var -> VVAR .)
    EXIT            reduce using rule 58 (var -> VVAR .)
    NAME            reduce using rule 58 (var -> VVAR .)
    IF              reduce using rule 58 (var -> VVAR .)
    TVAR            reduce using rule 58 (var -> VVAR .)
    AVAR            reduce using rule 58 (var -> VVAR .)
    VVAR            reduce using rule 58 (var -> VVAR .)
    SVAR            reduce using rule 58 (var -> VVAR .)
    SPVAR           reduce using rule 58 (var -> VVAR .)
    RAVAR           reduce using rule 58 (var -> VVAR .)
    $end            reduce using rule 58 (var -> VVAR .)


state 20

    (66) assign -> SVAR . ASSIGN condition SEMICOLON
    (70) assign -> SVAR . ASSIGN conversion SEMICOLON
    (74) assign -> SVAR . ASSIGN READ L_PAR R_PAR SEMICOLON
    (78) assign -> SVAR . ASSIGN bitwise SEMICOLON
    (82) assign -> SVAR . L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (88) assign -> SVAR . ASSIGN ABS L_PAR var R_PAR SEMICOLON
    (106) declaration -> SVAR . ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (112) declaration -> SVAR . L_BRACKET arithmetic R_BRACKET SEMICOLON
    (59) var -> SVAR .

    ASSIGN          shift and go to state 44
    L_BRACKET       shift and go to state 45
    GOTO            reduce using rule 59 (var -> SVAR .)
    UNSET           reduce using rule 59 (var -> SVAR .)
    PRINT           reduce using rule 59 (var -> SVAR .)
    EXIT            reduce using rule 59 (var -> SVAR .)
    NAME            reduce using rule 59 (var -> SVAR .)
    IF              reduce using rule 59 (var -> SVAR .)
    TVAR            reduce using rule 59 (var -> SVAR .)
    AVAR            reduce using rule 59 (var -> SVAR .)
    VVAR            reduce using rule 59 (var -> SVAR .)
    SVAR            reduce using rule 59 (var -> SVAR .)
    SPVAR           reduce using rule 59 (var -> SVAR .)
    RAVAR           reduce using rule 59 (var -> SVAR .)
    $end            reduce using rule 59 (var -> SVAR .)


state 21

    (83) assign -> SPVAR . L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (107) declaration -> SPVAR . ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (113) declaration -> SPVAR . L_BRACKET arithmetic R_BRACKET SEMICOLON
    (61) var -> SPVAR .

    L_BRACKET       shift and go to state 46
    ASSIGN          shift and go to state 47
    GOTO            reduce using rule 61 (var -> SPVAR .)
    UNSET           reduce using rule 61 (var -> SPVAR .)
    PRINT           reduce using rule 61 (var -> SPVAR .)
    EXIT            reduce using rule 61 (var -> SPVAR .)
    NAME            reduce using rule 61 (var -> SPVAR .)
    IF              reduce using rule 61 (var -> SPVAR .)
    TVAR            reduce using rule 61 (var -> SPVAR .)
    AVAR            reduce using rule 61 (var -> SPVAR .)
    VVAR            reduce using rule 61 (var -> SPVAR .)
    SVAR            reduce using rule 61 (var -> SPVAR .)
    SPVAR           reduce using rule 61 (var -> SPVAR .)
    RAVAR           reduce using rule 61 (var -> SPVAR .)
    $end            reduce using rule 61 (var -> SPVAR .)


state 22

    (84) assign -> RAVAR . L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (108) declaration -> RAVAR . ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (114) declaration -> RAVAR . L_BRACKET arithmetic R_BRACKET SEMICOLON
    (60) var -> RAVAR .

    L_BRACKET       shift and go to state 48
    ASSIGN          shift and go to state 49
    GOTO            reduce using rule 60 (var -> RAVAR .)
    UNSET           reduce using rule 60 (var -> RAVAR .)
    PRINT           reduce using rule 60 (var -> RAVAR .)
    EXIT            reduce using rule 60 (var -> RAVAR .)
    NAME            reduce using rule 60 (var -> RAVAR .)
    IF              reduce using rule 60 (var -> RAVAR .)
    TVAR            reduce using rule 60 (var -> RAVAR .)
    AVAR            reduce using rule 60 (var -> RAVAR .)
    VVAR            reduce using rule 60 (var -> RAVAR .)
    SVAR            reduce using rule 60 (var -> RAVAR .)
    SPVAR           reduce using rule 60 (var -> RAVAR .)
    RAVAR           reduce using rule 60 (var -> RAVAR .)
    $end            reduce using rule 60 (var -> RAVAR .)


state 23

    (18) print -> PRINT . L_PAR TVAR R_PAR SEMICOLON
    (19) print -> PRINT . L_PAR AVAR R_PAR SEMICOLON
    (20) print -> PRINT . L_PAR VVAR R_PAR SEMICOLON
    (21) print -> PRINT . L_PAR SVAR R_PAR SEMICOLON
    (22) print -> PRINT . L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> PRINT . L_PAR RAVAR R_PAR SEMICOLON
    (24) print -> PRINT . L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (25) print -> PRINT . L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (26) print -> PRINT . L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (27) print -> PRINT . L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (28) print -> PRINT . L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (29) print -> PRINT . L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (30) print -> PRINT . L_PAR STRING R_PAR SEMICOLON

    L_PAR           shift and go to state 50


state 24

    (31) exit -> EXIT . SEMICOLON

    SEMICOLON       shift and go to state 51


state 25

    (33) if -> IF . L_PAR condition R_PAR GOTO NAME SEMICOLON

    L_PAR           shift and go to state 52


state 26

    (102) declaration -> var .

    GOTO            reduce using rule 102 (declaration -> var .)
    UNSET           reduce using rule 102 (declaration -> var .)
    PRINT           reduce using rule 102 (declaration -> var .)
    EXIT            reduce using rule 102 (declaration -> var .)
    NAME            reduce using rule 102 (declaration -> var .)
    IF              reduce using rule 102 (declaration -> var .)
    TVAR            reduce using rule 102 (declaration -> var .)
    AVAR            reduce using rule 102 (declaration -> var .)
    VVAR            reduce using rule 102 (declaration -> var .)
    SVAR            reduce using rule 102 (declaration -> var .)
    SPVAR           reduce using rule 102 (declaration -> var .)
    RAVAR           reduce using rule 102 (declaration -> var .)
    $end            reduce using rule 102 (declaration -> var .)


state 27

    (2) body -> goto body .

    $end            reduce using rule 2 (body -> goto body .)


state 28

    (3) body -> unset body .

    $end            reduce using rule 3 (body -> unset body .)


state 29

    (4) body -> print body .

    $end            reduce using rule 4 (body -> print body .)


state 30

    (5) body -> exit body .

    $end            reduce using rule 5 (body -> exit body .)


state 31

    (6) body -> tag body .

    $end            reduce using rule 6 (body -> tag body .)


state 32

    (7) body -> if body .

    $end            reduce using rule 7 (body -> if body .)


state 33

    (8) body -> assign body .

    $end            reduce using rule 8 (body -> assign body .)


state 34

    (9) body -> declaration body .

    $end            reduce using rule 9 (body -> declaration body .)


state 35

    (11) goto -> GOTO NAME . SEMICOLON

    SEMICOLON       shift and go to state 53


state 36

    (32) tag -> NAME COLON .

    GOTO            reduce using rule 32 (tag -> NAME COLON .)
    UNSET           reduce using rule 32 (tag -> NAME COLON .)
    PRINT           reduce using rule 32 (tag -> NAME COLON .)
    EXIT            reduce using rule 32 (tag -> NAME COLON .)
    NAME            reduce using rule 32 (tag -> NAME COLON .)
    IF              reduce using rule 32 (tag -> NAME COLON .)
    TVAR            reduce using rule 32 (tag -> NAME COLON .)
    AVAR            reduce using rule 32 (tag -> NAME COLON .)
    VVAR            reduce using rule 32 (tag -> NAME COLON .)
    SVAR            reduce using rule 32 (tag -> NAME COLON .)
    SPVAR           reduce using rule 32 (tag -> NAME COLON .)
    RAVAR           reduce using rule 32 (tag -> NAME COLON .)
    $end            reduce using rule 32 (tag -> NAME COLON .)


state 37

    (12) unset -> UNSET L_PAR . TVAR R_PAR SEMICOLON
    (13) unset -> UNSET L_PAR . AVAR R_PAR SEMICOLON
    (14) unset -> UNSET L_PAR . VVAR R_PAR SEMICOLON
    (15) unset -> UNSET L_PAR . SVAR R_PAR SEMICOLON
    (16) unset -> UNSET L_PAR . SPVAR R_PAR SEMICOLON
    (17) unset -> UNSET L_PAR . RAVAR R_PAR SEMICOLON

    TVAR            shift and go to state 54
    AVAR            shift and go to state 55
    VVAR            shift and go to state 56
    SVAR            shift and go to state 57
    SPVAR           shift and go to state 58
    RAVAR           shift and go to state 59


state 38

    (63) assign -> TVAR ASSIGN . condition SEMICOLON
    (67) assign -> TVAR ASSIGN . conversion SEMICOLON
    (71) assign -> TVAR ASSIGN . READ L_PAR R_PAR SEMICOLON
    (75) assign -> TVAR ASSIGN . bitwise SEMICOLON
    (85) assign -> TVAR ASSIGN . ABS L_PAR var R_PAR SEMICOLON
    (103) declaration -> TVAR ASSIGN . ARRAY L_PAR R_PAR SEMICOLON
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (98) conversion -> . L_PAR type R_PAR var
    (89) bitwise -> . var AND_B var
    (90) bitwise -> . var OR_B var
    (91) bitwise -> . var XOR_B var
    (92) bitwise -> . var SHIFT_L var
    (93) bitwise -> . var SHIFT_R var
    (94) bitwise -> . NOT_B TVAR
    (95) bitwise -> . NOT_B AVAR
    (96) bitwise -> . NOT_B VVAR
    (97) bitwise -> . NOT_B SVAR
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    READ            shift and go to state 63
    ABS             shift and go to state 66
    ARRAY           shift and go to state 68
    NOT             shift and go to state 69
    L_PAR           shift and go to state 64
    NOT_B           shift and go to state 71
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    condition                      shift and go to state 61
    conversion                     shift and go to state 62
    bitwise                        shift and go to state 65
    var                            shift and go to state 67
    relational                     shift and go to state 70
    arithmetic                     shift and go to state 75
    array_access                   shift and go to state 82

state 39

    (79) assign -> TVAR L_BRACKET . arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (109) declaration -> TVAR L_BRACKET . arithmetic R_BRACKET SEMICOLON
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    R_BRACKET       reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 83
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 40

    (64) assign -> AVAR ASSIGN . condition SEMICOLON
    (68) assign -> AVAR ASSIGN . conversion SEMICOLON
    (72) assign -> AVAR ASSIGN . READ L_PAR R_PAR SEMICOLON
    (76) assign -> AVAR ASSIGN . bitwise SEMICOLON
    (86) assign -> AVAR ASSIGN . ABS L_PAR var R_PAR SEMICOLON
    (104) declaration -> AVAR ASSIGN . ARRAY L_PAR R_PAR SEMICOLON
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (98) conversion -> . L_PAR type R_PAR var
    (89) bitwise -> . var AND_B var
    (90) bitwise -> . var OR_B var
    (91) bitwise -> . var XOR_B var
    (92) bitwise -> . var SHIFT_L var
    (93) bitwise -> . var SHIFT_R var
    (94) bitwise -> . NOT_B TVAR
    (95) bitwise -> . NOT_B AVAR
    (96) bitwise -> . NOT_B VVAR
    (97) bitwise -> . NOT_B SVAR
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    READ            shift and go to state 87
    ABS             shift and go to state 89
    ARRAY           shift and go to state 90
    NOT             shift and go to state 69
    L_PAR           shift and go to state 64
    NOT_B           shift and go to state 71
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    condition                      shift and go to state 85
    conversion                     shift and go to state 86
    bitwise                        shift and go to state 88
    var                            shift and go to state 67
    relational                     shift and go to state 70
    arithmetic                     shift and go to state 75
    array_access                   shift and go to state 82

state 41

    (80) assign -> AVAR L_BRACKET . arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (110) declaration -> AVAR L_BRACKET . arithmetic R_BRACKET SEMICOLON
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    R_BRACKET       reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 91
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 42

    (65) assign -> VVAR ASSIGN . condition SEMICOLON
    (69) assign -> VVAR ASSIGN . conversion SEMICOLON
    (73) assign -> VVAR ASSIGN . READ L_PAR R_PAR SEMICOLON
    (77) assign -> VVAR ASSIGN . bitwise SEMICOLON
    (87) assign -> VVAR ASSIGN . ABS L_PAR var R_PAR SEMICOLON
    (105) declaration -> VVAR ASSIGN . ARRAY L_PAR R_PAR SEMICOLON
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (98) conversion -> . L_PAR type R_PAR var
    (89) bitwise -> . var AND_B var
    (90) bitwise -> . var OR_B var
    (91) bitwise -> . var XOR_B var
    (92) bitwise -> . var SHIFT_L var
    (93) bitwise -> . var SHIFT_R var
    (94) bitwise -> . NOT_B TVAR
    (95) bitwise -> . NOT_B AVAR
    (96) bitwise -> . NOT_B VVAR
    (97) bitwise -> . NOT_B SVAR
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    READ            shift and go to state 94
    ABS             shift and go to state 96
    ARRAY           shift and go to state 97
    NOT             shift and go to state 69
    L_PAR           shift and go to state 64
    NOT_B           shift and go to state 71
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    condition                      shift and go to state 92
    conversion                     shift and go to state 93
    bitwise                        shift and go to state 95
    var                            shift and go to state 67
    relational                     shift and go to state 70
    arithmetic                     shift and go to state 75
    array_access                   shift and go to state 82

state 43

    (81) assign -> VVAR L_BRACKET . arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (111) declaration -> VVAR L_BRACKET . arithmetic R_BRACKET SEMICOLON
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    R_BRACKET       reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 98
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 44

    (66) assign -> SVAR ASSIGN . condition SEMICOLON
    (70) assign -> SVAR ASSIGN . conversion SEMICOLON
    (74) assign -> SVAR ASSIGN . READ L_PAR R_PAR SEMICOLON
    (78) assign -> SVAR ASSIGN . bitwise SEMICOLON
    (88) assign -> SVAR ASSIGN . ABS L_PAR var R_PAR SEMICOLON
    (106) declaration -> SVAR ASSIGN . ARRAY L_PAR R_PAR SEMICOLON
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (98) conversion -> . L_PAR type R_PAR var
    (89) bitwise -> . var AND_B var
    (90) bitwise -> . var OR_B var
    (91) bitwise -> . var XOR_B var
    (92) bitwise -> . var SHIFT_L var
    (93) bitwise -> . var SHIFT_R var
    (94) bitwise -> . NOT_B TVAR
    (95) bitwise -> . NOT_B AVAR
    (96) bitwise -> . NOT_B VVAR
    (97) bitwise -> . NOT_B SVAR
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    READ            shift and go to state 101
    ABS             shift and go to state 103
    ARRAY           shift and go to state 104
    NOT             shift and go to state 69
    L_PAR           shift and go to state 64
    NOT_B           shift and go to state 71
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    condition                      shift and go to state 99
    conversion                     shift and go to state 100
    bitwise                        shift and go to state 102
    var                            shift and go to state 67
    relational                     shift and go to state 70
    arithmetic                     shift and go to state 75
    array_access                   shift and go to state 82

state 45

    (82) assign -> SVAR L_BRACKET . arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (112) declaration -> SVAR L_BRACKET . arithmetic R_BRACKET SEMICOLON
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    R_BRACKET       reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 105
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 46

    (83) assign -> SPVAR L_BRACKET . arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (113) declaration -> SPVAR L_BRACKET . arithmetic R_BRACKET SEMICOLON
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    R_BRACKET       reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 106
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 47

    (107) declaration -> SPVAR ASSIGN . ARRAY L_PAR R_PAR SEMICOLON

    ARRAY           shift and go to state 107


state 48

    (84) assign -> RAVAR L_BRACKET . arithmetic R_BRACKET ASSIGN condition SEMICOLON
    (114) declaration -> RAVAR L_BRACKET . arithmetic R_BRACKET SEMICOLON
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    R_BRACKET       reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 108
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 49

    (108) declaration -> RAVAR ASSIGN . ARRAY L_PAR R_PAR SEMICOLON

    ARRAY           shift and go to state 109


state 50

    (18) print -> PRINT L_PAR . TVAR R_PAR SEMICOLON
    (19) print -> PRINT L_PAR . AVAR R_PAR SEMICOLON
    (20) print -> PRINT L_PAR . VVAR R_PAR SEMICOLON
    (21) print -> PRINT L_PAR . SVAR R_PAR SEMICOLON
    (22) print -> PRINT L_PAR . SPVAR R_PAR SEMICOLON
    (23) print -> PRINT L_PAR . RAVAR R_PAR SEMICOLON
    (24) print -> PRINT L_PAR . TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (25) print -> PRINT L_PAR . AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (26) print -> PRINT L_PAR . VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (27) print -> PRINT L_PAR . SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (28) print -> PRINT L_PAR . SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (29) print -> PRINT L_PAR . RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON
    (30) print -> PRINT L_PAR . STRING R_PAR SEMICOLON

    TVAR            shift and go to state 110
    AVAR            shift and go to state 111
    VVAR            shift and go to state 112
    SVAR            shift and go to state 113
    SPVAR           shift and go to state 114
    RAVAR           shift and go to state 115
    STRING          shift and go to state 116


state 51

    (31) exit -> EXIT SEMICOLON .

    GOTO            reduce using rule 31 (exit -> EXIT SEMICOLON .)
    UNSET           reduce using rule 31 (exit -> EXIT SEMICOLON .)
    PRINT           reduce using rule 31 (exit -> EXIT SEMICOLON .)
    EXIT            reduce using rule 31 (exit -> EXIT SEMICOLON .)
    NAME            reduce using rule 31 (exit -> EXIT SEMICOLON .)
    IF              reduce using rule 31 (exit -> EXIT SEMICOLON .)
    TVAR            reduce using rule 31 (exit -> EXIT SEMICOLON .)
    AVAR            reduce using rule 31 (exit -> EXIT SEMICOLON .)
    VVAR            reduce using rule 31 (exit -> EXIT SEMICOLON .)
    SVAR            reduce using rule 31 (exit -> EXIT SEMICOLON .)
    SPVAR           reduce using rule 31 (exit -> EXIT SEMICOLON .)
    RAVAR           reduce using rule 31 (exit -> EXIT SEMICOLON .)
    $end            reduce using rule 31 (exit -> EXIT SEMICOLON .)


state 52

    (33) if -> IF L_PAR . condition R_PAR GOTO NAME SEMICOLON
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NOT             shift and go to state 69
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    condition                      shift and go to state 117
    relational                     shift and go to state 70
    arithmetic                     shift and go to state 75
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 53

    (11) goto -> GOTO NAME SEMICOLON .

    GOTO            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    UNSET           reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    PRINT           reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    EXIT            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    NAME            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    IF              reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    TVAR            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    AVAR            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    VVAR            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    SVAR            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    SPVAR           reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    RAVAR           reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    $end            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)


state 54

    (12) unset -> UNSET L_PAR TVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 118


state 55

    (13) unset -> UNSET L_PAR AVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 119


state 56

    (14) unset -> UNSET L_PAR VVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 120


state 57

    (15) unset -> UNSET L_PAR SVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 121


state 58

    (16) unset -> UNSET L_PAR SPVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 122


state 59

    (17) unset -> UNSET L_PAR RAVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 123


state 60

    (56) var -> TVAR .

    AND_B           reduce using rule 56 (var -> TVAR .)
    OR_B            reduce using rule 56 (var -> TVAR .)
    XOR_B           reduce using rule 56 (var -> TVAR .)
    SHIFT_L         reduce using rule 56 (var -> TVAR .)
    SHIFT_R         reduce using rule 56 (var -> TVAR .)
    EQUAL           reduce using rule 56 (var -> TVAR .)
    NOT_EQUAL       reduce using rule 56 (var -> TVAR .)
    GREATER         reduce using rule 56 (var -> TVAR .)
    LESS            reduce using rule 56 (var -> TVAR .)
    GREATER_EQUAL   reduce using rule 56 (var -> TVAR .)
    LESS_EQUAL      reduce using rule 56 (var -> TVAR .)
    PLUS            reduce using rule 56 (var -> TVAR .)
    MINUS           reduce using rule 56 (var -> TVAR .)
    MULTIPLY        reduce using rule 56 (var -> TVAR .)
    DIVIDE          reduce using rule 56 (var -> TVAR .)
    REMAINDER       reduce using rule 56 (var -> TVAR .)
    SEMICOLON       reduce using rule 56 (var -> TVAR .)
    AND             reduce using rule 56 (var -> TVAR .)
    OR              reduce using rule 56 (var -> TVAR .)
    R_BRACKET       reduce using rule 56 (var -> TVAR .)
    R_PAR           reduce using rule 56 (var -> TVAR .)


state 61

    (63) assign -> TVAR ASSIGN condition . SEMICOLON
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

    SEMICOLON       shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126


state 62

    (67) assign -> TVAR ASSIGN conversion . SEMICOLON

    SEMICOLON       shift and go to state 127


state 63

    (71) assign -> TVAR ASSIGN READ . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 128


state 64

    (98) conversion -> L_PAR . type R_PAR var
    (99) type -> . INT
    (100) type -> . FLOAT
    (101) type -> . CHAR

    INT             shift and go to state 130
    FLOAT           shift and go to state 131
    CHAR            shift and go to state 132

    type                           shift and go to state 129

state 65

    (75) assign -> TVAR ASSIGN bitwise . SEMICOLON

    SEMICOLON       shift and go to state 133


state 66

    (85) assign -> TVAR ASSIGN ABS . L_PAR var R_PAR SEMICOLON

    L_PAR           shift and go to state 134


state 67

    (89) bitwise -> var . AND_B var
    (90) bitwise -> var . OR_B var
    (91) bitwise -> var . XOR_B var
    (92) bitwise -> var . SHIFT_L var
    (93) bitwise -> var . SHIFT_R var
    (53) arithmetic -> var .

    AND_B           shift and go to state 135
    OR_B            shift and go to state 136
    XOR_B           shift and go to state 137
    SHIFT_L         shift and go to state 138
    SHIFT_R         shift and go to state 139
    EQUAL           reduce using rule 53 (arithmetic -> var .)
    NOT_EQUAL       reduce using rule 53 (arithmetic -> var .)
    GREATER         reduce using rule 53 (arithmetic -> var .)
    LESS            reduce using rule 53 (arithmetic -> var .)
    GREATER_EQUAL   reduce using rule 53 (arithmetic -> var .)
    LESS_EQUAL      reduce using rule 53 (arithmetic -> var .)
    PLUS            reduce using rule 53 (arithmetic -> var .)
    MINUS           reduce using rule 53 (arithmetic -> var .)
    MULTIPLY        reduce using rule 53 (arithmetic -> var .)
    DIVIDE          reduce using rule 53 (arithmetic -> var .)
    REMAINDER       reduce using rule 53 (arithmetic -> var .)
    SEMICOLON       reduce using rule 53 (arithmetic -> var .)
    AND             reduce using rule 53 (arithmetic -> var .)
    OR              reduce using rule 53 (arithmetic -> var .)


state 68

    (103) declaration -> TVAR ASSIGN ARRAY . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 140


state 69

    (36) condition -> NOT . condition
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NOT             shift and go to state 69
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    condition                      shift and go to state 141
    relational                     shift and go to state 70
    arithmetic                     shift and go to state 75
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 70

    (37) condition -> relational .

    SEMICOLON       reduce using rule 37 (condition -> relational .)
    AND             reduce using rule 37 (condition -> relational .)
    OR              reduce using rule 37 (condition -> relational .)
    R_PAR           reduce using rule 37 (condition -> relational .)


state 71

    (94) bitwise -> NOT_B . TVAR
    (95) bitwise -> NOT_B . AVAR
    (96) bitwise -> NOT_B . VVAR
    (97) bitwise -> NOT_B . SVAR

    TVAR            shift and go to state 142
    AVAR            shift and go to state 143
    VVAR            shift and go to state 144
    SVAR            shift and go to state 145


state 72

    (57) var -> AVAR .

    AND_B           reduce using rule 57 (var -> AVAR .)
    OR_B            reduce using rule 57 (var -> AVAR .)
    XOR_B           reduce using rule 57 (var -> AVAR .)
    SHIFT_L         reduce using rule 57 (var -> AVAR .)
    SHIFT_R         reduce using rule 57 (var -> AVAR .)
    EQUAL           reduce using rule 57 (var -> AVAR .)
    NOT_EQUAL       reduce using rule 57 (var -> AVAR .)
    GREATER         reduce using rule 57 (var -> AVAR .)
    LESS            reduce using rule 57 (var -> AVAR .)
    GREATER_EQUAL   reduce using rule 57 (var -> AVAR .)
    LESS_EQUAL      reduce using rule 57 (var -> AVAR .)
    PLUS            reduce using rule 57 (var -> AVAR .)
    MINUS           reduce using rule 57 (var -> AVAR .)
    MULTIPLY        reduce using rule 57 (var -> AVAR .)
    DIVIDE          reduce using rule 57 (var -> AVAR .)
    REMAINDER       reduce using rule 57 (var -> AVAR .)
    SEMICOLON       reduce using rule 57 (var -> AVAR .)
    AND             reduce using rule 57 (var -> AVAR .)
    OR              reduce using rule 57 (var -> AVAR .)
    R_BRACKET       reduce using rule 57 (var -> AVAR .)
    R_PAR           reduce using rule 57 (var -> AVAR .)


state 73

    (58) var -> VVAR .

    AND_B           reduce using rule 58 (var -> VVAR .)
    OR_B            reduce using rule 58 (var -> VVAR .)
    XOR_B           reduce using rule 58 (var -> VVAR .)
    SHIFT_L         reduce using rule 58 (var -> VVAR .)
    SHIFT_R         reduce using rule 58 (var -> VVAR .)
    EQUAL           reduce using rule 58 (var -> VVAR .)
    NOT_EQUAL       reduce using rule 58 (var -> VVAR .)
    GREATER         reduce using rule 58 (var -> VVAR .)
    LESS            reduce using rule 58 (var -> VVAR .)
    GREATER_EQUAL   reduce using rule 58 (var -> VVAR .)
    LESS_EQUAL      reduce using rule 58 (var -> VVAR .)
    PLUS            reduce using rule 58 (var -> VVAR .)
    MINUS           reduce using rule 58 (var -> VVAR .)
    MULTIPLY        reduce using rule 58 (var -> VVAR .)
    DIVIDE          reduce using rule 58 (var -> VVAR .)
    REMAINDER       reduce using rule 58 (var -> VVAR .)
    SEMICOLON       reduce using rule 58 (var -> VVAR .)
    AND             reduce using rule 58 (var -> VVAR .)
    OR              reduce using rule 58 (var -> VVAR .)
    R_BRACKET       reduce using rule 58 (var -> VVAR .)
    R_PAR           reduce using rule 58 (var -> VVAR .)


state 74

    (59) var -> SVAR .

    AND_B           reduce using rule 59 (var -> SVAR .)
    OR_B            reduce using rule 59 (var -> SVAR .)
    XOR_B           reduce using rule 59 (var -> SVAR .)
    SHIFT_L         reduce using rule 59 (var -> SVAR .)
    SHIFT_R         reduce using rule 59 (var -> SVAR .)
    EQUAL           reduce using rule 59 (var -> SVAR .)
    NOT_EQUAL       reduce using rule 59 (var -> SVAR .)
    GREATER         reduce using rule 59 (var -> SVAR .)
    LESS            reduce using rule 59 (var -> SVAR .)
    GREATER_EQUAL   reduce using rule 59 (var -> SVAR .)
    LESS_EQUAL      reduce using rule 59 (var -> SVAR .)
    PLUS            reduce using rule 59 (var -> SVAR .)
    MINUS           reduce using rule 59 (var -> SVAR .)
    MULTIPLY        reduce using rule 59 (var -> SVAR .)
    DIVIDE          reduce using rule 59 (var -> SVAR .)
    REMAINDER       reduce using rule 59 (var -> SVAR .)
    SEMICOLON       reduce using rule 59 (var -> SVAR .)
    AND             reduce using rule 59 (var -> SVAR .)
    OR              reduce using rule 59 (var -> SVAR .)
    R_BRACKET       reduce using rule 59 (var -> SVAR .)
    R_PAR           reduce using rule 59 (var -> SVAR .)


state 75

    (38) relational -> arithmetic . EQUAL arithmetic
    (39) relational -> arithmetic . NOT_EQUAL arithmetic
    (40) relational -> arithmetic . GREATER arithmetic
    (41) relational -> arithmetic . LESS arithmetic
    (42) relational -> arithmetic . GREATER_EQUAL arithmetic
    (43) relational -> arithmetic . LESS_EQUAL arithmetic
    (44) relational -> arithmetic .
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    EQUAL           shift and go to state 146
    NOT_EQUAL       shift and go to state 147
    GREATER         shift and go to state 148
    LESS            shift and go to state 149
    GREATER_EQUAL   shift and go to state 150
    LESS_EQUAL      shift and go to state 151
    SEMICOLON       reduce using rule 44 (relational -> arithmetic .)
    AND             reduce using rule 44 (relational -> arithmetic .)
    OR              reduce using rule 44 (relational -> arithmetic .)
    R_PAR           reduce using rule 44 (relational -> arithmetic .)
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 76

    (60) var -> RAVAR .

    AND_B           reduce using rule 60 (var -> RAVAR .)
    OR_B            reduce using rule 60 (var -> RAVAR .)
    XOR_B           reduce using rule 60 (var -> RAVAR .)
    SHIFT_L         reduce using rule 60 (var -> RAVAR .)
    SHIFT_R         reduce using rule 60 (var -> RAVAR .)
    EQUAL           reduce using rule 60 (var -> RAVAR .)
    NOT_EQUAL       reduce using rule 60 (var -> RAVAR .)
    GREATER         reduce using rule 60 (var -> RAVAR .)
    LESS            reduce using rule 60 (var -> RAVAR .)
    GREATER_EQUAL   reduce using rule 60 (var -> RAVAR .)
    LESS_EQUAL      reduce using rule 60 (var -> RAVAR .)
    PLUS            reduce using rule 60 (var -> RAVAR .)
    MINUS           reduce using rule 60 (var -> RAVAR .)
    MULTIPLY        reduce using rule 60 (var -> RAVAR .)
    DIVIDE          reduce using rule 60 (var -> RAVAR .)
    REMAINDER       reduce using rule 60 (var -> RAVAR .)
    SEMICOLON       reduce using rule 60 (var -> RAVAR .)
    AND             reduce using rule 60 (var -> RAVAR .)
    OR              reduce using rule 60 (var -> RAVAR .)
    R_BRACKET       reduce using rule 60 (var -> RAVAR .)
    R_PAR           reduce using rule 60 (var -> RAVAR .)


state 77

    (61) var -> SPVAR .

    AND_B           reduce using rule 61 (var -> SPVAR .)
    OR_B            reduce using rule 61 (var -> SPVAR .)
    XOR_B           reduce using rule 61 (var -> SPVAR .)
    SHIFT_L         reduce using rule 61 (var -> SPVAR .)
    SHIFT_R         reduce using rule 61 (var -> SPVAR .)
    EQUAL           reduce using rule 61 (var -> SPVAR .)
    NOT_EQUAL       reduce using rule 61 (var -> SPVAR .)
    GREATER         reduce using rule 61 (var -> SPVAR .)
    LESS            reduce using rule 61 (var -> SPVAR .)
    GREATER_EQUAL   reduce using rule 61 (var -> SPVAR .)
    LESS_EQUAL      reduce using rule 61 (var -> SPVAR .)
    PLUS            reduce using rule 61 (var -> SPVAR .)
    MINUS           reduce using rule 61 (var -> SPVAR .)
    MULTIPLY        reduce using rule 61 (var -> SPVAR .)
    DIVIDE          reduce using rule 61 (var -> SPVAR .)
    REMAINDER       reduce using rule 61 (var -> SPVAR .)
    SEMICOLON       reduce using rule 61 (var -> SPVAR .)
    AND             reduce using rule 61 (var -> SPVAR .)
    OR              reduce using rule 61 (var -> SPVAR .)
    R_BRACKET       reduce using rule 61 (var -> SPVAR .)
    R_PAR           reduce using rule 61 (var -> SPVAR .)


state 78

    (55) arithmetic -> MINUS . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    R_BRACKET       reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 157
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 79

    (50) arithmetic -> INTEGER .

    EQUAL           reduce using rule 50 (arithmetic -> INTEGER .)
    NOT_EQUAL       reduce using rule 50 (arithmetic -> INTEGER .)
    GREATER         reduce using rule 50 (arithmetic -> INTEGER .)
    LESS            reduce using rule 50 (arithmetic -> INTEGER .)
    GREATER_EQUAL   reduce using rule 50 (arithmetic -> INTEGER .)
    LESS_EQUAL      reduce using rule 50 (arithmetic -> INTEGER .)
    PLUS            reduce using rule 50 (arithmetic -> INTEGER .)
    MINUS           reduce using rule 50 (arithmetic -> INTEGER .)
    MULTIPLY        reduce using rule 50 (arithmetic -> INTEGER .)
    DIVIDE          reduce using rule 50 (arithmetic -> INTEGER .)
    REMAINDER       reduce using rule 50 (arithmetic -> INTEGER .)
    SEMICOLON       reduce using rule 50 (arithmetic -> INTEGER .)
    AND             reduce using rule 50 (arithmetic -> INTEGER .)
    OR              reduce using rule 50 (arithmetic -> INTEGER .)
    R_BRACKET       reduce using rule 50 (arithmetic -> INTEGER .)
    R_PAR           reduce using rule 50 (arithmetic -> INTEGER .)


state 80

    (51) arithmetic -> DECIMAL .

    EQUAL           reduce using rule 51 (arithmetic -> DECIMAL .)
    NOT_EQUAL       reduce using rule 51 (arithmetic -> DECIMAL .)
    GREATER         reduce using rule 51 (arithmetic -> DECIMAL .)
    LESS            reduce using rule 51 (arithmetic -> DECIMAL .)
    GREATER_EQUAL   reduce using rule 51 (arithmetic -> DECIMAL .)
    LESS_EQUAL      reduce using rule 51 (arithmetic -> DECIMAL .)
    PLUS            reduce using rule 51 (arithmetic -> DECIMAL .)
    MINUS           reduce using rule 51 (arithmetic -> DECIMAL .)
    MULTIPLY        reduce using rule 51 (arithmetic -> DECIMAL .)
    DIVIDE          reduce using rule 51 (arithmetic -> DECIMAL .)
    REMAINDER       reduce using rule 51 (arithmetic -> DECIMAL .)
    SEMICOLON       reduce using rule 51 (arithmetic -> DECIMAL .)
    AND             reduce using rule 51 (arithmetic -> DECIMAL .)
    OR              reduce using rule 51 (arithmetic -> DECIMAL .)
    R_BRACKET       reduce using rule 51 (arithmetic -> DECIMAL .)
    R_PAR           reduce using rule 51 (arithmetic -> DECIMAL .)


state 81

    (52) arithmetic -> STRING .

    EQUAL           reduce using rule 52 (arithmetic -> STRING .)
    NOT_EQUAL       reduce using rule 52 (arithmetic -> STRING .)
    GREATER         reduce using rule 52 (arithmetic -> STRING .)
    LESS            reduce using rule 52 (arithmetic -> STRING .)
    GREATER_EQUAL   reduce using rule 52 (arithmetic -> STRING .)
    LESS_EQUAL      reduce using rule 52 (arithmetic -> STRING .)
    PLUS            reduce using rule 52 (arithmetic -> STRING .)
    MINUS           reduce using rule 52 (arithmetic -> STRING .)
    MULTIPLY        reduce using rule 52 (arithmetic -> STRING .)
    DIVIDE          reduce using rule 52 (arithmetic -> STRING .)
    REMAINDER       reduce using rule 52 (arithmetic -> STRING .)
    SEMICOLON       reduce using rule 52 (arithmetic -> STRING .)
    AND             reduce using rule 52 (arithmetic -> STRING .)
    OR              reduce using rule 52 (arithmetic -> STRING .)
    R_BRACKET       reduce using rule 52 (arithmetic -> STRING .)
    R_PAR           reduce using rule 52 (arithmetic -> STRING .)


state 82

    (54) arithmetic -> array_access .

    EQUAL           reduce using rule 54 (arithmetic -> array_access .)
    NOT_EQUAL       reduce using rule 54 (arithmetic -> array_access .)
    GREATER         reduce using rule 54 (arithmetic -> array_access .)
    LESS            reduce using rule 54 (arithmetic -> array_access .)
    GREATER_EQUAL   reduce using rule 54 (arithmetic -> array_access .)
    LESS_EQUAL      reduce using rule 54 (arithmetic -> array_access .)
    PLUS            reduce using rule 54 (arithmetic -> array_access .)
    MINUS           reduce using rule 54 (arithmetic -> array_access .)
    MULTIPLY        reduce using rule 54 (arithmetic -> array_access .)
    DIVIDE          reduce using rule 54 (arithmetic -> array_access .)
    REMAINDER       reduce using rule 54 (arithmetic -> array_access .)
    SEMICOLON       reduce using rule 54 (arithmetic -> array_access .)
    AND             reduce using rule 54 (arithmetic -> array_access .)
    OR              reduce using rule 54 (arithmetic -> array_access .)
    R_BRACKET       reduce using rule 54 (arithmetic -> array_access .)
    R_PAR           reduce using rule 54 (arithmetic -> array_access .)


state 83

    (79) assign -> TVAR L_BRACKET arithmetic . R_BRACKET ASSIGN condition SEMICOLON
    (109) declaration -> TVAR L_BRACKET arithmetic . R_BRACKET SEMICOLON
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    R_BRACKET       shift and go to state 158
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 84

    (53) arithmetic -> var .

    R_BRACKET       reduce using rule 53 (arithmetic -> var .)
    PLUS            reduce using rule 53 (arithmetic -> var .)
    MINUS           reduce using rule 53 (arithmetic -> var .)
    MULTIPLY        reduce using rule 53 (arithmetic -> var .)
    DIVIDE          reduce using rule 53 (arithmetic -> var .)
    REMAINDER       reduce using rule 53 (arithmetic -> var .)
    EQUAL           reduce using rule 53 (arithmetic -> var .)
    NOT_EQUAL       reduce using rule 53 (arithmetic -> var .)
    GREATER         reduce using rule 53 (arithmetic -> var .)
    LESS            reduce using rule 53 (arithmetic -> var .)
    GREATER_EQUAL   reduce using rule 53 (arithmetic -> var .)
    LESS_EQUAL      reduce using rule 53 (arithmetic -> var .)
    R_PAR           reduce using rule 53 (arithmetic -> var .)
    AND             reduce using rule 53 (arithmetic -> var .)
    OR              reduce using rule 53 (arithmetic -> var .)
    SEMICOLON       reduce using rule 53 (arithmetic -> var .)


state 85

    (64) assign -> AVAR ASSIGN condition . SEMICOLON
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

    SEMICOLON       shift and go to state 159
    AND             shift and go to state 125
    OR              shift and go to state 126


state 86

    (68) assign -> AVAR ASSIGN conversion . SEMICOLON

    SEMICOLON       shift and go to state 160


state 87

    (72) assign -> AVAR ASSIGN READ . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 161


state 88

    (76) assign -> AVAR ASSIGN bitwise . SEMICOLON

    SEMICOLON       shift and go to state 162


state 89

    (86) assign -> AVAR ASSIGN ABS . L_PAR var R_PAR SEMICOLON

    L_PAR           shift and go to state 163


state 90

    (104) declaration -> AVAR ASSIGN ARRAY . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 164


state 91

    (80) assign -> AVAR L_BRACKET arithmetic . R_BRACKET ASSIGN condition SEMICOLON
    (110) declaration -> AVAR L_BRACKET arithmetic . R_BRACKET SEMICOLON
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    R_BRACKET       shift and go to state 165
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 92

    (65) assign -> VVAR ASSIGN condition . SEMICOLON
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

    SEMICOLON       shift and go to state 166
    AND             shift and go to state 125
    OR              shift and go to state 126


state 93

    (69) assign -> VVAR ASSIGN conversion . SEMICOLON

    SEMICOLON       shift and go to state 167


state 94

    (73) assign -> VVAR ASSIGN READ . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 168


state 95

    (77) assign -> VVAR ASSIGN bitwise . SEMICOLON

    SEMICOLON       shift and go to state 169


state 96

    (87) assign -> VVAR ASSIGN ABS . L_PAR var R_PAR SEMICOLON

    L_PAR           shift and go to state 170


state 97

    (105) declaration -> VVAR ASSIGN ARRAY . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 171


state 98

    (81) assign -> VVAR L_BRACKET arithmetic . R_BRACKET ASSIGN condition SEMICOLON
    (111) declaration -> VVAR L_BRACKET arithmetic . R_BRACKET SEMICOLON
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    R_BRACKET       shift and go to state 172
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 99

    (66) assign -> SVAR ASSIGN condition . SEMICOLON
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

    SEMICOLON       shift and go to state 173
    AND             shift and go to state 125
    OR              shift and go to state 126


state 100

    (70) assign -> SVAR ASSIGN conversion . SEMICOLON

    SEMICOLON       shift and go to state 174


state 101

    (74) assign -> SVAR ASSIGN READ . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 175


state 102

    (78) assign -> SVAR ASSIGN bitwise . SEMICOLON

    SEMICOLON       shift and go to state 176


state 103

    (88) assign -> SVAR ASSIGN ABS . L_PAR var R_PAR SEMICOLON

    L_PAR           shift and go to state 177


state 104

    (106) declaration -> SVAR ASSIGN ARRAY . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 178


state 105

    (82) assign -> SVAR L_BRACKET arithmetic . R_BRACKET ASSIGN condition SEMICOLON
    (112) declaration -> SVAR L_BRACKET arithmetic . R_BRACKET SEMICOLON
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    R_BRACKET       shift and go to state 179
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 106

    (83) assign -> SPVAR L_BRACKET arithmetic . R_BRACKET ASSIGN condition SEMICOLON
    (113) declaration -> SPVAR L_BRACKET arithmetic . R_BRACKET SEMICOLON
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    R_BRACKET       shift and go to state 180
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 107

    (107) declaration -> SPVAR ASSIGN ARRAY . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 181


state 108

    (84) assign -> RAVAR L_BRACKET arithmetic . R_BRACKET ASSIGN condition SEMICOLON
    (114) declaration -> RAVAR L_BRACKET arithmetic . R_BRACKET SEMICOLON
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    R_BRACKET       shift and go to state 182
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 109

    (108) declaration -> RAVAR ASSIGN ARRAY . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 183


state 110

    (18) print -> PRINT L_PAR TVAR . R_PAR SEMICOLON
    (24) print -> PRINT L_PAR TVAR . L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON

    R_PAR           shift and go to state 184
    L_BRACKET       shift and go to state 185


state 111

    (19) print -> PRINT L_PAR AVAR . R_PAR SEMICOLON
    (25) print -> PRINT L_PAR AVAR . L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON

    R_PAR           shift and go to state 186
    L_BRACKET       shift and go to state 187


state 112

    (20) print -> PRINT L_PAR VVAR . R_PAR SEMICOLON
    (26) print -> PRINT L_PAR VVAR . L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON

    R_PAR           shift and go to state 188
    L_BRACKET       shift and go to state 189


state 113

    (21) print -> PRINT L_PAR SVAR . R_PAR SEMICOLON
    (27) print -> PRINT L_PAR SVAR . L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON

    R_PAR           shift and go to state 190
    L_BRACKET       shift and go to state 191


state 114

    (22) print -> PRINT L_PAR SPVAR . R_PAR SEMICOLON
    (28) print -> PRINT L_PAR SPVAR . L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON

    R_PAR           shift and go to state 192
    L_BRACKET       shift and go to state 193


state 115

    (23) print -> PRINT L_PAR RAVAR . R_PAR SEMICOLON
    (29) print -> PRINT L_PAR RAVAR . L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON

    R_PAR           shift and go to state 194
    L_BRACKET       shift and go to state 195


state 116

    (30) print -> PRINT L_PAR STRING . R_PAR SEMICOLON

    R_PAR           shift and go to state 196


state 117

    (33) if -> IF L_PAR condition . R_PAR GOTO NAME SEMICOLON
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

    R_PAR           shift and go to state 197
    AND             shift and go to state 125
    OR              shift and go to state 126


state 118

    (12) unset -> UNSET L_PAR TVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 198


state 119

    (13) unset -> UNSET L_PAR AVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 199


state 120

    (14) unset -> UNSET L_PAR VVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 200


state 121

    (15) unset -> UNSET L_PAR SVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 201


state 122

    (16) unset -> UNSET L_PAR SPVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 202


state 123

    (17) unset -> UNSET L_PAR RAVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 203


state 124

    (63) assign -> TVAR ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 63 (assign -> TVAR ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 63 (assign -> TVAR ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 63 (assign -> TVAR ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 63 (assign -> TVAR ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 63 (assign -> TVAR ASSIGN condition SEMICOLON .)
    IF              reduce using rule 63 (assign -> TVAR ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 63 (assign -> TVAR ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 63 (assign -> TVAR ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 63 (assign -> TVAR ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 63 (assign -> TVAR ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 63 (assign -> TVAR ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 63 (assign -> TVAR ASSIGN condition SEMICOLON .)
    $end            reduce using rule 63 (assign -> TVAR ASSIGN condition SEMICOLON .)


state 125

    (34) condition -> condition AND . condition
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NOT             shift and go to state 69
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    condition                      shift and go to state 204
    relational                     shift and go to state 70
    arithmetic                     shift and go to state 75
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 126

    (35) condition -> condition OR . condition
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NOT             shift and go to state 69
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    condition                      shift and go to state 205
    relational                     shift and go to state 70
    arithmetic                     shift and go to state 75
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 127

    (67) assign -> TVAR ASSIGN conversion SEMICOLON .

    GOTO            reduce using rule 67 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    UNSET           reduce using rule 67 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    PRINT           reduce using rule 67 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    EXIT            reduce using rule 67 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    NAME            reduce using rule 67 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    IF              reduce using rule 67 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    TVAR            reduce using rule 67 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    AVAR            reduce using rule 67 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    VVAR            reduce using rule 67 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    SVAR            reduce using rule 67 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    SPVAR           reduce using rule 67 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    RAVAR           reduce using rule 67 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    $end            reduce using rule 67 (assign -> TVAR ASSIGN conversion SEMICOLON .)


state 128

    (71) assign -> TVAR ASSIGN READ L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 206


state 129

    (98) conversion -> L_PAR type . R_PAR var

    R_PAR           shift and go to state 207


state 130

    (99) type -> INT .

    R_PAR           reduce using rule 99 (type -> INT .)


state 131

    (100) type -> FLOAT .

    R_PAR           reduce using rule 100 (type -> FLOAT .)


state 132

    (101) type -> CHAR .

    R_PAR           reduce using rule 101 (type -> CHAR .)


state 133

    (75) assign -> TVAR ASSIGN bitwise SEMICOLON .

    GOTO            reduce using rule 75 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    UNSET           reduce using rule 75 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    PRINT           reduce using rule 75 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    EXIT            reduce using rule 75 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    NAME            reduce using rule 75 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    IF              reduce using rule 75 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    TVAR            reduce using rule 75 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    AVAR            reduce using rule 75 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    VVAR            reduce using rule 75 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    SVAR            reduce using rule 75 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    SPVAR           reduce using rule 75 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    RAVAR           reduce using rule 75 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    $end            reduce using rule 75 (assign -> TVAR ASSIGN bitwise SEMICOLON .)


state 134

    (85) assign -> TVAR ASSIGN ABS L_PAR . var R_PAR SEMICOLON
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77

    var                            shift and go to state 208

state 135

    (89) bitwise -> var AND_B . var
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77

    var                            shift and go to state 209

state 136

    (90) bitwise -> var OR_B . var
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77

    var                            shift and go to state 210

state 137

    (91) bitwise -> var XOR_B . var
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77

    var                            shift and go to state 211

state 138

    (92) bitwise -> var SHIFT_L . var
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77

    var                            shift and go to state 212

state 139

    (93) bitwise -> var SHIFT_R . var
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77

    var                            shift and go to state 213

state 140

    (103) declaration -> TVAR ASSIGN ARRAY L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 214


state 141

    (36) condition -> NOT condition .
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 36 (condition -> NOT condition .)
    R_PAR           reduce using rule 36 (condition -> NOT condition .)
    AND             shift and go to state 125
    OR              shift and go to state 126

  ! AND             [ reduce using rule 36 (condition -> NOT condition .) ]
  ! OR              [ reduce using rule 36 (condition -> NOT condition .) ]


state 142

    (94) bitwise -> NOT_B TVAR .

    SEMICOLON       reduce using rule 94 (bitwise -> NOT_B TVAR .)


state 143

    (95) bitwise -> NOT_B AVAR .

    SEMICOLON       reduce using rule 95 (bitwise -> NOT_B AVAR .)


state 144

    (96) bitwise -> NOT_B VVAR .

    SEMICOLON       reduce using rule 96 (bitwise -> NOT_B VVAR .)


state 145

    (97) bitwise -> NOT_B SVAR .

    SEMICOLON       reduce using rule 97 (bitwise -> NOT_B SVAR .)


state 146

    (38) relational -> arithmetic EQUAL . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 215
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 147

    (39) relational -> arithmetic NOT_EQUAL . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 216
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 148

    (40) relational -> arithmetic GREATER . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 217
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 149

    (41) relational -> arithmetic LESS . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 218
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 150

    (42) relational -> arithmetic GREATER_EQUAL . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 219
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 151

    (43) relational -> arithmetic LESS_EQUAL . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 220
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 152

    (45) arithmetic -> arithmetic PLUS . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    R_BRACKET       reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 221
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 153

    (46) arithmetic -> arithmetic MINUS . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    R_BRACKET       reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 222
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 154

    (47) arithmetic -> arithmetic MULTIPLY . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    R_BRACKET       reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 223
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 155

    (48) arithmetic -> arithmetic DIVIDE . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    R_BRACKET       reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 224
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 156

    (49) arithmetic -> arithmetic REMAINDER . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)
    R_BRACKET       reduce using rule 62 (array_access -> .)
    R_PAR           reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 225
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 157

    (55) arithmetic -> MINUS arithmetic .
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    EQUAL           reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    NOT_EQUAL       reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    GREATER         reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    LESS            reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    GREATER_EQUAL   reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    LESS_EQUAL      reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    PLUS            reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    MINUS           reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    REMAINDER       reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    SEMICOLON       reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    AND             reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    OR              reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    R_BRACKET       reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    R_PAR           reduce using rule 55 (arithmetic -> MINUS arithmetic .)
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155

  ! MULTIPLY        [ reduce using rule 55 (arithmetic -> MINUS arithmetic .) ]
  ! DIVIDE          [ reduce using rule 55 (arithmetic -> MINUS arithmetic .) ]
  ! PLUS            [ shift and go to state 152 ]
  ! MINUS           [ shift and go to state 153 ]
  ! REMAINDER       [ shift and go to state 156 ]


state 158

    (79) assign -> TVAR L_BRACKET arithmetic R_BRACKET . ASSIGN condition SEMICOLON
    (109) declaration -> TVAR L_BRACKET arithmetic R_BRACKET . SEMICOLON

    ASSIGN          shift and go to state 226
    SEMICOLON       shift and go to state 227


state 159

    (64) assign -> AVAR ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 64 (assign -> AVAR ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 64 (assign -> AVAR ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 64 (assign -> AVAR ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 64 (assign -> AVAR ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 64 (assign -> AVAR ASSIGN condition SEMICOLON .)
    IF              reduce using rule 64 (assign -> AVAR ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 64 (assign -> AVAR ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 64 (assign -> AVAR ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 64 (assign -> AVAR ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 64 (assign -> AVAR ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 64 (assign -> AVAR ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 64 (assign -> AVAR ASSIGN condition SEMICOLON .)
    $end            reduce using rule 64 (assign -> AVAR ASSIGN condition SEMICOLON .)


state 160

    (68) assign -> AVAR ASSIGN conversion SEMICOLON .

    GOTO            reduce using rule 68 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    UNSET           reduce using rule 68 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    PRINT           reduce using rule 68 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    EXIT            reduce using rule 68 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    NAME            reduce using rule 68 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    IF              reduce using rule 68 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    TVAR            reduce using rule 68 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    AVAR            reduce using rule 68 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    VVAR            reduce using rule 68 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    SVAR            reduce using rule 68 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    SPVAR           reduce using rule 68 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    RAVAR           reduce using rule 68 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    $end            reduce using rule 68 (assign -> AVAR ASSIGN conversion SEMICOLON .)


state 161

    (72) assign -> AVAR ASSIGN READ L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 228


state 162

    (76) assign -> AVAR ASSIGN bitwise SEMICOLON .

    GOTO            reduce using rule 76 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    UNSET           reduce using rule 76 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    PRINT           reduce using rule 76 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    EXIT            reduce using rule 76 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    NAME            reduce using rule 76 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    IF              reduce using rule 76 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    TVAR            reduce using rule 76 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    AVAR            reduce using rule 76 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    VVAR            reduce using rule 76 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    SVAR            reduce using rule 76 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    SPVAR           reduce using rule 76 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    RAVAR           reduce using rule 76 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    $end            reduce using rule 76 (assign -> AVAR ASSIGN bitwise SEMICOLON .)


state 163

    (86) assign -> AVAR ASSIGN ABS L_PAR . var R_PAR SEMICOLON
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77

    var                            shift and go to state 229

state 164

    (104) declaration -> AVAR ASSIGN ARRAY L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 230


state 165

    (80) assign -> AVAR L_BRACKET arithmetic R_BRACKET . ASSIGN condition SEMICOLON
    (110) declaration -> AVAR L_BRACKET arithmetic R_BRACKET . SEMICOLON

    ASSIGN          shift and go to state 231
    SEMICOLON       shift and go to state 232


state 166

    (65) assign -> VVAR ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 65 (assign -> VVAR ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 65 (assign -> VVAR ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 65 (assign -> VVAR ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 65 (assign -> VVAR ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 65 (assign -> VVAR ASSIGN condition SEMICOLON .)
    IF              reduce using rule 65 (assign -> VVAR ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 65 (assign -> VVAR ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 65 (assign -> VVAR ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 65 (assign -> VVAR ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 65 (assign -> VVAR ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 65 (assign -> VVAR ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 65 (assign -> VVAR ASSIGN condition SEMICOLON .)
    $end            reduce using rule 65 (assign -> VVAR ASSIGN condition SEMICOLON .)


state 167

    (69) assign -> VVAR ASSIGN conversion SEMICOLON .

    GOTO            reduce using rule 69 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    UNSET           reduce using rule 69 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    PRINT           reduce using rule 69 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    EXIT            reduce using rule 69 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    NAME            reduce using rule 69 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    IF              reduce using rule 69 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    TVAR            reduce using rule 69 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    AVAR            reduce using rule 69 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    VVAR            reduce using rule 69 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    SVAR            reduce using rule 69 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    SPVAR           reduce using rule 69 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    RAVAR           reduce using rule 69 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    $end            reduce using rule 69 (assign -> VVAR ASSIGN conversion SEMICOLON .)


state 168

    (73) assign -> VVAR ASSIGN READ L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 233


state 169

    (77) assign -> VVAR ASSIGN bitwise SEMICOLON .

    GOTO            reduce using rule 77 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    UNSET           reduce using rule 77 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    PRINT           reduce using rule 77 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    EXIT            reduce using rule 77 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    NAME            reduce using rule 77 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    IF              reduce using rule 77 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    TVAR            reduce using rule 77 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    AVAR            reduce using rule 77 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    VVAR            reduce using rule 77 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    SVAR            reduce using rule 77 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    SPVAR           reduce using rule 77 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    RAVAR           reduce using rule 77 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    $end            reduce using rule 77 (assign -> VVAR ASSIGN bitwise SEMICOLON .)


state 170

    (87) assign -> VVAR ASSIGN ABS L_PAR . var R_PAR SEMICOLON
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77

    var                            shift and go to state 234

state 171

    (105) declaration -> VVAR ASSIGN ARRAY L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 235


state 172

    (81) assign -> VVAR L_BRACKET arithmetic R_BRACKET . ASSIGN condition SEMICOLON
    (111) declaration -> VVAR L_BRACKET arithmetic R_BRACKET . SEMICOLON

    ASSIGN          shift and go to state 236
    SEMICOLON       shift and go to state 237


state 173

    (66) assign -> SVAR ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 66 (assign -> SVAR ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 66 (assign -> SVAR ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 66 (assign -> SVAR ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 66 (assign -> SVAR ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 66 (assign -> SVAR ASSIGN condition SEMICOLON .)
    IF              reduce using rule 66 (assign -> SVAR ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 66 (assign -> SVAR ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 66 (assign -> SVAR ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 66 (assign -> SVAR ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 66 (assign -> SVAR ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 66 (assign -> SVAR ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 66 (assign -> SVAR ASSIGN condition SEMICOLON .)
    $end            reduce using rule 66 (assign -> SVAR ASSIGN condition SEMICOLON .)


state 174

    (70) assign -> SVAR ASSIGN conversion SEMICOLON .

    GOTO            reduce using rule 70 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    UNSET           reduce using rule 70 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    PRINT           reduce using rule 70 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    EXIT            reduce using rule 70 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    NAME            reduce using rule 70 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    IF              reduce using rule 70 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    TVAR            reduce using rule 70 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    AVAR            reduce using rule 70 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    VVAR            reduce using rule 70 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    SVAR            reduce using rule 70 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    SPVAR           reduce using rule 70 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    RAVAR           reduce using rule 70 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    $end            reduce using rule 70 (assign -> SVAR ASSIGN conversion SEMICOLON .)


state 175

    (74) assign -> SVAR ASSIGN READ L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 238


state 176

    (78) assign -> SVAR ASSIGN bitwise SEMICOLON .

    GOTO            reduce using rule 78 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    UNSET           reduce using rule 78 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    PRINT           reduce using rule 78 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    EXIT            reduce using rule 78 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    NAME            reduce using rule 78 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    IF              reduce using rule 78 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    TVAR            reduce using rule 78 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    AVAR            reduce using rule 78 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    VVAR            reduce using rule 78 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    SVAR            reduce using rule 78 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    SPVAR           reduce using rule 78 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    RAVAR           reduce using rule 78 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    $end            reduce using rule 78 (assign -> SVAR ASSIGN bitwise SEMICOLON .)


state 177

    (88) assign -> SVAR ASSIGN ABS L_PAR . var R_PAR SEMICOLON
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77

    var                            shift and go to state 239

state 178

    (106) declaration -> SVAR ASSIGN ARRAY L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 240


state 179

    (82) assign -> SVAR L_BRACKET arithmetic R_BRACKET . ASSIGN condition SEMICOLON
    (112) declaration -> SVAR L_BRACKET arithmetic R_BRACKET . SEMICOLON

    ASSIGN          shift and go to state 241
    SEMICOLON       shift and go to state 242


state 180

    (83) assign -> SPVAR L_BRACKET arithmetic R_BRACKET . ASSIGN condition SEMICOLON
    (113) declaration -> SPVAR L_BRACKET arithmetic R_BRACKET . SEMICOLON

    ASSIGN          shift and go to state 243
    SEMICOLON       shift and go to state 244


state 181

    (107) declaration -> SPVAR ASSIGN ARRAY L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 245


state 182

    (84) assign -> RAVAR L_BRACKET arithmetic R_BRACKET . ASSIGN condition SEMICOLON
    (114) declaration -> RAVAR L_BRACKET arithmetic R_BRACKET . SEMICOLON

    ASSIGN          shift and go to state 246
    SEMICOLON       shift and go to state 247


state 183

    (108) declaration -> RAVAR ASSIGN ARRAY L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 248


state 184

    (18) print -> PRINT L_PAR TVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 249


state 185

    (24) print -> PRINT L_PAR TVAR L_BRACKET . arithmetic R_BRACKET R_PAR SEMICOLON
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    R_BRACKET       reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 250
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 186

    (19) print -> PRINT L_PAR AVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 251


state 187

    (25) print -> PRINT L_PAR AVAR L_BRACKET . arithmetic R_BRACKET R_PAR SEMICOLON
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    R_BRACKET       reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 252
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 188

    (20) print -> PRINT L_PAR VVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 253


state 189

    (26) print -> PRINT L_PAR VVAR L_BRACKET . arithmetic R_BRACKET R_PAR SEMICOLON
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    R_BRACKET       reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 254
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 190

    (21) print -> PRINT L_PAR SVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 255


state 191

    (27) print -> PRINT L_PAR SVAR L_BRACKET . arithmetic R_BRACKET R_PAR SEMICOLON
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    R_BRACKET       reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 256
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 192

    (22) print -> PRINT L_PAR SPVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 257


state 193

    (28) print -> PRINT L_PAR SPVAR L_BRACKET . arithmetic R_BRACKET R_PAR SEMICOLON
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    R_BRACKET       reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 258
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 194

    (23) print -> PRINT L_PAR RAVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 259


state 195

    (29) print -> PRINT L_PAR RAVAR L_BRACKET . arithmetic R_BRACKET R_PAR SEMICOLON
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    R_BRACKET       reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 260
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 196

    (30) print -> PRINT L_PAR STRING R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 261


state 197

    (33) if -> IF L_PAR condition R_PAR . GOTO NAME SEMICOLON

    GOTO            shift and go to state 262


state 198

    (12) unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    IF              reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    $end            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)


state 199

    (13) unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    IF              reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    $end            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)


state 200

    (14) unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    IF              reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    $end            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)


state 201

    (15) unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    IF              reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    $end            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)


state 202

    (16) unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    IF              reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    $end            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)


state 203

    (17) unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    IF              reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    $end            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)


state 204

    (34) condition -> condition AND condition .
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

    SEMICOLON       reduce using rule 34 (condition -> condition AND condition .)
    AND             reduce using rule 34 (condition -> condition AND condition .)
    OR              reduce using rule 34 (condition -> condition AND condition .)
    R_PAR           reduce using rule 34 (condition -> condition AND condition .)

  ! AND             [ shift and go to state 125 ]
  ! OR              [ shift and go to state 126 ]


state 205

    (35) condition -> condition OR condition .
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

    SEMICOLON       reduce using rule 35 (condition -> condition OR condition .)
    OR              reduce using rule 35 (condition -> condition OR condition .)
    R_PAR           reduce using rule 35 (condition -> condition OR condition .)
    AND             shift and go to state 125

  ! AND             [ reduce using rule 35 (condition -> condition OR condition .) ]
  ! OR              [ shift and go to state 126 ]


state 206

    (71) assign -> TVAR ASSIGN READ L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 263


state 207

    (98) conversion -> L_PAR type R_PAR . var
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR

    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77

    var                            shift and go to state 264

state 208

    (85) assign -> TVAR ASSIGN ABS L_PAR var . R_PAR SEMICOLON

    R_PAR           shift and go to state 265


state 209

    (89) bitwise -> var AND_B var .

    SEMICOLON       reduce using rule 89 (bitwise -> var AND_B var .)


state 210

    (90) bitwise -> var OR_B var .

    SEMICOLON       reduce using rule 90 (bitwise -> var OR_B var .)


state 211

    (91) bitwise -> var XOR_B var .

    SEMICOLON       reduce using rule 91 (bitwise -> var XOR_B var .)


state 212

    (92) bitwise -> var SHIFT_L var .

    SEMICOLON       reduce using rule 92 (bitwise -> var SHIFT_L var .)


state 213

    (93) bitwise -> var SHIFT_R var .

    SEMICOLON       reduce using rule 93 (bitwise -> var SHIFT_R var .)


state 214

    (103) declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 266


state 215

    (38) relational -> arithmetic EQUAL arithmetic .
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    SEMICOLON       reduce using rule 38 (relational -> arithmetic EQUAL arithmetic .)
    AND             reduce using rule 38 (relational -> arithmetic EQUAL arithmetic .)
    OR              reduce using rule 38 (relational -> arithmetic EQUAL arithmetic .)
    R_PAR           reduce using rule 38 (relational -> arithmetic EQUAL arithmetic .)
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 216

    (39) relational -> arithmetic NOT_EQUAL arithmetic .
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    SEMICOLON       reduce using rule 39 (relational -> arithmetic NOT_EQUAL arithmetic .)
    AND             reduce using rule 39 (relational -> arithmetic NOT_EQUAL arithmetic .)
    OR              reduce using rule 39 (relational -> arithmetic NOT_EQUAL arithmetic .)
    R_PAR           reduce using rule 39 (relational -> arithmetic NOT_EQUAL arithmetic .)
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 217

    (40) relational -> arithmetic GREATER arithmetic .
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    SEMICOLON       reduce using rule 40 (relational -> arithmetic GREATER arithmetic .)
    AND             reduce using rule 40 (relational -> arithmetic GREATER arithmetic .)
    OR              reduce using rule 40 (relational -> arithmetic GREATER arithmetic .)
    R_PAR           reduce using rule 40 (relational -> arithmetic GREATER arithmetic .)
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 218

    (41) relational -> arithmetic LESS arithmetic .
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    SEMICOLON       reduce using rule 41 (relational -> arithmetic LESS arithmetic .)
    AND             reduce using rule 41 (relational -> arithmetic LESS arithmetic .)
    OR              reduce using rule 41 (relational -> arithmetic LESS arithmetic .)
    R_PAR           reduce using rule 41 (relational -> arithmetic LESS arithmetic .)
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 219

    (42) relational -> arithmetic GREATER_EQUAL arithmetic .
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    SEMICOLON       reduce using rule 42 (relational -> arithmetic GREATER_EQUAL arithmetic .)
    AND             reduce using rule 42 (relational -> arithmetic GREATER_EQUAL arithmetic .)
    OR              reduce using rule 42 (relational -> arithmetic GREATER_EQUAL arithmetic .)
    R_PAR           reduce using rule 42 (relational -> arithmetic GREATER_EQUAL arithmetic .)
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 220

    (43) relational -> arithmetic LESS_EQUAL arithmetic .
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    SEMICOLON       reduce using rule 43 (relational -> arithmetic LESS_EQUAL arithmetic .)
    AND             reduce using rule 43 (relational -> arithmetic LESS_EQUAL arithmetic .)
    OR              reduce using rule 43 (relational -> arithmetic LESS_EQUAL arithmetic .)
    R_PAR           reduce using rule 43 (relational -> arithmetic LESS_EQUAL arithmetic .)
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 221

    (45) arithmetic -> arithmetic PLUS arithmetic .
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    EQUAL           reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    NOT_EQUAL       reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    GREATER         reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    LESS            reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    GREATER_EQUAL   reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    LESS_EQUAL      reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    PLUS            reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    MINUS           reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    REMAINDER       reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    SEMICOLON       reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    AND             reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    OR              reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    R_BRACKET       reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    R_PAR           reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .)
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155

  ! MULTIPLY        [ reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .) ]
  ! DIVIDE          [ reduce using rule 45 (arithmetic -> arithmetic PLUS arithmetic .) ]
  ! PLUS            [ shift and go to state 152 ]
  ! MINUS           [ shift and go to state 153 ]
  ! REMAINDER       [ shift and go to state 156 ]


state 222

    (46) arithmetic -> arithmetic MINUS arithmetic .
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    EQUAL           reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    NOT_EQUAL       reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    GREATER         reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    LESS            reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    GREATER_EQUAL   reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    LESS_EQUAL      reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    PLUS            reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    MINUS           reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    REMAINDER       reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    SEMICOLON       reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    AND             reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    OR              reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    R_BRACKET       reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    R_PAR           reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .)
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155

  ! MULTIPLY        [ reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .) ]
  ! DIVIDE          [ reduce using rule 46 (arithmetic -> arithmetic MINUS arithmetic .) ]
  ! PLUS            [ shift and go to state 152 ]
  ! MINUS           [ shift and go to state 153 ]
  ! REMAINDER       [ shift and go to state 156 ]


state 223

    (47) arithmetic -> arithmetic MULTIPLY arithmetic .
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    EQUAL           reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    NOT_EQUAL       reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    GREATER         reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    LESS            reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    GREATER_EQUAL   reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    LESS_EQUAL      reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    PLUS            reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    MINUS           reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    MULTIPLY        reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    DIVIDE          reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    REMAINDER       reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    SEMICOLON       reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    AND             reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    OR              reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    R_BRACKET       reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    R_PAR           reduce using rule 47 (arithmetic -> arithmetic MULTIPLY arithmetic .)

  ! PLUS            [ shift and go to state 152 ]
  ! MINUS           [ shift and go to state 153 ]
  ! MULTIPLY        [ shift and go to state 154 ]
  ! DIVIDE          [ shift and go to state 155 ]
  ! REMAINDER       [ shift and go to state 156 ]


state 224

    (48) arithmetic -> arithmetic DIVIDE arithmetic .
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    EQUAL           reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    NOT_EQUAL       reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    GREATER         reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    LESS            reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    GREATER_EQUAL   reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    LESS_EQUAL      reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    PLUS            reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    MINUS           reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    MULTIPLY        reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    DIVIDE          reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    REMAINDER       reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    SEMICOLON       reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    AND             reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    OR              reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    R_BRACKET       reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)
    R_PAR           reduce using rule 48 (arithmetic -> arithmetic DIVIDE arithmetic .)

  ! PLUS            [ shift and go to state 152 ]
  ! MINUS           [ shift and go to state 153 ]
  ! MULTIPLY        [ shift and go to state 154 ]
  ! DIVIDE          [ shift and go to state 155 ]
  ! REMAINDER       [ shift and go to state 156 ]


state 225

    (49) arithmetic -> arithmetic REMAINDER arithmetic .
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for REMAINDER resolved as shift
    EQUAL           reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .)
    NOT_EQUAL       reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .)
    GREATER         reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .)
    LESS            reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .)
    GREATER_EQUAL   reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .)
    LESS_EQUAL      reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .)
    SEMICOLON       reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .)
    AND             reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .)
    OR              reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .)
    R_BRACKET       reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .)
    R_PAR           reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .)
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156

  ! PLUS            [ reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .) ]
  ! MINUS           [ reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .) ]
  ! MULTIPLY        [ reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .) ]
  ! DIVIDE          [ reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .) ]
  ! REMAINDER       [ reduce using rule 49 (arithmetic -> arithmetic REMAINDER arithmetic .) ]


state 226

    (79) assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN . condition SEMICOLON
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NOT             shift and go to state 69
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 75
    condition                      shift and go to state 267
    relational                     shift and go to state 70
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 227

    (109) declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .

    GOTO            reduce using rule 109 (declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    UNSET           reduce using rule 109 (declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    PRINT           reduce using rule 109 (declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    EXIT            reduce using rule 109 (declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    NAME            reduce using rule 109 (declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    IF              reduce using rule 109 (declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    TVAR            reduce using rule 109 (declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    AVAR            reduce using rule 109 (declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    VVAR            reduce using rule 109 (declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    SVAR            reduce using rule 109 (declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    SPVAR           reduce using rule 109 (declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    RAVAR           reduce using rule 109 (declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    $end            reduce using rule 109 (declaration -> TVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)


state 228

    (72) assign -> AVAR ASSIGN READ L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 268


state 229

    (86) assign -> AVAR ASSIGN ABS L_PAR var . R_PAR SEMICOLON

    R_PAR           shift and go to state 269


state 230

    (104) declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 270


state 231

    (80) assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN . condition SEMICOLON
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NOT             shift and go to state 69
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 75
    condition                      shift and go to state 271
    relational                     shift and go to state 70
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 232

    (110) declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .

    GOTO            reduce using rule 110 (declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    UNSET           reduce using rule 110 (declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    PRINT           reduce using rule 110 (declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    EXIT            reduce using rule 110 (declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    NAME            reduce using rule 110 (declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    IF              reduce using rule 110 (declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    TVAR            reduce using rule 110 (declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    AVAR            reduce using rule 110 (declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    VVAR            reduce using rule 110 (declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    SVAR            reduce using rule 110 (declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    SPVAR           reduce using rule 110 (declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    RAVAR           reduce using rule 110 (declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    $end            reduce using rule 110 (declaration -> AVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)


state 233

    (73) assign -> VVAR ASSIGN READ L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 272


state 234

    (87) assign -> VVAR ASSIGN ABS L_PAR var . R_PAR SEMICOLON

    R_PAR           shift and go to state 273


state 235

    (105) declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 274


state 236

    (81) assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN . condition SEMICOLON
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NOT             shift and go to state 69
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 75
    condition                      shift and go to state 275
    relational                     shift and go to state 70
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 237

    (111) declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .

    GOTO            reduce using rule 111 (declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    UNSET           reduce using rule 111 (declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    PRINT           reduce using rule 111 (declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    EXIT            reduce using rule 111 (declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    NAME            reduce using rule 111 (declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    IF              reduce using rule 111 (declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    TVAR            reduce using rule 111 (declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    AVAR            reduce using rule 111 (declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    VVAR            reduce using rule 111 (declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    SVAR            reduce using rule 111 (declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    SPVAR           reduce using rule 111 (declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    RAVAR           reduce using rule 111 (declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    $end            reduce using rule 111 (declaration -> VVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)


state 238

    (74) assign -> SVAR ASSIGN READ L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 276


state 239

    (88) assign -> SVAR ASSIGN ABS L_PAR var . R_PAR SEMICOLON

    R_PAR           shift and go to state 277


state 240

    (106) declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 278


state 241

    (82) assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN . condition SEMICOLON
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NOT             shift and go to state 69
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 75
    condition                      shift and go to state 279
    relational                     shift and go to state 70
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 242

    (112) declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .

    GOTO            reduce using rule 112 (declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    UNSET           reduce using rule 112 (declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    PRINT           reduce using rule 112 (declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    EXIT            reduce using rule 112 (declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    NAME            reduce using rule 112 (declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    IF              reduce using rule 112 (declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    TVAR            reduce using rule 112 (declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    AVAR            reduce using rule 112 (declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    VVAR            reduce using rule 112 (declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    SVAR            reduce using rule 112 (declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    SPVAR           reduce using rule 112 (declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    RAVAR           reduce using rule 112 (declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    $end            reduce using rule 112 (declaration -> SVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)


state 243

    (83) assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN . condition SEMICOLON
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NOT             shift and go to state 69
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 75
    condition                      shift and go to state 280
    relational                     shift and go to state 70
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 244

    (113) declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .

    GOTO            reduce using rule 113 (declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    UNSET           reduce using rule 113 (declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    PRINT           reduce using rule 113 (declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    EXIT            reduce using rule 113 (declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    NAME            reduce using rule 113 (declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    IF              reduce using rule 113 (declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    TVAR            reduce using rule 113 (declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    AVAR            reduce using rule 113 (declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    VVAR            reduce using rule 113 (declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    SVAR            reduce using rule 113 (declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    SPVAR           reduce using rule 113 (declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    RAVAR           reduce using rule 113 (declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    $end            reduce using rule 113 (declaration -> SPVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)


state 245

    (107) declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 281


state 246

    (84) assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN . condition SEMICOLON
    (34) condition -> . condition AND condition
    (35) condition -> . condition OR condition
    (36) condition -> . NOT condition
    (37) condition -> . relational
    (38) relational -> . arithmetic EQUAL arithmetic
    (39) relational -> . arithmetic NOT_EQUAL arithmetic
    (40) relational -> . arithmetic GREATER arithmetic
    (41) relational -> . arithmetic LESS arithmetic
    (42) relational -> . arithmetic GREATER_EQUAL arithmetic
    (43) relational -> . arithmetic LESS_EQUAL arithmetic
    (44) relational -> . arithmetic
    (45) arithmetic -> . arithmetic PLUS arithmetic
    (46) arithmetic -> . arithmetic MINUS arithmetic
    (47) arithmetic -> . arithmetic MULTIPLY arithmetic
    (48) arithmetic -> . arithmetic DIVIDE arithmetic
    (49) arithmetic -> . arithmetic REMAINDER arithmetic
    (50) arithmetic -> . INTEGER
    (51) arithmetic -> . DECIMAL
    (52) arithmetic -> . STRING
    (53) arithmetic -> . var
    (54) arithmetic -> . array_access
    (55) arithmetic -> . MINUS arithmetic
    (56) var -> . TVAR
    (57) var -> . AVAR
    (58) var -> . VVAR
    (59) var -> . SVAR
    (60) var -> . RAVAR
    (61) var -> . SPVAR
    (62) array_access -> .

  ! shift/reduce conflict for MINUS resolved as shift
    NOT             shift and go to state 69
    INTEGER         shift and go to state 79
    DECIMAL         shift and go to state 80
    STRING          shift and go to state 81
    MINUS           shift and go to state 78
    TVAR            shift and go to state 60
    AVAR            shift and go to state 72
    VVAR            shift and go to state 73
    SVAR            shift and go to state 74
    RAVAR           shift and go to state 76
    SPVAR           shift and go to state 77
    EQUAL           reduce using rule 62 (array_access -> .)
    NOT_EQUAL       reduce using rule 62 (array_access -> .)
    GREATER         reduce using rule 62 (array_access -> .)
    LESS            reduce using rule 62 (array_access -> .)
    GREATER_EQUAL   reduce using rule 62 (array_access -> .)
    LESS_EQUAL      reduce using rule 62 (array_access -> .)
    PLUS            reduce using rule 62 (array_access -> .)
    MULTIPLY        reduce using rule 62 (array_access -> .)
    DIVIDE          reduce using rule 62 (array_access -> .)
    REMAINDER       reduce using rule 62 (array_access -> .)
    SEMICOLON       reduce using rule 62 (array_access -> .)
    AND             reduce using rule 62 (array_access -> .)
    OR              reduce using rule 62 (array_access -> .)

  ! MINUS           [ reduce using rule 62 (array_access -> .) ]

    arithmetic                     shift and go to state 75
    condition                      shift and go to state 282
    relational                     shift and go to state 70
    var                            shift and go to state 84
    array_access                   shift and go to state 82

state 247

    (114) declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .

    GOTO            reduce using rule 114 (declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    UNSET           reduce using rule 114 (declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    PRINT           reduce using rule 114 (declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    EXIT            reduce using rule 114 (declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    NAME            reduce using rule 114 (declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    IF              reduce using rule 114 (declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    TVAR            reduce using rule 114 (declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    AVAR            reduce using rule 114 (declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    VVAR            reduce using rule 114 (declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    SVAR            reduce using rule 114 (declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    SPVAR           reduce using rule 114 (declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    RAVAR           reduce using rule 114 (declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)
    $end            reduce using rule 114 (declaration -> RAVAR L_BRACKET arithmetic R_BRACKET SEMICOLON .)


state 248

    (108) declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 283


state 249

    (18) print -> PRINT L_PAR TVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    IF              reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    $end            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)


state 250

    (24) print -> PRINT L_PAR TVAR L_BRACKET arithmetic . R_BRACKET R_PAR SEMICOLON
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    R_BRACKET       shift and go to state 284
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 251

    (19) print -> PRINT L_PAR AVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    IF              reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    $end            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)


state 252

    (25) print -> PRINT L_PAR AVAR L_BRACKET arithmetic . R_BRACKET R_PAR SEMICOLON
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    R_BRACKET       shift and go to state 285
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 253

    (20) print -> PRINT L_PAR VVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    IF              reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    $end            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)


state 254

    (26) print -> PRINT L_PAR VVAR L_BRACKET arithmetic . R_BRACKET R_PAR SEMICOLON
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    R_BRACKET       shift and go to state 286
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 255

    (21) print -> PRINT L_PAR SVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    IF              reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    $end            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)


state 256

    (27) print -> PRINT L_PAR SVAR L_BRACKET arithmetic . R_BRACKET R_PAR SEMICOLON
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    R_BRACKET       shift and go to state 287
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 257

    (22) print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    IF              reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    $end            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)


state 258

    (28) print -> PRINT L_PAR SPVAR L_BRACKET arithmetic . R_BRACKET R_PAR SEMICOLON
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    R_BRACKET       shift and go to state 288
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 259

    (23) print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    IF              reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    $end            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)


state 260

    (29) print -> PRINT L_PAR RAVAR L_BRACKET arithmetic . R_BRACKET R_PAR SEMICOLON
    (45) arithmetic -> arithmetic . PLUS arithmetic
    (46) arithmetic -> arithmetic . MINUS arithmetic
    (47) arithmetic -> arithmetic . MULTIPLY arithmetic
    (48) arithmetic -> arithmetic . DIVIDE arithmetic
    (49) arithmetic -> arithmetic . REMAINDER arithmetic

    R_BRACKET       shift and go to state 289
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    MULTIPLY        shift and go to state 154
    DIVIDE          shift and go to state 155
    REMAINDER       shift and go to state 156


state 261

    (30) print -> PRINT L_PAR STRING R_PAR SEMICOLON .

    GOTO            reduce using rule 30 (print -> PRINT L_PAR STRING R_PAR SEMICOLON .)
    UNSET           reduce using rule 30 (print -> PRINT L_PAR STRING R_PAR SEMICOLON .)
    PRINT           reduce using rule 30 (print -> PRINT L_PAR STRING R_PAR SEMICOLON .)
    EXIT            reduce using rule 30 (print -> PRINT L_PAR STRING R_PAR SEMICOLON .)
    NAME            reduce using rule 30 (print -> PRINT L_PAR STRING R_PAR SEMICOLON .)
    IF              reduce using rule 30 (print -> PRINT L_PAR STRING R_PAR SEMICOLON .)
    TVAR            reduce using rule 30 (print -> PRINT L_PAR STRING R_PAR SEMICOLON .)
    AVAR            reduce using rule 30 (print -> PRINT L_PAR STRING R_PAR SEMICOLON .)
    VVAR            reduce using rule 30 (print -> PRINT L_PAR STRING R_PAR SEMICOLON .)
    SVAR            reduce using rule 30 (print -> PRINT L_PAR STRING R_PAR SEMICOLON .)
    SPVAR           reduce using rule 30 (print -> PRINT L_PAR STRING R_PAR SEMICOLON .)
    RAVAR           reduce using rule 30 (print -> PRINT L_PAR STRING R_PAR SEMICOLON .)
    $end            reduce using rule 30 (print -> PRINT L_PAR STRING R_PAR SEMICOLON .)


state 262

    (33) if -> IF L_PAR condition R_PAR GOTO . NAME SEMICOLON

    NAME            shift and go to state 290


state 263

    (71) assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 71 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 71 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 71 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 71 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 71 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 71 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 71 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 71 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 71 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 71 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 71 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 71 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 71 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)


state 264

    (98) conversion -> L_PAR type R_PAR var .

    SEMICOLON       reduce using rule 98 (conversion -> L_PAR type R_PAR var .)


state 265

    (85) assign -> TVAR ASSIGN ABS L_PAR var R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 291


state 266

    (103) declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 103 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 103 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 103 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 103 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 103 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 103 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 103 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 103 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 103 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 103 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 103 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 103 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 103 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)


state 267

    (79) assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition . SEMICOLON
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

    SEMICOLON       shift and go to state 292
    AND             shift and go to state 125
    OR              shift and go to state 126


state 268

    (72) assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 72 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 72 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 72 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 72 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 72 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 72 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 72 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 72 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 72 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 72 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 72 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 72 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 72 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)


state 269

    (86) assign -> AVAR ASSIGN ABS L_PAR var R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 293


state 270

    (104) declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 104 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 104 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 104 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 104 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 104 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 104 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 104 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 104 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 104 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 104 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 104 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 104 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 104 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)


state 271

    (80) assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition . SEMICOLON
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

    SEMICOLON       shift and go to state 294
    AND             shift and go to state 125
    OR              shift and go to state 126


state 272

    (73) assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 73 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 73 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 73 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 73 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 73 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 73 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 73 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 73 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 73 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 73 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 73 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 73 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 73 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)


state 273

    (87) assign -> VVAR ASSIGN ABS L_PAR var R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 295


state 274

    (105) declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 105 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 105 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 105 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 105 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 105 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 105 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 105 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 105 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 105 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 105 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 105 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 105 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 105 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)


state 275

    (81) assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition . SEMICOLON
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

    SEMICOLON       shift and go to state 296
    AND             shift and go to state 125
    OR              shift and go to state 126


state 276

    (74) assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 74 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 74 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 74 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 74 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 74 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 74 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 74 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 74 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 74 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 74 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 74 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 74 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 74 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)


state 277

    (88) assign -> SVAR ASSIGN ABS L_PAR var R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 297


state 278

    (106) declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 106 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 106 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 106 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 106 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 106 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 106 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 106 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 106 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 106 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 106 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 106 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 106 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 106 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)


state 279

    (82) assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition . SEMICOLON
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

    SEMICOLON       shift and go to state 298
    AND             shift and go to state 125
    OR              shift and go to state 126


state 280

    (83) assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition . SEMICOLON
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

    SEMICOLON       shift and go to state 299
    AND             shift and go to state 125
    OR              shift and go to state 126


state 281

    (107) declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 107 (declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 107 (declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 107 (declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 107 (declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 107 (declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 107 (declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 107 (declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 107 (declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 107 (declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 107 (declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 107 (declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 107 (declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 107 (declaration -> SPVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)


state 282

    (84) assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition . SEMICOLON
    (34) condition -> condition . AND condition
    (35) condition -> condition . OR condition

    SEMICOLON       shift and go to state 300
    AND             shift and go to state 125
    OR              shift and go to state 126


state 283

    (108) declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 108 (declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 108 (declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 108 (declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 108 (declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 108 (declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 108 (declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 108 (declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 108 (declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 108 (declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 108 (declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 108 (declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 108 (declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 108 (declaration -> RAVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)


state 284

    (24) print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET . R_PAR SEMICOLON

    R_PAR           shift and go to state 301


state 285

    (25) print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET . R_PAR SEMICOLON

    R_PAR           shift and go to state 302


state 286

    (26) print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET . R_PAR SEMICOLON

    R_PAR           shift and go to state 303


state 287

    (27) print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET . R_PAR SEMICOLON

    R_PAR           shift and go to state 304


state 288

    (28) print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET . R_PAR SEMICOLON

    R_PAR           shift and go to state 305


state 289

    (29) print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET . R_PAR SEMICOLON

    R_PAR           shift and go to state 306


state 290

    (33) if -> IF L_PAR condition R_PAR GOTO NAME . SEMICOLON

    SEMICOLON       shift and go to state 307


state 291

    (85) assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .

    GOTO            reduce using rule 85 (assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    UNSET           reduce using rule 85 (assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    PRINT           reduce using rule 85 (assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    EXIT            reduce using rule 85 (assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    NAME            reduce using rule 85 (assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    IF              reduce using rule 85 (assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    TVAR            reduce using rule 85 (assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    AVAR            reduce using rule 85 (assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    VVAR            reduce using rule 85 (assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    SVAR            reduce using rule 85 (assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    SPVAR           reduce using rule 85 (assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    RAVAR           reduce using rule 85 (assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    $end            reduce using rule 85 (assign -> TVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)


state 292

    (79) assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 79 (assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 79 (assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 79 (assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 79 (assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 79 (assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    IF              reduce using rule 79 (assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 79 (assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 79 (assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 79 (assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 79 (assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 79 (assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 79 (assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    $end            reduce using rule 79 (assign -> TVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)


state 293

    (86) assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .

    GOTO            reduce using rule 86 (assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    UNSET           reduce using rule 86 (assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    PRINT           reduce using rule 86 (assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    EXIT            reduce using rule 86 (assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    NAME            reduce using rule 86 (assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    IF              reduce using rule 86 (assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    TVAR            reduce using rule 86 (assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    AVAR            reduce using rule 86 (assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    VVAR            reduce using rule 86 (assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    SVAR            reduce using rule 86 (assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    SPVAR           reduce using rule 86 (assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    RAVAR           reduce using rule 86 (assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    $end            reduce using rule 86 (assign -> AVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)


state 294

    (80) assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 80 (assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 80 (assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 80 (assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 80 (assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 80 (assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    IF              reduce using rule 80 (assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 80 (assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 80 (assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 80 (assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 80 (assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 80 (assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 80 (assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    $end            reduce using rule 80 (assign -> AVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)


state 295

    (87) assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .

    GOTO            reduce using rule 87 (assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    UNSET           reduce using rule 87 (assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    PRINT           reduce using rule 87 (assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    EXIT            reduce using rule 87 (assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    NAME            reduce using rule 87 (assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    IF              reduce using rule 87 (assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    TVAR            reduce using rule 87 (assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    AVAR            reduce using rule 87 (assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    VVAR            reduce using rule 87 (assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    SVAR            reduce using rule 87 (assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    SPVAR           reduce using rule 87 (assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    RAVAR           reduce using rule 87 (assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    $end            reduce using rule 87 (assign -> VVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)


state 296

    (81) assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 81 (assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 81 (assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 81 (assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 81 (assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 81 (assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    IF              reduce using rule 81 (assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 81 (assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 81 (assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 81 (assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 81 (assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 81 (assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 81 (assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    $end            reduce using rule 81 (assign -> VVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)


state 297

    (88) assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .

    GOTO            reduce using rule 88 (assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    UNSET           reduce using rule 88 (assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    PRINT           reduce using rule 88 (assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    EXIT            reduce using rule 88 (assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    NAME            reduce using rule 88 (assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    IF              reduce using rule 88 (assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    TVAR            reduce using rule 88 (assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    AVAR            reduce using rule 88 (assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    VVAR            reduce using rule 88 (assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    SVAR            reduce using rule 88 (assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    SPVAR           reduce using rule 88 (assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    RAVAR           reduce using rule 88 (assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)
    $end            reduce using rule 88 (assign -> SVAR ASSIGN ABS L_PAR var R_PAR SEMICOLON .)


state 298

    (82) assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 82 (assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 82 (assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 82 (assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 82 (assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 82 (assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    IF              reduce using rule 82 (assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 82 (assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 82 (assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 82 (assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 82 (assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 82 (assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 82 (assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    $end            reduce using rule 82 (assign -> SVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)


state 299

    (83) assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 83 (assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 83 (assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 83 (assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 83 (assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 83 (assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    IF              reduce using rule 83 (assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 83 (assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 83 (assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 83 (assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 83 (assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 83 (assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 83 (assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    $end            reduce using rule 83 (assign -> SPVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)


state 300

    (84) assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 84 (assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 84 (assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 84 (assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 84 (assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 84 (assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    IF              reduce using rule 84 (assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 84 (assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 84 (assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 84 (assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 84 (assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 84 (assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 84 (assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)
    $end            reduce using rule 84 (assign -> RAVAR L_BRACKET arithmetic R_BRACKET ASSIGN condition SEMICOLON .)


state 301

    (24) print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 308


state 302

    (25) print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 309


state 303

    (26) print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 310


state 304

    (27) print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 311


state 305

    (28) print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 312


state 306

    (29) print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 313


state 307

    (33) if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .

    GOTO            reduce using rule 33 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    UNSET           reduce using rule 33 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    PRINT           reduce using rule 33 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    EXIT            reduce using rule 33 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    NAME            reduce using rule 33 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    IF              reduce using rule 33 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    TVAR            reduce using rule 33 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    AVAR            reduce using rule 33 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    VVAR            reduce using rule 33 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    SVAR            reduce using rule 33 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    SPVAR           reduce using rule 33 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    RAVAR           reduce using rule 33 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    $end            reduce using rule 33 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)


state 308

    (24) print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .

    GOTO            reduce using rule 24 (print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    UNSET           reduce using rule 24 (print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    PRINT           reduce using rule 24 (print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    EXIT            reduce using rule 24 (print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    NAME            reduce using rule 24 (print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    IF              reduce using rule 24 (print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    TVAR            reduce using rule 24 (print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    AVAR            reduce using rule 24 (print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    VVAR            reduce using rule 24 (print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    SVAR            reduce using rule 24 (print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    SPVAR           reduce using rule 24 (print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    RAVAR           reduce using rule 24 (print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    $end            reduce using rule 24 (print -> PRINT L_PAR TVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)


state 309

    (25) print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .

    GOTO            reduce using rule 25 (print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    UNSET           reduce using rule 25 (print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    PRINT           reduce using rule 25 (print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    EXIT            reduce using rule 25 (print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    NAME            reduce using rule 25 (print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    IF              reduce using rule 25 (print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    TVAR            reduce using rule 25 (print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    AVAR            reduce using rule 25 (print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    VVAR            reduce using rule 25 (print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    SVAR            reduce using rule 25 (print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    SPVAR           reduce using rule 25 (print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    RAVAR           reduce using rule 25 (print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    $end            reduce using rule 25 (print -> PRINT L_PAR AVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)


state 310

    (26) print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .

    GOTO            reduce using rule 26 (print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    UNSET           reduce using rule 26 (print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    PRINT           reduce using rule 26 (print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    EXIT            reduce using rule 26 (print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    NAME            reduce using rule 26 (print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    IF              reduce using rule 26 (print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    TVAR            reduce using rule 26 (print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    AVAR            reduce using rule 26 (print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    VVAR            reduce using rule 26 (print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    SVAR            reduce using rule 26 (print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    SPVAR           reduce using rule 26 (print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    RAVAR           reduce using rule 26 (print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    $end            reduce using rule 26 (print -> PRINT L_PAR VVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)


state 311

    (27) print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .

    GOTO            reduce using rule 27 (print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    UNSET           reduce using rule 27 (print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    PRINT           reduce using rule 27 (print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    EXIT            reduce using rule 27 (print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    NAME            reduce using rule 27 (print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    IF              reduce using rule 27 (print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    TVAR            reduce using rule 27 (print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    AVAR            reduce using rule 27 (print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    VVAR            reduce using rule 27 (print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    SVAR            reduce using rule 27 (print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    SPVAR           reduce using rule 27 (print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    RAVAR           reduce using rule 27 (print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    $end            reduce using rule 27 (print -> PRINT L_PAR SVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)


state 312

    (28) print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .

    GOTO            reduce using rule 28 (print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    UNSET           reduce using rule 28 (print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    PRINT           reduce using rule 28 (print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    EXIT            reduce using rule 28 (print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    NAME            reduce using rule 28 (print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    IF              reduce using rule 28 (print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    TVAR            reduce using rule 28 (print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    AVAR            reduce using rule 28 (print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    VVAR            reduce using rule 28 (print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    SVAR            reduce using rule 28 (print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    SPVAR           reduce using rule 28 (print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    RAVAR           reduce using rule 28 (print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    $end            reduce using rule 28 (print -> PRINT L_PAR SPVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)


state 313

    (29) print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .

    GOTO            reduce using rule 29 (print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    UNSET           reduce using rule 29 (print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    PRINT           reduce using rule 29 (print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    EXIT            reduce using rule 29 (print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    NAME            reduce using rule 29 (print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    IF              reduce using rule 29 (print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    TVAR            reduce using rule 29 (print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    AVAR            reduce using rule 29 (print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    VVAR            reduce using rule 29 (print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    SVAR            reduce using rule 29 (print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    SPVAR           reduce using rule 29 (print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    RAVAR           reduce using rule 29 (print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)
    $end            reduce using rule 29 (print -> PRINT L_PAR RAVAR L_BRACKET arithmetic R_BRACKET R_PAR SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MINUS in state 38 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 39 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 40 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 41 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 42 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 43 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 44 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 45 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 46 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 48 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 52 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 78 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 125 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 126 resolved as shift
WARNING: shift/reduce conflict for AND in state 141 resolved as shift
WARNING: shift/reduce conflict for OR in state 141 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 150 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 153 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 154 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 155 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 156 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 185 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 187 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 189 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 191 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 193 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 195 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 225 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 225 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 225 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 225 resolved as shift
WARNING: shift/reduce conflict for REMAINDER in state 225 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 226 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 231 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 236 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 241 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 243 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 246 resolved as shift

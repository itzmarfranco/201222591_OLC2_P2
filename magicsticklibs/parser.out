Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AREMAINDER
    COMMENT
    COMMENT_MULTI
    QUOTE_1
    QUOTE_2

Grammar

Rule 0     S' -> Decls
Rule 1     Decls -> Decl Decls
Rule 2     Decls -> empty
Rule 3     Decl -> Func_Decl
Rule 4     Decl -> Func_Proto
Rule 5     Decl -> Struct_Decl
Rule 6     Decl -> Union_Decl
Rule 7     Decl -> Enum_Decl
Rule 8     Decl -> Var_Decl
Rule 9     Decl -> Typedef_Decl
Rule 10    Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON
Rule 11    Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON
Rule 12    Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON
Rule 13    Func_Decl -> Func_ID L_PAR Params R_PAR Block
Rule 14    Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block
Rule 15    Func_Decl -> Func_ID L_PAR R_PAR Block
Rule 16    Params -> Param COMMA Params
Rule 17    Params -> Param
Rule 18    Param -> CONST Type NAME
Rule 19    Param -> Type NAME
Rule 20    Types -> Type COMMA Types
Rule 21    Types -> Type
Rule 22    Id_List -> NAME COMMA Id_List
Rule 23    Id_List -> NAME
Rule 24    Func_ID -> Type NAME
Rule 25    Func_ID -> NAME
Rule 26    Typedef_Decl -> TYPEDEF Type NAME SEMICOLON
Rule 27    Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON
Rule 28    Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON
Rule 29    Struct_Def -> Var_Decl Struct_Def
Rule 30    Struct_Def -> Var_Decl
Rule 31    Var_Decl -> Mod Type Var Var_List SEMICOLON
Rule 32    Var_Decl -> Type Var Var_List SEMICOLON
Rule 33    Var_Decl -> Mod Var Var_List SEMICOLON
Rule 34    Var -> NAME Array
Rule 35    Var -> NAME Array ASSIGN Op_If
Rule 36    Array -> L_BRACKET Expr R_BRACKET
Rule 37    Array -> L_BRACKET R_BRACKET
Rule 38    Array -> empty
Rule 39    Var_List -> COMMA Var_Item Var_List
Rule 40    Var_List -> empty
Rule 41    Var_Item -> Pointers Var
Rule 42    Mod -> EXTERN
Rule 43    Mod -> STATIC
Rule 44    Mod -> REGISTER
Rule 45    Mod -> AUTO
Rule 46    Mod -> VOLATILE
Rule 47    Mod -> CONST
Rule 48    Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON
Rule 49    Enum_Def -> Enum_Val COMMA Enum_Def
Rule 50    Enum_Def -> Enum_Val
Rule 51    Enum_Val -> NAME
Rule 52    Enum_Val -> NAME ASSIGN INTEGER
Rule 53    Type -> Base Pointers
Rule 54    Base -> Sign Scalar
Rule 55    Base -> STRUCT NAME
Rule 56    Base -> STRUCT L_CURLY Struct_Def R_CURLY
Rule 57    Base -> UNION NAME
Rule 58    Base -> UNION L_CURLY Struct_Def R_CURLY
Rule 59    Base -> ENUM NAME
Rule 60    Sign -> SIGNED
Rule 61    Sign -> UNSIGNED
Rule 62    Sign -> empty
Rule 63    Scalar -> CHAR
Rule 64    Scalar -> INT
Rule 65    Scalar -> FLOAT
Rule 66    Scalar -> DOUBLE
Rule 67    Scalar -> VOID
Rule 68    Pointers -> MULTIPLY Pointers
Rule 69    Pointers -> empty
Rule 70    Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
Rule 71    Printf_Params -> COMMA Printf_Param Printf_Params
Rule 72    Printf_Params -> Printf_Param
Rule 73    Printf_Params -> empty
Rule 74    Printf_Param -> Op_Pointer
Rule 75    Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
Rule 76    Scanf_Param -> AND_B NAME
Rule 77    Scanf_Param -> NAME
Rule 78    Stm -> Var_Decl
Rule 79    Stm -> NAME COLON
Rule 80    Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm
Rule 81    Stm -> IF L_PAR Expr R_PAR Stm
Rule 82    Stm -> WHILE L_PAR Expr R_PAR Stm
Rule 83    Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
Rule 84    Stm -> Normal_Stm
Rule 85    Then_Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Then_Stm
Rule 86    Then_Stm -> WHILE L_PAR Expr R_PAR Then_Stm
Rule 87    Then_Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Then_Stm
Rule 88    Then_Stm -> Normal_Stm
Rule 89    Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR
Rule 90    Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
Rule 91    Normal_Stm -> Block
Rule 92    Normal_Stm -> Expr SEMICOLON
Rule 93    Normal_Stm -> GOTO NAME SEMICOLON
Rule 94    Normal_Stm -> BREAK SEMICOLON
Rule 95    Normal_Stm -> CONTINUE SEMICOLON
Rule 96    Normal_Stm -> RETURN Expr SEMICOLON
Rule 97    Normal_Stm -> SEMICOLON
Rule 98    Arg -> Expr
Rule 99    Arg -> empty
Rule 100   Case_Stms -> CASE Value COLON Stm_List Case_Stms
Rule 101   Case_Stms -> DEFAULT COLON Stm_List
Rule 102   Case_Stms -> empty
Rule 103   Block -> L_CURLY Stm_List R_CURLY
Rule 104   Stm_List -> Stm Stm_List
Rule 105   Stm_List -> empty
Rule 106   Expr -> Expr COMMA Op_Assign
Rule 107   Expr -> Op_Assign
Rule 108   Op_Assign -> Op_If ASSIGN Op_Assign
Rule 109   Op_Assign -> Op_If APLUS Op_Assign
Rule 110   Op_Assign -> Op_If AMINUS Op_Assign
Rule 111   Op_Assign -> Op_If AMULTIPLY Op_Assign
Rule 112   Op_Assign -> Op_If ADIVIDE Op_Assign
Rule 113   Op_Assign -> Op_If AXOR Op_Assign
Rule 114   Op_Assign -> Op_If AAND Op_Assign
Rule 115   Op_Assign -> Op_If AOR Op_Assign
Rule 116   Op_Assign -> Op_If ASHIFT_R Op_Assign
Rule 117   Op_Assign -> Op_If ASHIFT_L Op_Assign
Rule 118   Op_Assign -> Op_If
Rule 119   Op_If -> Op_Or QUESTION Op_If COLON Op_If
Rule 120   Op_If -> Op_Or
Rule 121   Op_Or -> Op_Or OR Op_And
Rule 122   Op_Or -> Op_And
Rule 123   Op_And -> Op_And AND Op_BinOR
Rule 124   Op_And -> Op_BinOR
Rule 125   Op_BinOR -> Op_BinOR OR_B Op_BinXOR
Rule 126   Op_BinOR -> Op_BinXOR
Rule 127   Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND
Rule 128   Op_BinXOR -> Op_BinAND
Rule 129   Op_BinAND -> Op_BinAND AND_B Op_Equate
Rule 130   Op_BinAND -> Op_Equate
Rule 131   Op_Equate -> Op_Equate EQUAL Op_Compare
Rule 132   Op_Equate -> Op_Equate NOT_EQUAL Op_Compare
Rule 133   Op_Equate -> Op_Compare
Rule 134   Op_Compare -> Op_Compare LESS Op_Shift
Rule 135   Op_Compare -> Op_Compare GREATER Op_Shift
Rule 136   Op_Compare -> Op_Compare LESS_EQUAL Op_Shift
Rule 137   Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift
Rule 138   Op_Compare -> Op_Shift
Rule 139   Op_Shift -> Op_Shift SHIFT_L Op_Add
Rule 140   Op_Shift -> Op_Shift SHIFT_R Op_Add
Rule 141   Op_Shift -> Op_Add
Rule 142   Op_Add -> Op_Add PLUS Op_Mult
Rule 143   Op_Add -> Op_Add MINUS Op_Mult
Rule 144   Op_Add -> Op_Mult
Rule 145   Op_Mult -> Op_Mult MULTIPLY Op_Unary
Rule 146   Op_Mult -> Op_Mult DIVIDE Op_Unary
Rule 147   Op_Mult -> Op_Mult REMAINDER Op_Unary
Rule 148   Op_Mult -> Op_Unary
Rule 149   Op_Unary -> NOT Op_Unary
Rule 150   Op_Unary -> NOT_B Op_Unary
Rule 151   Op_Unary -> UMINUS Op_Unary
Rule 152   Op_Unary -> MULTIPLY Op_Unary
Rule 153   Op_Unary -> AND_B Op_Unary
Rule 154   Op_Unary -> PLUSPLUS Op_Unary
Rule 155   Op_Unary -> MINUSMINUS Op_Unary
Rule 156   Op_Unary -> Op_Pointer PLUSPLUS
Rule 157   Op_Unary -> Op_Pointer MINUSMINUS
Rule 158   Op_Unary -> L_PAR Type R_PAR Op_Unary
Rule 159   Op_Unary -> SIZEOF L_PAR Type R_PAR
Rule 160   Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR
Rule 161   Op_Unary -> Op_Pointer
Rule 162   Op_Pointer -> Op_Pointer DOT Value
Rule 163   Op_Pointer -> Op_Pointer ACCESS Value
Rule 164   Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET
Rule 165   Op_Pointer -> Value
Rule 166   Value -> INTEGER
Rule 167   Value -> STRING
Rule 168   Value -> CHARACTER
Rule 169   Value -> DECIMAL
Rule 170   Value -> NAME
Rule 171   Value -> NAME L_PAR Expr R_PAR
Rule 172   Value -> NAME L_PAR R_PAR
Rule 173   Value -> L_PAR Expr R_PAR
Rule 174   empty -> <empty>

Terminals, with rules where they appear

AAND                 : 114
ACCESS               : 163
ADIVIDE              : 112
AMINUS               : 110
AMULTIPLY            : 111
AND                  : 123
AND_B                : 76 129 153
AOR                  : 115
APLUS                : 109
AREMAINDER           : 
ASHIFT_L             : 117
ASHIFT_R             : 116
ASSIGN               : 35 52 108
AUTO                 : 45
AXOR                 : 113
BREAK                : 94
CASE                 : 100
CHAR                 : 63
CHARACTER            : 168
COLON                : 79 100 101 119
COMMA                : 16 20 22 39 49 71 75 106
COMMENT              : 
COMMENT_MULTI        : 
CONST                : 18 47
CONTINUE             : 95
DECIMAL              : 169
DEFAULT              : 101
DIVIDE               : 146
DO                   : 89
DOT                  : 162
DOUBLE               : 66
ELSE                 : 80 85
ENUM                 : 48 59
EQUAL                : 131
EXTERN               : 42
FLOAT                : 65
FOR                  : 83 87
GOTO                 : 93
GREATER              : 135
GREATER_EQUAL        : 137
IF                   : 80 81 85
INT                  : 64
INTEGER              : 52 166
LESS                 : 134
LESS_EQUAL           : 136
L_BRACKET            : 36 37 164
L_CURLY              : 27 28 48 56 58 90 103
L_PAR                : 10 11 12 13 14 15 70 75 80 81 82 83 85 86 87 89 90 158 159 160 171 172 173
MINUS                : 143
MINUSMINUS           : 155 157
MULTIPLY             : 68 145 152
NAME                 : 18 19 22 23 24 25 26 27 28 34 35 48 51 52 55 57 59 76 77 79 93 160 170 171 172
NOT                  : 149
NOT_B                : 150
NOT_EQUAL            : 132
OR                   : 121
OR_B                 : 125
PLUS                 : 142
PLUSPLUS             : 154 156
PRINTF               : 70
QUESTION             : 119
QUOTE_1              : 
QUOTE_2              : 
REGISTER             : 44
REMAINDER            : 147
RETURN               : 96
R_BRACKET            : 36 37 164
R_CURLY              : 27 28 48 56 58 90 103
R_PAR                : 10 11 12 13 14 15 70 75 80 81 82 83 85 86 87 89 90 158 159 160 171 172 173
SCANF                : 75
SEMICOLON            : 10 11 12 26 27 28 31 32 33 48 70 75 83 83 87 87 92 93 94 95 96 97
SHIFT_L              : 139
SHIFT_R              : 140
SIGNED               : 60
SIZEOF               : 159 160
STATIC               : 43
STRING               : 70 75 167
STRUCT               : 27 55 56
SWITCH               : 90
TYPEDEF              : 26
UMINUS               : 151
UNION                : 28 57 58
UNSIGNED             : 61
VOID                 : 67
VOLATILE             : 46
WHILE                : 82 86 89
XOR_B                : 127
error                : 

Nonterminals, with rules where they appear

Arg                  : 83 83 83 87 87 87
Array                : 34 35
Base                 : 53
Block                : 13 14 15 91
Case_Stms            : 90 100
Decl                 : 1
Decls                : 1 0
Enum_Decl            : 7
Enum_Def             : 48 49
Enum_Val             : 49 50
Expr                 : 36 80 81 82 85 86 89 90 92 96 98 106 164 171 173
Func_Decl            : 3
Func_ID              : 10 11 12 13 14 15
Func_Proto           : 4
Id_List              : 14 22
Mod                  : 31 33
Normal_Stm           : 84 88
Op_Add               : 139 140 141 142 143
Op_And               : 121 122 123
Op_Assign            : 106 107 108 109 110 111 112 113 114 115 116 117
Op_BinAND            : 127 128 129
Op_BinOR             : 123 124 125
Op_BinXOR            : 125 126 127
Op_Compare           : 131 132 133 134 135 136 137
Op_Equate            : 129 130 131 132
Op_If                : 35 108 109 110 111 112 113 114 115 116 117 118 119 119
Op_Mult              : 142 143 144 145 146 147
Op_Or                : 119 120 121
Op_Pointer           : 74 156 157 161 162 163 164
Op_Shift             : 134 135 136 137 138 139 140
Op_Unary             : 145 146 147 148 149 150 151 152 153 154 155 158
Param                : 16 17
Params               : 11 13 16
Pointers             : 41 53 68 160
Printf_Param         : 71 72
Printf_Params        : 70 71
Scalar               : 54
Scanf_Param          : 75
Sign                 : 54
Stm                  : 80 81 82 83 89 104
Stm_List             : 100 101 103 104
Struct_Decl          : 5
Struct_Def           : 14 27 28 29 56 58
Then_Stm             : 80 85 85 86 87
Type                 : 18 19 20 21 24 26 31 32 158 159
Typedef_Decl         : 9
Types                : 10 20
Union_Decl           : 6
Value                : 100 162 163 165
Var                  : 31 32 33 41
Var_Decl             : 8 29 30 78
Var_Item             : 39
Var_List             : 31 32 33 39
empty                : 2 38 40 62 69 73 99 102 105

Parsing method: LALR

state 0

    (0) S' -> . Decls
    (1) Decls -> . Decl Decls
    (2) Decls -> . empty
    (3) Decl -> . Func_Decl
    (4) Decl -> . Func_Proto
    (5) Decl -> . Struct_Decl
    (6) Decl -> . Union_Decl
    (7) Decl -> . Enum_Decl
    (8) Decl -> . Var_Decl
    (9) Decl -> . Typedef_Decl
    (174) empty -> .
    (13) Func_Decl -> . Func_ID L_PAR Params R_PAR Block
    (14) Func_Decl -> . Func_ID L_PAR Id_List R_PAR Struct_Def Block
    (15) Func_Decl -> . Func_ID L_PAR R_PAR Block
    (10) Func_Proto -> . Func_ID L_PAR Types R_PAR SEMICOLON
    (11) Func_Proto -> . Func_ID L_PAR Params R_PAR SEMICOLON
    (12) Func_Proto -> . Func_ID L_PAR R_PAR SEMICOLON
    (27) Struct_Decl -> . STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON
    (28) Union_Decl -> . UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON
    (48) Enum_Decl -> . ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (26) Typedef_Decl -> . TYPEDEF Type NAME SEMICOLON
    (24) Func_ID -> . Type NAME
    (25) Func_ID -> . NAME
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty

    $end            reduce using rule 174 (empty -> .)
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    STRUCT          shift and go to state 12
    UNION           shift and go to state 14
    ENUM            shift and go to state 15
    TYPEDEF         shift and go to state 18
    NAME            shift and go to state 13
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28

    Decls                          shift and go to state 1
    Decl                           shift and go to state 2
    empty                          shift and go to state 3
    Func_Decl                      shift and go to state 4
    Func_Proto                     shift and go to state 5
    Struct_Decl                    shift and go to state 6
    Union_Decl                     shift and go to state 7
    Enum_Decl                      shift and go to state 8
    Var_Decl                       shift and go to state 9
    Typedef_Decl                   shift and go to state 10
    Func_ID                        shift and go to state 11
    Mod                            shift and go to state 16
    Type                           shift and go to state 17
    Base                           shift and go to state 25
    Sign                           shift and go to state 26

state 1

    (0) S' -> Decls .



state 2

    (1) Decls -> Decl . Decls
    (1) Decls -> . Decl Decls
    (2) Decls -> . empty
    (3) Decl -> . Func_Decl
    (4) Decl -> . Func_Proto
    (5) Decl -> . Struct_Decl
    (6) Decl -> . Union_Decl
    (7) Decl -> . Enum_Decl
    (8) Decl -> . Var_Decl
    (9) Decl -> . Typedef_Decl
    (174) empty -> .
    (13) Func_Decl -> . Func_ID L_PAR Params R_PAR Block
    (14) Func_Decl -> . Func_ID L_PAR Id_List R_PAR Struct_Def Block
    (15) Func_Decl -> . Func_ID L_PAR R_PAR Block
    (10) Func_Proto -> . Func_ID L_PAR Types R_PAR SEMICOLON
    (11) Func_Proto -> . Func_ID L_PAR Params R_PAR SEMICOLON
    (12) Func_Proto -> . Func_ID L_PAR R_PAR SEMICOLON
    (27) Struct_Decl -> . STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON
    (28) Union_Decl -> . UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON
    (48) Enum_Decl -> . ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (26) Typedef_Decl -> . TYPEDEF Type NAME SEMICOLON
    (24) Func_ID -> . Type NAME
    (25) Func_ID -> . NAME
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty

    $end            reduce using rule 174 (empty -> .)
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    STRUCT          shift and go to state 12
    UNION           shift and go to state 14
    ENUM            shift and go to state 15
    TYPEDEF         shift and go to state 18
    NAME            shift and go to state 13
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28

    Decl                           shift and go to state 2
    Decls                          shift and go to state 29
    empty                          shift and go to state 3
    Func_Decl                      shift and go to state 4
    Func_Proto                     shift and go to state 5
    Struct_Decl                    shift and go to state 6
    Union_Decl                     shift and go to state 7
    Enum_Decl                      shift and go to state 8
    Var_Decl                       shift and go to state 9
    Typedef_Decl                   shift and go to state 10
    Func_ID                        shift and go to state 11
    Mod                            shift and go to state 16
    Type                           shift and go to state 17
    Base                           shift and go to state 25
    Sign                           shift and go to state 26

state 3

    (2) Decls -> empty .
    (62) Sign -> empty .

    $end            reduce using rule 2 (Decls -> empty .)
    CHAR            reduce using rule 62 (Sign -> empty .)
    INT             reduce using rule 62 (Sign -> empty .)
    FLOAT           reduce using rule 62 (Sign -> empty .)
    DOUBLE          reduce using rule 62 (Sign -> empty .)
    VOID            reduce using rule 62 (Sign -> empty .)


state 4

    (3) Decl -> Func_Decl .

    STRUCT          reduce using rule 3 (Decl -> Func_Decl .)
    UNION           reduce using rule 3 (Decl -> Func_Decl .)
    ENUM            reduce using rule 3 (Decl -> Func_Decl .)
    TYPEDEF         reduce using rule 3 (Decl -> Func_Decl .)
    NAME            reduce using rule 3 (Decl -> Func_Decl .)
    EXTERN          reduce using rule 3 (Decl -> Func_Decl .)
    STATIC          reduce using rule 3 (Decl -> Func_Decl .)
    REGISTER        reduce using rule 3 (Decl -> Func_Decl .)
    AUTO            reduce using rule 3 (Decl -> Func_Decl .)
    VOLATILE        reduce using rule 3 (Decl -> Func_Decl .)
    CONST           reduce using rule 3 (Decl -> Func_Decl .)
    SIGNED          reduce using rule 3 (Decl -> Func_Decl .)
    UNSIGNED        reduce using rule 3 (Decl -> Func_Decl .)
    CHAR            reduce using rule 3 (Decl -> Func_Decl .)
    INT             reduce using rule 3 (Decl -> Func_Decl .)
    FLOAT           reduce using rule 3 (Decl -> Func_Decl .)
    DOUBLE          reduce using rule 3 (Decl -> Func_Decl .)
    VOID            reduce using rule 3 (Decl -> Func_Decl .)
    $end            reduce using rule 3 (Decl -> Func_Decl .)


state 5

    (4) Decl -> Func_Proto .

    STRUCT          reduce using rule 4 (Decl -> Func_Proto .)
    UNION           reduce using rule 4 (Decl -> Func_Proto .)
    ENUM            reduce using rule 4 (Decl -> Func_Proto .)
    TYPEDEF         reduce using rule 4 (Decl -> Func_Proto .)
    NAME            reduce using rule 4 (Decl -> Func_Proto .)
    EXTERN          reduce using rule 4 (Decl -> Func_Proto .)
    STATIC          reduce using rule 4 (Decl -> Func_Proto .)
    REGISTER        reduce using rule 4 (Decl -> Func_Proto .)
    AUTO            reduce using rule 4 (Decl -> Func_Proto .)
    VOLATILE        reduce using rule 4 (Decl -> Func_Proto .)
    CONST           reduce using rule 4 (Decl -> Func_Proto .)
    SIGNED          reduce using rule 4 (Decl -> Func_Proto .)
    UNSIGNED        reduce using rule 4 (Decl -> Func_Proto .)
    CHAR            reduce using rule 4 (Decl -> Func_Proto .)
    INT             reduce using rule 4 (Decl -> Func_Proto .)
    FLOAT           reduce using rule 4 (Decl -> Func_Proto .)
    DOUBLE          reduce using rule 4 (Decl -> Func_Proto .)
    VOID            reduce using rule 4 (Decl -> Func_Proto .)
    $end            reduce using rule 4 (Decl -> Func_Proto .)


state 6

    (5) Decl -> Struct_Decl .

    STRUCT          reduce using rule 5 (Decl -> Struct_Decl .)
    UNION           reduce using rule 5 (Decl -> Struct_Decl .)
    ENUM            reduce using rule 5 (Decl -> Struct_Decl .)
    TYPEDEF         reduce using rule 5 (Decl -> Struct_Decl .)
    NAME            reduce using rule 5 (Decl -> Struct_Decl .)
    EXTERN          reduce using rule 5 (Decl -> Struct_Decl .)
    STATIC          reduce using rule 5 (Decl -> Struct_Decl .)
    REGISTER        reduce using rule 5 (Decl -> Struct_Decl .)
    AUTO            reduce using rule 5 (Decl -> Struct_Decl .)
    VOLATILE        reduce using rule 5 (Decl -> Struct_Decl .)
    CONST           reduce using rule 5 (Decl -> Struct_Decl .)
    SIGNED          reduce using rule 5 (Decl -> Struct_Decl .)
    UNSIGNED        reduce using rule 5 (Decl -> Struct_Decl .)
    CHAR            reduce using rule 5 (Decl -> Struct_Decl .)
    INT             reduce using rule 5 (Decl -> Struct_Decl .)
    FLOAT           reduce using rule 5 (Decl -> Struct_Decl .)
    DOUBLE          reduce using rule 5 (Decl -> Struct_Decl .)
    VOID            reduce using rule 5 (Decl -> Struct_Decl .)
    $end            reduce using rule 5 (Decl -> Struct_Decl .)


state 7

    (6) Decl -> Union_Decl .

    STRUCT          reduce using rule 6 (Decl -> Union_Decl .)
    UNION           reduce using rule 6 (Decl -> Union_Decl .)
    ENUM            reduce using rule 6 (Decl -> Union_Decl .)
    TYPEDEF         reduce using rule 6 (Decl -> Union_Decl .)
    NAME            reduce using rule 6 (Decl -> Union_Decl .)
    EXTERN          reduce using rule 6 (Decl -> Union_Decl .)
    STATIC          reduce using rule 6 (Decl -> Union_Decl .)
    REGISTER        reduce using rule 6 (Decl -> Union_Decl .)
    AUTO            reduce using rule 6 (Decl -> Union_Decl .)
    VOLATILE        reduce using rule 6 (Decl -> Union_Decl .)
    CONST           reduce using rule 6 (Decl -> Union_Decl .)
    SIGNED          reduce using rule 6 (Decl -> Union_Decl .)
    UNSIGNED        reduce using rule 6 (Decl -> Union_Decl .)
    CHAR            reduce using rule 6 (Decl -> Union_Decl .)
    INT             reduce using rule 6 (Decl -> Union_Decl .)
    FLOAT           reduce using rule 6 (Decl -> Union_Decl .)
    DOUBLE          reduce using rule 6 (Decl -> Union_Decl .)
    VOID            reduce using rule 6 (Decl -> Union_Decl .)
    $end            reduce using rule 6 (Decl -> Union_Decl .)


state 8

    (7) Decl -> Enum_Decl .

    STRUCT          reduce using rule 7 (Decl -> Enum_Decl .)
    UNION           reduce using rule 7 (Decl -> Enum_Decl .)
    ENUM            reduce using rule 7 (Decl -> Enum_Decl .)
    TYPEDEF         reduce using rule 7 (Decl -> Enum_Decl .)
    NAME            reduce using rule 7 (Decl -> Enum_Decl .)
    EXTERN          reduce using rule 7 (Decl -> Enum_Decl .)
    STATIC          reduce using rule 7 (Decl -> Enum_Decl .)
    REGISTER        reduce using rule 7 (Decl -> Enum_Decl .)
    AUTO            reduce using rule 7 (Decl -> Enum_Decl .)
    VOLATILE        reduce using rule 7 (Decl -> Enum_Decl .)
    CONST           reduce using rule 7 (Decl -> Enum_Decl .)
    SIGNED          reduce using rule 7 (Decl -> Enum_Decl .)
    UNSIGNED        reduce using rule 7 (Decl -> Enum_Decl .)
    CHAR            reduce using rule 7 (Decl -> Enum_Decl .)
    INT             reduce using rule 7 (Decl -> Enum_Decl .)
    FLOAT           reduce using rule 7 (Decl -> Enum_Decl .)
    DOUBLE          reduce using rule 7 (Decl -> Enum_Decl .)
    VOID            reduce using rule 7 (Decl -> Enum_Decl .)
    $end            reduce using rule 7 (Decl -> Enum_Decl .)


state 9

    (8) Decl -> Var_Decl .

    STRUCT          reduce using rule 8 (Decl -> Var_Decl .)
    UNION           reduce using rule 8 (Decl -> Var_Decl .)
    ENUM            reduce using rule 8 (Decl -> Var_Decl .)
    TYPEDEF         reduce using rule 8 (Decl -> Var_Decl .)
    NAME            reduce using rule 8 (Decl -> Var_Decl .)
    EXTERN          reduce using rule 8 (Decl -> Var_Decl .)
    STATIC          reduce using rule 8 (Decl -> Var_Decl .)
    REGISTER        reduce using rule 8 (Decl -> Var_Decl .)
    AUTO            reduce using rule 8 (Decl -> Var_Decl .)
    VOLATILE        reduce using rule 8 (Decl -> Var_Decl .)
    CONST           reduce using rule 8 (Decl -> Var_Decl .)
    SIGNED          reduce using rule 8 (Decl -> Var_Decl .)
    UNSIGNED        reduce using rule 8 (Decl -> Var_Decl .)
    CHAR            reduce using rule 8 (Decl -> Var_Decl .)
    INT             reduce using rule 8 (Decl -> Var_Decl .)
    FLOAT           reduce using rule 8 (Decl -> Var_Decl .)
    DOUBLE          reduce using rule 8 (Decl -> Var_Decl .)
    VOID            reduce using rule 8 (Decl -> Var_Decl .)
    $end            reduce using rule 8 (Decl -> Var_Decl .)


state 10

    (9) Decl -> Typedef_Decl .

    STRUCT          reduce using rule 9 (Decl -> Typedef_Decl .)
    UNION           reduce using rule 9 (Decl -> Typedef_Decl .)
    ENUM            reduce using rule 9 (Decl -> Typedef_Decl .)
    TYPEDEF         reduce using rule 9 (Decl -> Typedef_Decl .)
    NAME            reduce using rule 9 (Decl -> Typedef_Decl .)
    EXTERN          reduce using rule 9 (Decl -> Typedef_Decl .)
    STATIC          reduce using rule 9 (Decl -> Typedef_Decl .)
    REGISTER        reduce using rule 9 (Decl -> Typedef_Decl .)
    AUTO            reduce using rule 9 (Decl -> Typedef_Decl .)
    VOLATILE        reduce using rule 9 (Decl -> Typedef_Decl .)
    CONST           reduce using rule 9 (Decl -> Typedef_Decl .)
    SIGNED          reduce using rule 9 (Decl -> Typedef_Decl .)
    UNSIGNED        reduce using rule 9 (Decl -> Typedef_Decl .)
    CHAR            reduce using rule 9 (Decl -> Typedef_Decl .)
    INT             reduce using rule 9 (Decl -> Typedef_Decl .)
    FLOAT           reduce using rule 9 (Decl -> Typedef_Decl .)
    DOUBLE          reduce using rule 9 (Decl -> Typedef_Decl .)
    VOID            reduce using rule 9 (Decl -> Typedef_Decl .)
    $end            reduce using rule 9 (Decl -> Typedef_Decl .)


state 11

    (13) Func_Decl -> Func_ID . L_PAR Params R_PAR Block
    (14) Func_Decl -> Func_ID . L_PAR Id_List R_PAR Struct_Def Block
    (15) Func_Decl -> Func_ID . L_PAR R_PAR Block
    (10) Func_Proto -> Func_ID . L_PAR Types R_PAR SEMICOLON
    (11) Func_Proto -> Func_ID . L_PAR Params R_PAR SEMICOLON
    (12) Func_Proto -> Func_ID . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 30


state 12

    (27) Struct_Decl -> STRUCT . NAME L_CURLY Struct_Def R_CURLY SEMICOLON
    (55) Base -> STRUCT . NAME
    (56) Base -> STRUCT . L_CURLY Struct_Def R_CURLY

    NAME            shift and go to state 31
    L_CURLY         shift and go to state 32


state 13

    (25) Func_ID -> NAME .

    L_PAR           reduce using rule 25 (Func_ID -> NAME .)


state 14

    (28) Union_Decl -> UNION . NAME L_CURLY Struct_Def R_CURLY SEMICOLON
    (57) Base -> UNION . NAME
    (58) Base -> UNION . L_CURLY Struct_Def R_CURLY

    NAME            shift and go to state 33
    L_CURLY         shift and go to state 34


state 15

    (48) Enum_Decl -> ENUM . NAME L_CURLY Enum_Def R_CURLY SEMICOLON
    (59) Base -> ENUM . NAME

    NAME            shift and go to state 35


state 16

    (31) Var_Decl -> Mod . Type Var Var_List SEMICOLON
    (33) Var_Decl -> Mod . Var Var_List SEMICOLON
    (53) Type -> . Base Pointers
    (34) Var -> . NAME Array
    (35) Var -> . NAME Array ASSIGN Op_If
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (174) empty -> .

    NAME            shift and go to state 38
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)

    Type                           shift and go to state 36
    Var                            shift and go to state 37
    Base                           shift and go to state 25
    Sign                           shift and go to state 26
    empty                          shift and go to state 42

state 17

    (32) Var_Decl -> Type . Var Var_List SEMICOLON
    (24) Func_ID -> Type . NAME
    (34) Var -> . NAME Array
    (35) Var -> . NAME Array ASSIGN Op_If

    NAME            shift and go to state 44

    Var                            shift and go to state 43

state 18

    (26) Typedef_Decl -> TYPEDEF . Type NAME SEMICOLON
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (174) empty -> .

    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)

    Type                           shift and go to state 45
    Base                           shift and go to state 25
    Sign                           shift and go to state 26
    empty                          shift and go to state 42

state 19

    (42) Mod -> EXTERN .

    NAME            reduce using rule 42 (Mod -> EXTERN .)
    STRUCT          reduce using rule 42 (Mod -> EXTERN .)
    UNION           reduce using rule 42 (Mod -> EXTERN .)
    ENUM            reduce using rule 42 (Mod -> EXTERN .)
    SIGNED          reduce using rule 42 (Mod -> EXTERN .)
    UNSIGNED        reduce using rule 42 (Mod -> EXTERN .)
    CHAR            reduce using rule 42 (Mod -> EXTERN .)
    INT             reduce using rule 42 (Mod -> EXTERN .)
    FLOAT           reduce using rule 42 (Mod -> EXTERN .)
    DOUBLE          reduce using rule 42 (Mod -> EXTERN .)
    VOID            reduce using rule 42 (Mod -> EXTERN .)


state 20

    (43) Mod -> STATIC .

    NAME            reduce using rule 43 (Mod -> STATIC .)
    STRUCT          reduce using rule 43 (Mod -> STATIC .)
    UNION           reduce using rule 43 (Mod -> STATIC .)
    ENUM            reduce using rule 43 (Mod -> STATIC .)
    SIGNED          reduce using rule 43 (Mod -> STATIC .)
    UNSIGNED        reduce using rule 43 (Mod -> STATIC .)
    CHAR            reduce using rule 43 (Mod -> STATIC .)
    INT             reduce using rule 43 (Mod -> STATIC .)
    FLOAT           reduce using rule 43 (Mod -> STATIC .)
    DOUBLE          reduce using rule 43 (Mod -> STATIC .)
    VOID            reduce using rule 43 (Mod -> STATIC .)


state 21

    (44) Mod -> REGISTER .

    NAME            reduce using rule 44 (Mod -> REGISTER .)
    STRUCT          reduce using rule 44 (Mod -> REGISTER .)
    UNION           reduce using rule 44 (Mod -> REGISTER .)
    ENUM            reduce using rule 44 (Mod -> REGISTER .)
    SIGNED          reduce using rule 44 (Mod -> REGISTER .)
    UNSIGNED        reduce using rule 44 (Mod -> REGISTER .)
    CHAR            reduce using rule 44 (Mod -> REGISTER .)
    INT             reduce using rule 44 (Mod -> REGISTER .)
    FLOAT           reduce using rule 44 (Mod -> REGISTER .)
    DOUBLE          reduce using rule 44 (Mod -> REGISTER .)
    VOID            reduce using rule 44 (Mod -> REGISTER .)


state 22

    (45) Mod -> AUTO .

    NAME            reduce using rule 45 (Mod -> AUTO .)
    STRUCT          reduce using rule 45 (Mod -> AUTO .)
    UNION           reduce using rule 45 (Mod -> AUTO .)
    ENUM            reduce using rule 45 (Mod -> AUTO .)
    SIGNED          reduce using rule 45 (Mod -> AUTO .)
    UNSIGNED        reduce using rule 45 (Mod -> AUTO .)
    CHAR            reduce using rule 45 (Mod -> AUTO .)
    INT             reduce using rule 45 (Mod -> AUTO .)
    FLOAT           reduce using rule 45 (Mod -> AUTO .)
    DOUBLE          reduce using rule 45 (Mod -> AUTO .)
    VOID            reduce using rule 45 (Mod -> AUTO .)


state 23

    (46) Mod -> VOLATILE .

    NAME            reduce using rule 46 (Mod -> VOLATILE .)
    STRUCT          reduce using rule 46 (Mod -> VOLATILE .)
    UNION           reduce using rule 46 (Mod -> VOLATILE .)
    ENUM            reduce using rule 46 (Mod -> VOLATILE .)
    SIGNED          reduce using rule 46 (Mod -> VOLATILE .)
    UNSIGNED        reduce using rule 46 (Mod -> VOLATILE .)
    CHAR            reduce using rule 46 (Mod -> VOLATILE .)
    INT             reduce using rule 46 (Mod -> VOLATILE .)
    FLOAT           reduce using rule 46 (Mod -> VOLATILE .)
    DOUBLE          reduce using rule 46 (Mod -> VOLATILE .)
    VOID            reduce using rule 46 (Mod -> VOLATILE .)


state 24

    (47) Mod -> CONST .

    NAME            reduce using rule 47 (Mod -> CONST .)
    STRUCT          reduce using rule 47 (Mod -> CONST .)
    UNION           reduce using rule 47 (Mod -> CONST .)
    ENUM            reduce using rule 47 (Mod -> CONST .)
    SIGNED          reduce using rule 47 (Mod -> CONST .)
    UNSIGNED        reduce using rule 47 (Mod -> CONST .)
    CHAR            reduce using rule 47 (Mod -> CONST .)
    INT             reduce using rule 47 (Mod -> CONST .)
    FLOAT           reduce using rule 47 (Mod -> CONST .)
    DOUBLE          reduce using rule 47 (Mod -> CONST .)
    VOID            reduce using rule 47 (Mod -> CONST .)


state 25

    (53) Type -> Base . Pointers
    (68) Pointers -> . MULTIPLY Pointers
    (69) Pointers -> . empty
    (174) empty -> .

    MULTIPLY        shift and go to state 47
    NAME            reduce using rule 174 (empty -> .)
    COMMA           reduce using rule 174 (empty -> .)
    R_PAR           reduce using rule 174 (empty -> .)

    Pointers                       shift and go to state 46
    empty                          shift and go to state 48

state 26

    (54) Base -> Sign . Scalar
    (63) Scalar -> . CHAR
    (64) Scalar -> . INT
    (65) Scalar -> . FLOAT
    (66) Scalar -> . DOUBLE
    (67) Scalar -> . VOID

    CHAR            shift and go to state 50
    INT             shift and go to state 51
    FLOAT           shift and go to state 52
    DOUBLE          shift and go to state 53
    VOID            shift and go to state 54

    Scalar                         shift and go to state 49

state 27

    (60) Sign -> SIGNED .

    CHAR            reduce using rule 60 (Sign -> SIGNED .)
    INT             reduce using rule 60 (Sign -> SIGNED .)
    FLOAT           reduce using rule 60 (Sign -> SIGNED .)
    DOUBLE          reduce using rule 60 (Sign -> SIGNED .)
    VOID            reduce using rule 60 (Sign -> SIGNED .)


state 28

    (61) Sign -> UNSIGNED .

    CHAR            reduce using rule 61 (Sign -> UNSIGNED .)
    INT             reduce using rule 61 (Sign -> UNSIGNED .)
    FLOAT           reduce using rule 61 (Sign -> UNSIGNED .)
    DOUBLE          reduce using rule 61 (Sign -> UNSIGNED .)
    VOID            reduce using rule 61 (Sign -> UNSIGNED .)


state 29

    (1) Decls -> Decl Decls .

    $end            reduce using rule 1 (Decls -> Decl Decls .)


state 30

    (13) Func_Decl -> Func_ID L_PAR . Params R_PAR Block
    (14) Func_Decl -> Func_ID L_PAR . Id_List R_PAR Struct_Def Block
    (15) Func_Decl -> Func_ID L_PAR . R_PAR Block
    (10) Func_Proto -> Func_ID L_PAR . Types R_PAR SEMICOLON
    (11) Func_Proto -> Func_ID L_PAR . Params R_PAR SEMICOLON
    (12) Func_Proto -> Func_ID L_PAR . R_PAR SEMICOLON
    (16) Params -> . Param COMMA Params
    (17) Params -> . Param
    (22) Id_List -> . NAME COMMA Id_List
    (23) Id_List -> . NAME
    (20) Types -> . Type COMMA Types
    (21) Types -> . Type
    (18) Param -> . CONST Type NAME
    (19) Param -> . Type NAME
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (174) empty -> .

    R_PAR           shift and go to state 56
    NAME            shift and go to state 60
    CONST           shift and go to state 62
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)

    Params                         shift and go to state 55
    Id_List                        shift and go to state 57
    Types                          shift and go to state 58
    Param                          shift and go to state 59
    Type                           shift and go to state 61
    Base                           shift and go to state 25
    Sign                           shift and go to state 26
    empty                          shift and go to state 42

state 31

    (27) Struct_Decl -> STRUCT NAME . L_CURLY Struct_Def R_CURLY SEMICOLON
    (55) Base -> STRUCT NAME .

    L_CURLY         shift and go to state 63
    MULTIPLY        reduce using rule 55 (Base -> STRUCT NAME .)
    NAME            reduce using rule 55 (Base -> STRUCT NAME .)


state 32

    (56) Base -> STRUCT L_CURLY . Struct_Def R_CURLY
    (29) Struct_Def -> . Var_Decl Struct_Def
    (30) Struct_Def -> . Var_Decl
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (174) empty -> .

    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)

    Struct_Def                     shift and go to state 64
    Var_Decl                       shift and go to state 65
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Base                           shift and go to state 25
    Sign                           shift and go to state 26
    empty                          shift and go to state 42

state 33

    (28) Union_Decl -> UNION NAME . L_CURLY Struct_Def R_CURLY SEMICOLON
    (57) Base -> UNION NAME .

    L_CURLY         shift and go to state 67
    MULTIPLY        reduce using rule 57 (Base -> UNION NAME .)
    NAME            reduce using rule 57 (Base -> UNION NAME .)


state 34

    (58) Base -> UNION L_CURLY . Struct_Def R_CURLY
    (29) Struct_Def -> . Var_Decl Struct_Def
    (30) Struct_Def -> . Var_Decl
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (174) empty -> .

    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)

    Struct_Def                     shift and go to state 68
    Var_Decl                       shift and go to state 65
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Base                           shift and go to state 25
    Sign                           shift and go to state 26
    empty                          shift and go to state 42

state 35

    (48) Enum_Decl -> ENUM NAME . L_CURLY Enum_Def R_CURLY SEMICOLON
    (59) Base -> ENUM NAME .

    L_CURLY         shift and go to state 69
    MULTIPLY        reduce using rule 59 (Base -> ENUM NAME .)
    NAME            reduce using rule 59 (Base -> ENUM NAME .)


state 36

    (31) Var_Decl -> Mod Type . Var Var_List SEMICOLON
    (34) Var -> . NAME Array
    (35) Var -> . NAME Array ASSIGN Op_If

    NAME            shift and go to state 38

    Var                            shift and go to state 70

state 37

    (33) Var_Decl -> Mod Var . Var_List SEMICOLON
    (39) Var_List -> . COMMA Var_Item Var_List
    (40) Var_List -> . empty
    (174) empty -> .

    COMMA           shift and go to state 72
    SEMICOLON       reduce using rule 174 (empty -> .)

    Var_List                       shift and go to state 71
    empty                          shift and go to state 73

state 38

    (34) Var -> NAME . Array
    (35) Var -> NAME . Array ASSIGN Op_If
    (36) Array -> . L_BRACKET Expr R_BRACKET
    (37) Array -> . L_BRACKET R_BRACKET
    (38) Array -> . empty
    (174) empty -> .

    L_BRACKET       shift and go to state 75
    ASSIGN          reduce using rule 174 (empty -> .)
    COMMA           reduce using rule 174 (empty -> .)
    SEMICOLON       reduce using rule 174 (empty -> .)

    Array                          shift and go to state 74
    empty                          shift and go to state 76

state 39

    (55) Base -> STRUCT . NAME
    (56) Base -> STRUCT . L_CURLY Struct_Def R_CURLY

    NAME            shift and go to state 77
    L_CURLY         shift and go to state 32


state 40

    (57) Base -> UNION . NAME
    (58) Base -> UNION . L_CURLY Struct_Def R_CURLY

    NAME            shift and go to state 78
    L_CURLY         shift and go to state 34


state 41

    (59) Base -> ENUM . NAME

    NAME            shift and go to state 79


state 42

    (62) Sign -> empty .

    CHAR            reduce using rule 62 (Sign -> empty .)
    INT             reduce using rule 62 (Sign -> empty .)
    FLOAT           reduce using rule 62 (Sign -> empty .)
    DOUBLE          reduce using rule 62 (Sign -> empty .)
    VOID            reduce using rule 62 (Sign -> empty .)


state 43

    (32) Var_Decl -> Type Var . Var_List SEMICOLON
    (39) Var_List -> . COMMA Var_Item Var_List
    (40) Var_List -> . empty
    (174) empty -> .

    COMMA           shift and go to state 72
    SEMICOLON       reduce using rule 174 (empty -> .)

    Var_List                       shift and go to state 80
    empty                          shift and go to state 73

state 44

    (24) Func_ID -> Type NAME .
    (34) Var -> NAME . Array
    (35) Var -> NAME . Array ASSIGN Op_If
    (36) Array -> . L_BRACKET Expr R_BRACKET
    (37) Array -> . L_BRACKET R_BRACKET
    (38) Array -> . empty
    (174) empty -> .

    L_PAR           reduce using rule 24 (Func_ID -> Type NAME .)
    L_BRACKET       shift and go to state 75
    ASSIGN          reduce using rule 174 (empty -> .)
    COMMA           reduce using rule 174 (empty -> .)
    SEMICOLON       reduce using rule 174 (empty -> .)

    Array                          shift and go to state 74
    empty                          shift and go to state 76

state 45

    (26) Typedef_Decl -> TYPEDEF Type . NAME SEMICOLON

    NAME            shift and go to state 81


state 46

    (53) Type -> Base Pointers .

    NAME            reduce using rule 53 (Type -> Base Pointers .)
    COMMA           reduce using rule 53 (Type -> Base Pointers .)
    R_PAR           reduce using rule 53 (Type -> Base Pointers .)


state 47

    (68) Pointers -> MULTIPLY . Pointers
    (68) Pointers -> . MULTIPLY Pointers
    (69) Pointers -> . empty
    (174) empty -> .

    MULTIPLY        shift and go to state 47
    NAME            reduce using rule 174 (empty -> .)
    COMMA           reduce using rule 174 (empty -> .)
    R_PAR           reduce using rule 174 (empty -> .)

    Pointers                       shift and go to state 82
    empty                          shift and go to state 48

state 48

    (69) Pointers -> empty .

    NAME            reduce using rule 69 (Pointers -> empty .)
    COMMA           reduce using rule 69 (Pointers -> empty .)
    R_PAR           reduce using rule 69 (Pointers -> empty .)


state 49

    (54) Base -> Sign Scalar .

    MULTIPLY        reduce using rule 54 (Base -> Sign Scalar .)
    NAME            reduce using rule 54 (Base -> Sign Scalar .)
    COMMA           reduce using rule 54 (Base -> Sign Scalar .)
    R_PAR           reduce using rule 54 (Base -> Sign Scalar .)


state 50

    (63) Scalar -> CHAR .

    MULTIPLY        reduce using rule 63 (Scalar -> CHAR .)
    NAME            reduce using rule 63 (Scalar -> CHAR .)
    COMMA           reduce using rule 63 (Scalar -> CHAR .)
    R_PAR           reduce using rule 63 (Scalar -> CHAR .)


state 51

    (64) Scalar -> INT .

    MULTIPLY        reduce using rule 64 (Scalar -> INT .)
    NAME            reduce using rule 64 (Scalar -> INT .)
    COMMA           reduce using rule 64 (Scalar -> INT .)
    R_PAR           reduce using rule 64 (Scalar -> INT .)


state 52

    (65) Scalar -> FLOAT .

    MULTIPLY        reduce using rule 65 (Scalar -> FLOAT .)
    NAME            reduce using rule 65 (Scalar -> FLOAT .)
    COMMA           reduce using rule 65 (Scalar -> FLOAT .)
    R_PAR           reduce using rule 65 (Scalar -> FLOAT .)


state 53

    (66) Scalar -> DOUBLE .

    MULTIPLY        reduce using rule 66 (Scalar -> DOUBLE .)
    NAME            reduce using rule 66 (Scalar -> DOUBLE .)
    COMMA           reduce using rule 66 (Scalar -> DOUBLE .)
    R_PAR           reduce using rule 66 (Scalar -> DOUBLE .)


state 54

    (67) Scalar -> VOID .

    MULTIPLY        reduce using rule 67 (Scalar -> VOID .)
    NAME            reduce using rule 67 (Scalar -> VOID .)
    COMMA           reduce using rule 67 (Scalar -> VOID .)
    R_PAR           reduce using rule 67 (Scalar -> VOID .)


state 55

    (13) Func_Decl -> Func_ID L_PAR Params . R_PAR Block
    (11) Func_Proto -> Func_ID L_PAR Params . R_PAR SEMICOLON

    R_PAR           shift and go to state 83


state 56

    (15) Func_Decl -> Func_ID L_PAR R_PAR . Block
    (12) Func_Proto -> Func_ID L_PAR R_PAR . SEMICOLON
    (103) Block -> . L_CURLY Stm_List R_CURLY

    SEMICOLON       shift and go to state 85
    L_CURLY         shift and go to state 86

    Block                          shift and go to state 84

state 57

    (14) Func_Decl -> Func_ID L_PAR Id_List . R_PAR Struct_Def Block

    R_PAR           shift and go to state 87


state 58

    (10) Func_Proto -> Func_ID L_PAR Types . R_PAR SEMICOLON

    R_PAR           shift and go to state 88


state 59

    (16) Params -> Param . COMMA Params
    (17) Params -> Param .

    COMMA           shift and go to state 89
    R_PAR           reduce using rule 17 (Params -> Param .)


state 60

    (22) Id_List -> NAME . COMMA Id_List
    (23) Id_List -> NAME .

    COMMA           shift and go to state 90
    R_PAR           reduce using rule 23 (Id_List -> NAME .)


state 61

    (20) Types -> Type . COMMA Types
    (21) Types -> Type .
    (19) Param -> Type . NAME

    COMMA           shift and go to state 91
    R_PAR           reduce using rule 21 (Types -> Type .)
    NAME            shift and go to state 92


state 62

    (18) Param -> CONST . Type NAME
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (174) empty -> .

    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)

    Type                           shift and go to state 93
    Base                           shift and go to state 25
    Sign                           shift and go to state 26
    empty                          shift and go to state 42

state 63

    (27) Struct_Decl -> STRUCT NAME L_CURLY . Struct_Def R_CURLY SEMICOLON
    (29) Struct_Def -> . Var_Decl Struct_Def
    (30) Struct_Def -> . Var_Decl
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (174) empty -> .

    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)

    Struct_Def                     shift and go to state 94
    Var_Decl                       shift and go to state 65
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Base                           shift and go to state 25
    Sign                           shift and go to state 26
    empty                          shift and go to state 42

state 64

    (56) Base -> STRUCT L_CURLY Struct_Def . R_CURLY

    R_CURLY         shift and go to state 95


state 65

    (29) Struct_Def -> Var_Decl . Struct_Def
    (30) Struct_Def -> Var_Decl .
    (29) Struct_Def -> . Var_Decl Struct_Def
    (30) Struct_Def -> . Var_Decl
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (174) empty -> .

    R_CURLY         reduce using rule 30 (Struct_Def -> Var_Decl .)
    L_CURLY         reduce using rule 30 (Struct_Def -> Var_Decl .)
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)

    Var_Decl                       shift and go to state 65
    Struct_Def                     shift and go to state 96
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Base                           shift and go to state 25
    Sign                           shift and go to state 26
    empty                          shift and go to state 42

state 66

    (32) Var_Decl -> Type . Var Var_List SEMICOLON
    (34) Var -> . NAME Array
    (35) Var -> . NAME Array ASSIGN Op_If

    NAME            shift and go to state 38

    Var                            shift and go to state 43

state 67

    (28) Union_Decl -> UNION NAME L_CURLY . Struct_Def R_CURLY SEMICOLON
    (29) Struct_Def -> . Var_Decl Struct_Def
    (30) Struct_Def -> . Var_Decl
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (174) empty -> .

    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)

    Struct_Def                     shift and go to state 97
    Var_Decl                       shift and go to state 65
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Base                           shift and go to state 25
    Sign                           shift and go to state 26
    empty                          shift and go to state 42

state 68

    (58) Base -> UNION L_CURLY Struct_Def . R_CURLY

    R_CURLY         shift and go to state 98


state 69

    (48) Enum_Decl -> ENUM NAME L_CURLY . Enum_Def R_CURLY SEMICOLON
    (49) Enum_Def -> . Enum_Val COMMA Enum_Def
    (50) Enum_Def -> . Enum_Val
    (51) Enum_Val -> . NAME
    (52) Enum_Val -> . NAME ASSIGN INTEGER

    NAME            shift and go to state 99

    Enum_Def                       shift and go to state 100
    Enum_Val                       shift and go to state 101

state 70

    (31) Var_Decl -> Mod Type Var . Var_List SEMICOLON
    (39) Var_List -> . COMMA Var_Item Var_List
    (40) Var_List -> . empty
    (174) empty -> .

    COMMA           shift and go to state 72
    SEMICOLON       reduce using rule 174 (empty -> .)

    Var_List                       shift and go to state 102
    empty                          shift and go to state 73

state 71

    (33) Var_Decl -> Mod Var Var_List . SEMICOLON

    SEMICOLON       shift and go to state 103


state 72

    (39) Var_List -> COMMA . Var_Item Var_List
    (41) Var_Item -> . Pointers Var
    (68) Pointers -> . MULTIPLY Pointers
    (69) Pointers -> . empty
    (174) empty -> .

    MULTIPLY        shift and go to state 47
    NAME            reduce using rule 174 (empty -> .)

    Var_Item                       shift and go to state 104
    Pointers                       shift and go to state 105
    empty                          shift and go to state 48

state 73

    (40) Var_List -> empty .

    SEMICOLON       reduce using rule 40 (Var_List -> empty .)


state 74

    (34) Var -> NAME Array .
    (35) Var -> NAME Array . ASSIGN Op_If

    COMMA           reduce using rule 34 (Var -> NAME Array .)
    SEMICOLON       reduce using rule 34 (Var -> NAME Array .)
    ASSIGN          shift and go to state 106


state 75

    (36) Array -> L_BRACKET . Expr R_BRACKET
    (37) Array -> L_BRACKET . R_BRACKET
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    R_BRACKET       shift and go to state 108
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Expr                           shift and go to state 107
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 76

    (38) Array -> empty .

    ASSIGN          reduce using rule 38 (Array -> empty .)
    COMMA           reduce using rule 38 (Array -> empty .)
    SEMICOLON       reduce using rule 38 (Array -> empty .)


state 77

    (55) Base -> STRUCT NAME .

    MULTIPLY        reduce using rule 55 (Base -> STRUCT NAME .)
    NAME            reduce using rule 55 (Base -> STRUCT NAME .)
    COMMA           reduce using rule 55 (Base -> STRUCT NAME .)
    R_PAR           reduce using rule 55 (Base -> STRUCT NAME .)


state 78

    (57) Base -> UNION NAME .

    MULTIPLY        reduce using rule 57 (Base -> UNION NAME .)
    NAME            reduce using rule 57 (Base -> UNION NAME .)
    COMMA           reduce using rule 57 (Base -> UNION NAME .)
    R_PAR           reduce using rule 57 (Base -> UNION NAME .)


state 79

    (59) Base -> ENUM NAME .

    MULTIPLY        reduce using rule 59 (Base -> ENUM NAME .)
    NAME            reduce using rule 59 (Base -> ENUM NAME .)
    COMMA           reduce using rule 59 (Base -> ENUM NAME .)
    R_PAR           reduce using rule 59 (Base -> ENUM NAME .)


state 80

    (32) Var_Decl -> Type Var Var_List . SEMICOLON

    SEMICOLON       shift and go to state 138


state 81

    (26) Typedef_Decl -> TYPEDEF Type NAME . SEMICOLON

    SEMICOLON       shift and go to state 139


state 82

    (68) Pointers -> MULTIPLY Pointers .

    NAME            reduce using rule 68 (Pointers -> MULTIPLY Pointers .)
    COMMA           reduce using rule 68 (Pointers -> MULTIPLY Pointers .)
    R_PAR           reduce using rule 68 (Pointers -> MULTIPLY Pointers .)


state 83

    (13) Func_Decl -> Func_ID L_PAR Params R_PAR . Block
    (11) Func_Proto -> Func_ID L_PAR Params R_PAR . SEMICOLON
    (103) Block -> . L_CURLY Stm_List R_CURLY

    SEMICOLON       shift and go to state 141
    L_CURLY         shift and go to state 86

    Block                          shift and go to state 140

state 84

    (15) Func_Decl -> Func_ID L_PAR R_PAR Block .

    STRUCT          reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    UNION           reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    ENUM            reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    TYPEDEF         reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    NAME            reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    EXTERN          reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    STATIC          reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    REGISTER        reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    AUTO            reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    VOLATILE        reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    CONST           reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    SIGNED          reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    UNSIGNED        reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    CHAR            reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    INT             reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    FLOAT           reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    DOUBLE          reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    VOID            reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)
    $end            reduce using rule 15 (Func_Decl -> Func_ID L_PAR R_PAR Block .)


state 85

    (12) Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .

    STRUCT          reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    UNION           reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    ENUM            reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    TYPEDEF         reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    EXTERN          reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    STATIC          reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    REGISTER        reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    AUTO            reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    VOLATILE        reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    CONST           reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    SIGNED          reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    UNSIGNED        reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    CHAR            reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    INT             reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    FLOAT           reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    DOUBLE          reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    VOID            reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 12 (Func_Proto -> Func_ID L_PAR R_PAR SEMICOLON .)


state 86

    (103) Block -> L_CURLY . Stm_List R_CURLY
    (104) Stm_List -> . Stm Stm_List
    (105) Stm_List -> . empty
    (70) Stm -> . PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
    (75) Stm -> . SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
    (78) Stm -> . Var_Decl
    (79) Stm -> . NAME COLON
    (80) Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> . IF L_PAR Expr R_PAR Stm
    (82) Stm -> . WHILE L_PAR Expr R_PAR Stm
    (83) Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (84) Stm -> . Normal_Stm
    (174) empty -> .
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (89) Normal_Stm -> . DO Stm WHILE L_PAR Expr R_PAR
    (90) Normal_Stm -> . SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
    (91) Normal_Stm -> . Block
    (92) Normal_Stm -> . Expr SEMICOLON
    (93) Normal_Stm -> . GOTO NAME SEMICOLON
    (94) Normal_Stm -> . BREAK SEMICOLON
    (95) Normal_Stm -> . CONTINUE SEMICOLON
    (96) Normal_Stm -> . RETURN Expr SEMICOLON
    (97) Normal_Stm -> . SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (103) Block -> . L_CURLY Stm_List R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    PRINTF          shift and go to state 145
    SCANF           shift and go to state 147
    NAME            shift and go to state 149
    IF              shift and go to state 150
    WHILE           shift and go to state 152
    FOR             shift and go to state 153
    R_CURLY         reduce using rule 174 (empty -> .)
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    DO              shift and go to state 155
    SWITCH          shift and go to state 156
    GOTO            shift and go to state 158
    BREAK           shift and go to state 159
    CONTINUE        shift and go to state 160
    RETURN          shift and go to state 161
    SEMICOLON       shift and go to state 146
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    L_CURLY         shift and go to state 86
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137

    Stm_List                       shift and go to state 142
    Stm                            shift and go to state 143
    empty                          shift and go to state 144
    Var_Decl                       shift and go to state 148
    Expr                           shift and go to state 151
    Normal_Stm                     shift and go to state 154
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Block                          shift and go to state 157
    Base                           shift and go to state 25
    Op_Assign                      shift and go to state 109
    Sign                           shift and go to state 26
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 87

    (14) Func_Decl -> Func_ID L_PAR Id_List R_PAR . Struct_Def Block
    (29) Struct_Def -> . Var_Decl Struct_Def
    (30) Struct_Def -> . Var_Decl
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (174) empty -> .

    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)

    Struct_Def                     shift and go to state 162
    Var_Decl                       shift and go to state 65
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Base                           shift and go to state 25
    Sign                           shift and go to state 26
    empty                          shift and go to state 42

state 88

    (10) Func_Proto -> Func_ID L_PAR Types R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 163


state 89

    (16) Params -> Param COMMA . Params
    (16) Params -> . Param COMMA Params
    (17) Params -> . Param
    (18) Param -> . CONST Type NAME
    (19) Param -> . Type NAME
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (174) empty -> .

    CONST           shift and go to state 62
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)

    Param                          shift and go to state 59
    Params                         shift and go to state 164
    Type                           shift and go to state 165
    Base                           shift and go to state 25
    Sign                           shift and go to state 26
    empty                          shift and go to state 42

state 90

    (22) Id_List -> NAME COMMA . Id_List
    (22) Id_List -> . NAME COMMA Id_List
    (23) Id_List -> . NAME

    NAME            shift and go to state 60

    Id_List                        shift and go to state 166

state 91

    (20) Types -> Type COMMA . Types
    (20) Types -> . Type COMMA Types
    (21) Types -> . Type
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (174) empty -> .

    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)

    Type                           shift and go to state 167
    Types                          shift and go to state 168
    Base                           shift and go to state 25
    Sign                           shift and go to state 26
    empty                          shift and go to state 42

state 92

    (19) Param -> Type NAME .

    COMMA           reduce using rule 19 (Param -> Type NAME .)
    R_PAR           reduce using rule 19 (Param -> Type NAME .)


state 93

    (18) Param -> CONST Type . NAME

    NAME            shift and go to state 169


state 94

    (27) Struct_Decl -> STRUCT NAME L_CURLY Struct_Def . R_CURLY SEMICOLON

    R_CURLY         shift and go to state 170


state 95

    (56) Base -> STRUCT L_CURLY Struct_Def R_CURLY .

    MULTIPLY        reduce using rule 56 (Base -> STRUCT L_CURLY Struct_Def R_CURLY .)
    NAME            reduce using rule 56 (Base -> STRUCT L_CURLY Struct_Def R_CURLY .)
    COMMA           reduce using rule 56 (Base -> STRUCT L_CURLY Struct_Def R_CURLY .)
    R_PAR           reduce using rule 56 (Base -> STRUCT L_CURLY Struct_Def R_CURLY .)


state 96

    (29) Struct_Def -> Var_Decl Struct_Def .

    R_CURLY         reduce using rule 29 (Struct_Def -> Var_Decl Struct_Def .)
    L_CURLY         reduce using rule 29 (Struct_Def -> Var_Decl Struct_Def .)


state 97

    (28) Union_Decl -> UNION NAME L_CURLY Struct_Def . R_CURLY SEMICOLON

    R_CURLY         shift and go to state 171


state 98

    (58) Base -> UNION L_CURLY Struct_Def R_CURLY .

    MULTIPLY        reduce using rule 58 (Base -> UNION L_CURLY Struct_Def R_CURLY .)
    NAME            reduce using rule 58 (Base -> UNION L_CURLY Struct_Def R_CURLY .)
    COMMA           reduce using rule 58 (Base -> UNION L_CURLY Struct_Def R_CURLY .)
    R_PAR           reduce using rule 58 (Base -> UNION L_CURLY Struct_Def R_CURLY .)


state 99

    (51) Enum_Val -> NAME .
    (52) Enum_Val -> NAME . ASSIGN INTEGER

    COMMA           reduce using rule 51 (Enum_Val -> NAME .)
    R_CURLY         reduce using rule 51 (Enum_Val -> NAME .)
    ASSIGN          shift and go to state 172


state 100

    (48) Enum_Decl -> ENUM NAME L_CURLY Enum_Def . R_CURLY SEMICOLON

    R_CURLY         shift and go to state 173


state 101

    (49) Enum_Def -> Enum_Val . COMMA Enum_Def
    (50) Enum_Def -> Enum_Val .

    COMMA           shift and go to state 174
    R_CURLY         reduce using rule 50 (Enum_Def -> Enum_Val .)


state 102

    (31) Var_Decl -> Mod Type Var Var_List . SEMICOLON

    SEMICOLON       shift and go to state 175


state 103

    (33) Var_Decl -> Mod Var Var_List SEMICOLON .

    STRUCT          reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    UNION           reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    ENUM            reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    TYPEDEF         reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    NAME            reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    EXTERN          reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    STATIC          reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    REGISTER        reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    AUTO            reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    VOLATILE        reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    CONST           reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    SIGNED          reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    UNSIGNED        reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    CHAR            reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    INT             reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    FLOAT           reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    DOUBLE          reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    VOID            reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    $end            reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    R_CURLY         reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    L_CURLY         reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    PRINTF          reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    SCANF           reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    IF              reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    WHILE           reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    FOR             reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    DO              reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    SWITCH          reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    GOTO            reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    BREAK           reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    CONTINUE        reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    RETURN          reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    SEMICOLON       reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    NOT             reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    NOT_B           reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    UMINUS          reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    MULTIPLY        reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    AND_B           reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    PLUSPLUS        reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    MINUSMINUS      reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    L_PAR           reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    SIZEOF          reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    INTEGER         reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    STRING          reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    CHARACTER       reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    DECIMAL         reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    CASE            reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)
    DEFAULT         reduce using rule 33 (Var_Decl -> Mod Var Var_List SEMICOLON .)


state 104

    (39) Var_List -> COMMA Var_Item . Var_List
    (39) Var_List -> . COMMA Var_Item Var_List
    (40) Var_List -> . empty
    (174) empty -> .

    COMMA           shift and go to state 72
    SEMICOLON       reduce using rule 174 (empty -> .)

    Var_List                       shift and go to state 176
    empty                          shift and go to state 73

state 105

    (41) Var_Item -> Pointers . Var
    (34) Var -> . NAME Array
    (35) Var -> . NAME Array ASSIGN Op_If

    NAME            shift and go to state 38

    Var                            shift and go to state 177

state 106

    (35) Var -> NAME Array ASSIGN . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_If                          shift and go to state 178
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 107

    (36) Array -> L_BRACKET Expr . R_BRACKET
    (106) Expr -> Expr . COMMA Op_Assign

    R_BRACKET       shift and go to state 179
    COMMA           shift and go to state 180


state 108

    (37) Array -> L_BRACKET R_BRACKET .

    ASSIGN          reduce using rule 37 (Array -> L_BRACKET R_BRACKET .)
    COMMA           reduce using rule 37 (Array -> L_BRACKET R_BRACKET .)
    SEMICOLON       reduce using rule 37 (Array -> L_BRACKET R_BRACKET .)


state 109

    (107) Expr -> Op_Assign .

    R_BRACKET       reduce using rule 107 (Expr -> Op_Assign .)
    COMMA           reduce using rule 107 (Expr -> Op_Assign .)
    SEMICOLON       reduce using rule 107 (Expr -> Op_Assign .)
    R_PAR           reduce using rule 107 (Expr -> Op_Assign .)


state 110

    (108) Op_Assign -> Op_If . ASSIGN Op_Assign
    (109) Op_Assign -> Op_If . APLUS Op_Assign
    (110) Op_Assign -> Op_If . AMINUS Op_Assign
    (111) Op_Assign -> Op_If . AMULTIPLY Op_Assign
    (112) Op_Assign -> Op_If . ADIVIDE Op_Assign
    (113) Op_Assign -> Op_If . AXOR Op_Assign
    (114) Op_Assign -> Op_If . AAND Op_Assign
    (115) Op_Assign -> Op_If . AOR Op_Assign
    (116) Op_Assign -> Op_If . ASHIFT_R Op_Assign
    (117) Op_Assign -> Op_If . ASHIFT_L Op_Assign
    (118) Op_Assign -> Op_If .

    ASSIGN          shift and go to state 181
    APLUS           shift and go to state 182
    AMINUS          shift and go to state 183
    AMULTIPLY       shift and go to state 184
    ADIVIDE         shift and go to state 185
    AXOR            shift and go to state 186
    AAND            shift and go to state 187
    AOR             shift and go to state 188
    ASHIFT_R        shift and go to state 189
    ASHIFT_L        shift and go to state 190
    R_BRACKET       reduce using rule 118 (Op_Assign -> Op_If .)
    COMMA           reduce using rule 118 (Op_Assign -> Op_If .)
    SEMICOLON       reduce using rule 118 (Op_Assign -> Op_If .)
    R_PAR           reduce using rule 118 (Op_Assign -> Op_If .)


state 111

    (119) Op_If -> Op_Or . QUESTION Op_If COLON Op_If
    (120) Op_If -> Op_Or .
    (121) Op_Or -> Op_Or . OR Op_And

    QUESTION        shift and go to state 191
    ASSIGN          reduce using rule 120 (Op_If -> Op_Or .)
    APLUS           reduce using rule 120 (Op_If -> Op_Or .)
    AMINUS          reduce using rule 120 (Op_If -> Op_Or .)
    AMULTIPLY       reduce using rule 120 (Op_If -> Op_Or .)
    ADIVIDE         reduce using rule 120 (Op_If -> Op_Or .)
    AXOR            reduce using rule 120 (Op_If -> Op_Or .)
    AAND            reduce using rule 120 (Op_If -> Op_Or .)
    AOR             reduce using rule 120 (Op_If -> Op_Or .)
    ASHIFT_R        reduce using rule 120 (Op_If -> Op_Or .)
    ASHIFT_L        reduce using rule 120 (Op_If -> Op_Or .)
    R_BRACKET       reduce using rule 120 (Op_If -> Op_Or .)
    COMMA           reduce using rule 120 (Op_If -> Op_Or .)
    SEMICOLON       reduce using rule 120 (Op_If -> Op_Or .)
    R_PAR           reduce using rule 120 (Op_If -> Op_Or .)
    COLON           reduce using rule 120 (Op_If -> Op_Or .)
    OR              shift and go to state 192


state 112

    (122) Op_Or -> Op_And .
    (123) Op_And -> Op_And . AND Op_BinOR

    QUESTION        reduce using rule 122 (Op_Or -> Op_And .)
    OR              reduce using rule 122 (Op_Or -> Op_And .)
    ASSIGN          reduce using rule 122 (Op_Or -> Op_And .)
    APLUS           reduce using rule 122 (Op_Or -> Op_And .)
    AMINUS          reduce using rule 122 (Op_Or -> Op_And .)
    AMULTIPLY       reduce using rule 122 (Op_Or -> Op_And .)
    ADIVIDE         reduce using rule 122 (Op_Or -> Op_And .)
    AXOR            reduce using rule 122 (Op_Or -> Op_And .)
    AAND            reduce using rule 122 (Op_Or -> Op_And .)
    AOR             reduce using rule 122 (Op_Or -> Op_And .)
    ASHIFT_R        reduce using rule 122 (Op_Or -> Op_And .)
    ASHIFT_L        reduce using rule 122 (Op_Or -> Op_And .)
    R_BRACKET       reduce using rule 122 (Op_Or -> Op_And .)
    COMMA           reduce using rule 122 (Op_Or -> Op_And .)
    SEMICOLON       reduce using rule 122 (Op_Or -> Op_And .)
    R_PAR           reduce using rule 122 (Op_Or -> Op_And .)
    COLON           reduce using rule 122 (Op_Or -> Op_And .)
    AND             shift and go to state 193


state 113

    (124) Op_And -> Op_BinOR .
    (125) Op_BinOR -> Op_BinOR . OR_B Op_BinXOR

    AND             reduce using rule 124 (Op_And -> Op_BinOR .)
    QUESTION        reduce using rule 124 (Op_And -> Op_BinOR .)
    OR              reduce using rule 124 (Op_And -> Op_BinOR .)
    ASSIGN          reduce using rule 124 (Op_And -> Op_BinOR .)
    APLUS           reduce using rule 124 (Op_And -> Op_BinOR .)
    AMINUS          reduce using rule 124 (Op_And -> Op_BinOR .)
    AMULTIPLY       reduce using rule 124 (Op_And -> Op_BinOR .)
    ADIVIDE         reduce using rule 124 (Op_And -> Op_BinOR .)
    AXOR            reduce using rule 124 (Op_And -> Op_BinOR .)
    AAND            reduce using rule 124 (Op_And -> Op_BinOR .)
    AOR             reduce using rule 124 (Op_And -> Op_BinOR .)
    ASHIFT_R        reduce using rule 124 (Op_And -> Op_BinOR .)
    ASHIFT_L        reduce using rule 124 (Op_And -> Op_BinOR .)
    R_BRACKET       reduce using rule 124 (Op_And -> Op_BinOR .)
    COMMA           reduce using rule 124 (Op_And -> Op_BinOR .)
    SEMICOLON       reduce using rule 124 (Op_And -> Op_BinOR .)
    R_PAR           reduce using rule 124 (Op_And -> Op_BinOR .)
    COLON           reduce using rule 124 (Op_And -> Op_BinOR .)
    OR_B            shift and go to state 194


state 114

    (126) Op_BinOR -> Op_BinXOR .
    (127) Op_BinXOR -> Op_BinXOR . XOR_B Op_BinAND

    OR_B            reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    AND             reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    QUESTION        reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    OR              reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    ASSIGN          reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    APLUS           reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    AMINUS          reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    AMULTIPLY       reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    ADIVIDE         reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    AXOR            reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    AAND            reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    AOR             reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    ASHIFT_R        reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    ASHIFT_L        reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    R_BRACKET       reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    COMMA           reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    SEMICOLON       reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    R_PAR           reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    COLON           reduce using rule 126 (Op_BinOR -> Op_BinXOR .)
    XOR_B           shift and go to state 195


state 115

    (128) Op_BinXOR -> Op_BinAND .
    (129) Op_BinAND -> Op_BinAND . AND_B Op_Equate

    XOR_B           reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    OR_B            reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    AND             reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    QUESTION        reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    OR              reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    ASSIGN          reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    APLUS           reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    AMINUS          reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    AMULTIPLY       reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    ADIVIDE         reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    AXOR            reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    AAND            reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    AOR             reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    ASHIFT_R        reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    ASHIFT_L        reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    R_BRACKET       reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    COMMA           reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    SEMICOLON       reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    R_PAR           reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    COLON           reduce using rule 128 (Op_BinXOR -> Op_BinAND .)
    AND_B           shift and go to state 196


state 116

    (153) Op_Unary -> AND_B . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Unary                       shift and go to state 197
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 117

    (130) Op_BinAND -> Op_Equate .
    (131) Op_Equate -> Op_Equate . EQUAL Op_Compare
    (132) Op_Equate -> Op_Equate . NOT_EQUAL Op_Compare

    AND_B           reduce using rule 130 (Op_BinAND -> Op_Equate .)
    XOR_B           reduce using rule 130 (Op_BinAND -> Op_Equate .)
    OR_B            reduce using rule 130 (Op_BinAND -> Op_Equate .)
    AND             reduce using rule 130 (Op_BinAND -> Op_Equate .)
    QUESTION        reduce using rule 130 (Op_BinAND -> Op_Equate .)
    OR              reduce using rule 130 (Op_BinAND -> Op_Equate .)
    ASSIGN          reduce using rule 130 (Op_BinAND -> Op_Equate .)
    APLUS           reduce using rule 130 (Op_BinAND -> Op_Equate .)
    AMINUS          reduce using rule 130 (Op_BinAND -> Op_Equate .)
    AMULTIPLY       reduce using rule 130 (Op_BinAND -> Op_Equate .)
    ADIVIDE         reduce using rule 130 (Op_BinAND -> Op_Equate .)
    AXOR            reduce using rule 130 (Op_BinAND -> Op_Equate .)
    AAND            reduce using rule 130 (Op_BinAND -> Op_Equate .)
    AOR             reduce using rule 130 (Op_BinAND -> Op_Equate .)
    ASHIFT_R        reduce using rule 130 (Op_BinAND -> Op_Equate .)
    ASHIFT_L        reduce using rule 130 (Op_BinAND -> Op_Equate .)
    R_BRACKET       reduce using rule 130 (Op_BinAND -> Op_Equate .)
    COMMA           reduce using rule 130 (Op_BinAND -> Op_Equate .)
    SEMICOLON       reduce using rule 130 (Op_BinAND -> Op_Equate .)
    R_PAR           reduce using rule 130 (Op_BinAND -> Op_Equate .)
    COLON           reduce using rule 130 (Op_BinAND -> Op_Equate .)
    EQUAL           shift and go to state 198
    NOT_EQUAL       shift and go to state 199


state 118

    (133) Op_Equate -> Op_Compare .
    (134) Op_Compare -> Op_Compare . LESS Op_Shift
    (135) Op_Compare -> Op_Compare . GREATER Op_Shift
    (136) Op_Compare -> Op_Compare . LESS_EQUAL Op_Shift
    (137) Op_Compare -> Op_Compare . GREATER_EQUAL Op_Shift

    EQUAL           reduce using rule 133 (Op_Equate -> Op_Compare .)
    NOT_EQUAL       reduce using rule 133 (Op_Equate -> Op_Compare .)
    AND_B           reduce using rule 133 (Op_Equate -> Op_Compare .)
    XOR_B           reduce using rule 133 (Op_Equate -> Op_Compare .)
    OR_B            reduce using rule 133 (Op_Equate -> Op_Compare .)
    AND             reduce using rule 133 (Op_Equate -> Op_Compare .)
    QUESTION        reduce using rule 133 (Op_Equate -> Op_Compare .)
    OR              reduce using rule 133 (Op_Equate -> Op_Compare .)
    ASSIGN          reduce using rule 133 (Op_Equate -> Op_Compare .)
    APLUS           reduce using rule 133 (Op_Equate -> Op_Compare .)
    AMINUS          reduce using rule 133 (Op_Equate -> Op_Compare .)
    AMULTIPLY       reduce using rule 133 (Op_Equate -> Op_Compare .)
    ADIVIDE         reduce using rule 133 (Op_Equate -> Op_Compare .)
    AXOR            reduce using rule 133 (Op_Equate -> Op_Compare .)
    AAND            reduce using rule 133 (Op_Equate -> Op_Compare .)
    AOR             reduce using rule 133 (Op_Equate -> Op_Compare .)
    ASHIFT_R        reduce using rule 133 (Op_Equate -> Op_Compare .)
    ASHIFT_L        reduce using rule 133 (Op_Equate -> Op_Compare .)
    R_BRACKET       reduce using rule 133 (Op_Equate -> Op_Compare .)
    COMMA           reduce using rule 133 (Op_Equate -> Op_Compare .)
    SEMICOLON       reduce using rule 133 (Op_Equate -> Op_Compare .)
    R_PAR           reduce using rule 133 (Op_Equate -> Op_Compare .)
    COLON           reduce using rule 133 (Op_Equate -> Op_Compare .)
    LESS            shift and go to state 200
    GREATER         shift and go to state 201
    LESS_EQUAL      shift and go to state 202
    GREATER_EQUAL   shift and go to state 203


state 119

    (138) Op_Compare -> Op_Shift .
    (139) Op_Shift -> Op_Shift . SHIFT_L Op_Add
    (140) Op_Shift -> Op_Shift . SHIFT_R Op_Add

    LESS            reduce using rule 138 (Op_Compare -> Op_Shift .)
    GREATER         reduce using rule 138 (Op_Compare -> Op_Shift .)
    LESS_EQUAL      reduce using rule 138 (Op_Compare -> Op_Shift .)
    GREATER_EQUAL   reduce using rule 138 (Op_Compare -> Op_Shift .)
    EQUAL           reduce using rule 138 (Op_Compare -> Op_Shift .)
    NOT_EQUAL       reduce using rule 138 (Op_Compare -> Op_Shift .)
    AND_B           reduce using rule 138 (Op_Compare -> Op_Shift .)
    XOR_B           reduce using rule 138 (Op_Compare -> Op_Shift .)
    OR_B            reduce using rule 138 (Op_Compare -> Op_Shift .)
    AND             reduce using rule 138 (Op_Compare -> Op_Shift .)
    QUESTION        reduce using rule 138 (Op_Compare -> Op_Shift .)
    OR              reduce using rule 138 (Op_Compare -> Op_Shift .)
    ASSIGN          reduce using rule 138 (Op_Compare -> Op_Shift .)
    APLUS           reduce using rule 138 (Op_Compare -> Op_Shift .)
    AMINUS          reduce using rule 138 (Op_Compare -> Op_Shift .)
    AMULTIPLY       reduce using rule 138 (Op_Compare -> Op_Shift .)
    ADIVIDE         reduce using rule 138 (Op_Compare -> Op_Shift .)
    AXOR            reduce using rule 138 (Op_Compare -> Op_Shift .)
    AAND            reduce using rule 138 (Op_Compare -> Op_Shift .)
    AOR             reduce using rule 138 (Op_Compare -> Op_Shift .)
    ASHIFT_R        reduce using rule 138 (Op_Compare -> Op_Shift .)
    ASHIFT_L        reduce using rule 138 (Op_Compare -> Op_Shift .)
    R_BRACKET       reduce using rule 138 (Op_Compare -> Op_Shift .)
    COMMA           reduce using rule 138 (Op_Compare -> Op_Shift .)
    SEMICOLON       reduce using rule 138 (Op_Compare -> Op_Shift .)
    R_PAR           reduce using rule 138 (Op_Compare -> Op_Shift .)
    COLON           reduce using rule 138 (Op_Compare -> Op_Shift .)
    SHIFT_L         shift and go to state 204
    SHIFT_R         shift and go to state 205


state 120

    (141) Op_Shift -> Op_Add .
    (142) Op_Add -> Op_Add . PLUS Op_Mult
    (143) Op_Add -> Op_Add . MINUS Op_Mult

    SHIFT_L         reduce using rule 141 (Op_Shift -> Op_Add .)
    SHIFT_R         reduce using rule 141 (Op_Shift -> Op_Add .)
    LESS            reduce using rule 141 (Op_Shift -> Op_Add .)
    GREATER         reduce using rule 141 (Op_Shift -> Op_Add .)
    LESS_EQUAL      reduce using rule 141 (Op_Shift -> Op_Add .)
    GREATER_EQUAL   reduce using rule 141 (Op_Shift -> Op_Add .)
    EQUAL           reduce using rule 141 (Op_Shift -> Op_Add .)
    NOT_EQUAL       reduce using rule 141 (Op_Shift -> Op_Add .)
    AND_B           reduce using rule 141 (Op_Shift -> Op_Add .)
    XOR_B           reduce using rule 141 (Op_Shift -> Op_Add .)
    OR_B            reduce using rule 141 (Op_Shift -> Op_Add .)
    AND             reduce using rule 141 (Op_Shift -> Op_Add .)
    QUESTION        reduce using rule 141 (Op_Shift -> Op_Add .)
    OR              reduce using rule 141 (Op_Shift -> Op_Add .)
    ASSIGN          reduce using rule 141 (Op_Shift -> Op_Add .)
    APLUS           reduce using rule 141 (Op_Shift -> Op_Add .)
    AMINUS          reduce using rule 141 (Op_Shift -> Op_Add .)
    AMULTIPLY       reduce using rule 141 (Op_Shift -> Op_Add .)
    ADIVIDE         reduce using rule 141 (Op_Shift -> Op_Add .)
    AXOR            reduce using rule 141 (Op_Shift -> Op_Add .)
    AAND            reduce using rule 141 (Op_Shift -> Op_Add .)
    AOR             reduce using rule 141 (Op_Shift -> Op_Add .)
    ASHIFT_R        reduce using rule 141 (Op_Shift -> Op_Add .)
    ASHIFT_L        reduce using rule 141 (Op_Shift -> Op_Add .)
    R_BRACKET       reduce using rule 141 (Op_Shift -> Op_Add .)
    COMMA           reduce using rule 141 (Op_Shift -> Op_Add .)
    SEMICOLON       reduce using rule 141 (Op_Shift -> Op_Add .)
    R_PAR           reduce using rule 141 (Op_Shift -> Op_Add .)
    COLON           reduce using rule 141 (Op_Shift -> Op_Add .)
    PLUS            shift and go to state 206
    MINUS           shift and go to state 207


state 121

    (144) Op_Add -> Op_Mult .
    (145) Op_Mult -> Op_Mult . MULTIPLY Op_Unary
    (146) Op_Mult -> Op_Mult . DIVIDE Op_Unary
    (147) Op_Mult -> Op_Mult . REMAINDER Op_Unary

    PLUS            reduce using rule 144 (Op_Add -> Op_Mult .)
    MINUS           reduce using rule 144 (Op_Add -> Op_Mult .)
    SHIFT_L         reduce using rule 144 (Op_Add -> Op_Mult .)
    SHIFT_R         reduce using rule 144 (Op_Add -> Op_Mult .)
    LESS            reduce using rule 144 (Op_Add -> Op_Mult .)
    GREATER         reduce using rule 144 (Op_Add -> Op_Mult .)
    LESS_EQUAL      reduce using rule 144 (Op_Add -> Op_Mult .)
    GREATER_EQUAL   reduce using rule 144 (Op_Add -> Op_Mult .)
    EQUAL           reduce using rule 144 (Op_Add -> Op_Mult .)
    NOT_EQUAL       reduce using rule 144 (Op_Add -> Op_Mult .)
    AND_B           reduce using rule 144 (Op_Add -> Op_Mult .)
    XOR_B           reduce using rule 144 (Op_Add -> Op_Mult .)
    OR_B            reduce using rule 144 (Op_Add -> Op_Mult .)
    AND             reduce using rule 144 (Op_Add -> Op_Mult .)
    QUESTION        reduce using rule 144 (Op_Add -> Op_Mult .)
    OR              reduce using rule 144 (Op_Add -> Op_Mult .)
    ASSIGN          reduce using rule 144 (Op_Add -> Op_Mult .)
    APLUS           reduce using rule 144 (Op_Add -> Op_Mult .)
    AMINUS          reduce using rule 144 (Op_Add -> Op_Mult .)
    AMULTIPLY       reduce using rule 144 (Op_Add -> Op_Mult .)
    ADIVIDE         reduce using rule 144 (Op_Add -> Op_Mult .)
    AXOR            reduce using rule 144 (Op_Add -> Op_Mult .)
    AAND            reduce using rule 144 (Op_Add -> Op_Mult .)
    AOR             reduce using rule 144 (Op_Add -> Op_Mult .)
    ASHIFT_R        reduce using rule 144 (Op_Add -> Op_Mult .)
    ASHIFT_L        reduce using rule 144 (Op_Add -> Op_Mult .)
    R_BRACKET       reduce using rule 144 (Op_Add -> Op_Mult .)
    COMMA           reduce using rule 144 (Op_Add -> Op_Mult .)
    SEMICOLON       reduce using rule 144 (Op_Add -> Op_Mult .)
    R_PAR           reduce using rule 144 (Op_Add -> Op_Mult .)
    COLON           reduce using rule 144 (Op_Add -> Op_Mult .)
    MULTIPLY        shift and go to state 208
    DIVIDE          shift and go to state 209
    REMAINDER       shift and go to state 210


state 122

    (152) Op_Unary -> MULTIPLY . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Unary                       shift and go to state 211
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 123

    (148) Op_Mult -> Op_Unary .

    MULTIPLY        reduce using rule 148 (Op_Mult -> Op_Unary .)
    DIVIDE          reduce using rule 148 (Op_Mult -> Op_Unary .)
    REMAINDER       reduce using rule 148 (Op_Mult -> Op_Unary .)
    PLUS            reduce using rule 148 (Op_Mult -> Op_Unary .)
    MINUS           reduce using rule 148 (Op_Mult -> Op_Unary .)
    SHIFT_L         reduce using rule 148 (Op_Mult -> Op_Unary .)
    SHIFT_R         reduce using rule 148 (Op_Mult -> Op_Unary .)
    LESS            reduce using rule 148 (Op_Mult -> Op_Unary .)
    GREATER         reduce using rule 148 (Op_Mult -> Op_Unary .)
    LESS_EQUAL      reduce using rule 148 (Op_Mult -> Op_Unary .)
    GREATER_EQUAL   reduce using rule 148 (Op_Mult -> Op_Unary .)
    EQUAL           reduce using rule 148 (Op_Mult -> Op_Unary .)
    NOT_EQUAL       reduce using rule 148 (Op_Mult -> Op_Unary .)
    AND_B           reduce using rule 148 (Op_Mult -> Op_Unary .)
    XOR_B           reduce using rule 148 (Op_Mult -> Op_Unary .)
    OR_B            reduce using rule 148 (Op_Mult -> Op_Unary .)
    AND             reduce using rule 148 (Op_Mult -> Op_Unary .)
    QUESTION        reduce using rule 148 (Op_Mult -> Op_Unary .)
    OR              reduce using rule 148 (Op_Mult -> Op_Unary .)
    ASSIGN          reduce using rule 148 (Op_Mult -> Op_Unary .)
    APLUS           reduce using rule 148 (Op_Mult -> Op_Unary .)
    AMINUS          reduce using rule 148 (Op_Mult -> Op_Unary .)
    AMULTIPLY       reduce using rule 148 (Op_Mult -> Op_Unary .)
    ADIVIDE         reduce using rule 148 (Op_Mult -> Op_Unary .)
    AXOR            reduce using rule 148 (Op_Mult -> Op_Unary .)
    AAND            reduce using rule 148 (Op_Mult -> Op_Unary .)
    AOR             reduce using rule 148 (Op_Mult -> Op_Unary .)
    ASHIFT_R        reduce using rule 148 (Op_Mult -> Op_Unary .)
    ASHIFT_L        reduce using rule 148 (Op_Mult -> Op_Unary .)
    R_BRACKET       reduce using rule 148 (Op_Mult -> Op_Unary .)
    COMMA           reduce using rule 148 (Op_Mult -> Op_Unary .)
    SEMICOLON       reduce using rule 148 (Op_Mult -> Op_Unary .)
    R_PAR           reduce using rule 148 (Op_Mult -> Op_Unary .)
    COLON           reduce using rule 148 (Op_Mult -> Op_Unary .)


state 124

    (149) Op_Unary -> NOT . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Unary                       shift and go to state 212
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 125

    (150) Op_Unary -> NOT_B . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Unary                       shift and go to state 213
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 126

    (151) Op_Unary -> UMINUS . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Unary                       shift and go to state 214
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 127

    (154) Op_Unary -> PLUSPLUS . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Unary                       shift and go to state 215
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 128

    (155) Op_Unary -> MINUSMINUS . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Unary                       shift and go to state 216
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 129

    (156) Op_Unary -> Op_Pointer . PLUSPLUS
    (157) Op_Unary -> Op_Pointer . MINUSMINUS
    (161) Op_Unary -> Op_Pointer .
    (162) Op_Pointer -> Op_Pointer . DOT Value
    (163) Op_Pointer -> Op_Pointer . ACCESS Value
    (164) Op_Pointer -> Op_Pointer . L_BRACKET Expr R_BRACKET

    PLUSPLUS        shift and go to state 217
    MINUSMINUS      shift and go to state 218
    MULTIPLY        reduce using rule 161 (Op_Unary -> Op_Pointer .)
    DIVIDE          reduce using rule 161 (Op_Unary -> Op_Pointer .)
    REMAINDER       reduce using rule 161 (Op_Unary -> Op_Pointer .)
    PLUS            reduce using rule 161 (Op_Unary -> Op_Pointer .)
    MINUS           reduce using rule 161 (Op_Unary -> Op_Pointer .)
    SHIFT_L         reduce using rule 161 (Op_Unary -> Op_Pointer .)
    SHIFT_R         reduce using rule 161 (Op_Unary -> Op_Pointer .)
    LESS            reduce using rule 161 (Op_Unary -> Op_Pointer .)
    GREATER         reduce using rule 161 (Op_Unary -> Op_Pointer .)
    LESS_EQUAL      reduce using rule 161 (Op_Unary -> Op_Pointer .)
    GREATER_EQUAL   reduce using rule 161 (Op_Unary -> Op_Pointer .)
    EQUAL           reduce using rule 161 (Op_Unary -> Op_Pointer .)
    NOT_EQUAL       reduce using rule 161 (Op_Unary -> Op_Pointer .)
    AND_B           reduce using rule 161 (Op_Unary -> Op_Pointer .)
    XOR_B           reduce using rule 161 (Op_Unary -> Op_Pointer .)
    OR_B            reduce using rule 161 (Op_Unary -> Op_Pointer .)
    AND             reduce using rule 161 (Op_Unary -> Op_Pointer .)
    QUESTION        reduce using rule 161 (Op_Unary -> Op_Pointer .)
    OR              reduce using rule 161 (Op_Unary -> Op_Pointer .)
    ASSIGN          reduce using rule 161 (Op_Unary -> Op_Pointer .)
    APLUS           reduce using rule 161 (Op_Unary -> Op_Pointer .)
    AMINUS          reduce using rule 161 (Op_Unary -> Op_Pointer .)
    AMULTIPLY       reduce using rule 161 (Op_Unary -> Op_Pointer .)
    ADIVIDE         reduce using rule 161 (Op_Unary -> Op_Pointer .)
    AXOR            reduce using rule 161 (Op_Unary -> Op_Pointer .)
    AAND            reduce using rule 161 (Op_Unary -> Op_Pointer .)
    AOR             reduce using rule 161 (Op_Unary -> Op_Pointer .)
    ASHIFT_R        reduce using rule 161 (Op_Unary -> Op_Pointer .)
    ASHIFT_L        reduce using rule 161 (Op_Unary -> Op_Pointer .)
    R_BRACKET       reduce using rule 161 (Op_Unary -> Op_Pointer .)
    COMMA           reduce using rule 161 (Op_Unary -> Op_Pointer .)
    SEMICOLON       reduce using rule 161 (Op_Unary -> Op_Pointer .)
    R_PAR           reduce using rule 161 (Op_Unary -> Op_Pointer .)
    COLON           reduce using rule 161 (Op_Unary -> Op_Pointer .)
    DOT             shift and go to state 219
    ACCESS          shift and go to state 220
    L_BRACKET       shift and go to state 221


state 130

    (158) Op_Unary -> L_PAR . Type R_PAR Op_Unary
    (173) Value -> L_PAR . Expr R_PAR
    (53) Type -> . Base Pointers
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (174) empty -> .
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Type                           shift and go to state 222
    Op_Unary                       shift and go to state 123
    Expr                           shift and go to state 223
    Base                           shift and go to state 25
    Op_Assign                      shift and go to state 109
    Sign                           shift and go to state 26
    Op_If                          shift and go to state 110
    empty                          shift and go to state 42
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 131

    (159) Op_Unary -> SIZEOF . L_PAR Type R_PAR
    (160) Op_Unary -> SIZEOF . L_PAR NAME Pointers R_PAR

    L_PAR           shift and go to state 224


state 132

    (170) Value -> NAME .
    (171) Value -> NAME . L_PAR Expr R_PAR
    (172) Value -> NAME . L_PAR R_PAR

  ! shift/reduce conflict for L_PAR resolved as shift
    PLUSPLUS        reduce using rule 170 (Value -> NAME .)
    MINUSMINUS      reduce using rule 170 (Value -> NAME .)
    DOT             reduce using rule 170 (Value -> NAME .)
    ACCESS          reduce using rule 170 (Value -> NAME .)
    L_BRACKET       reduce using rule 170 (Value -> NAME .)
    MULTIPLY        reduce using rule 170 (Value -> NAME .)
    DIVIDE          reduce using rule 170 (Value -> NAME .)
    REMAINDER       reduce using rule 170 (Value -> NAME .)
    PLUS            reduce using rule 170 (Value -> NAME .)
    MINUS           reduce using rule 170 (Value -> NAME .)
    SHIFT_L         reduce using rule 170 (Value -> NAME .)
    SHIFT_R         reduce using rule 170 (Value -> NAME .)
    LESS            reduce using rule 170 (Value -> NAME .)
    GREATER         reduce using rule 170 (Value -> NAME .)
    LESS_EQUAL      reduce using rule 170 (Value -> NAME .)
    GREATER_EQUAL   reduce using rule 170 (Value -> NAME .)
    EQUAL           reduce using rule 170 (Value -> NAME .)
    NOT_EQUAL       reduce using rule 170 (Value -> NAME .)
    AND_B           reduce using rule 170 (Value -> NAME .)
    XOR_B           reduce using rule 170 (Value -> NAME .)
    OR_B            reduce using rule 170 (Value -> NAME .)
    AND             reduce using rule 170 (Value -> NAME .)
    QUESTION        reduce using rule 170 (Value -> NAME .)
    OR              reduce using rule 170 (Value -> NAME .)
    ASSIGN          reduce using rule 170 (Value -> NAME .)
    APLUS           reduce using rule 170 (Value -> NAME .)
    AMINUS          reduce using rule 170 (Value -> NAME .)
    AMULTIPLY       reduce using rule 170 (Value -> NAME .)
    ADIVIDE         reduce using rule 170 (Value -> NAME .)
    AXOR            reduce using rule 170 (Value -> NAME .)
    AAND            reduce using rule 170 (Value -> NAME .)
    AOR             reduce using rule 170 (Value -> NAME .)
    ASHIFT_R        reduce using rule 170 (Value -> NAME .)
    ASHIFT_L        reduce using rule 170 (Value -> NAME .)
    R_BRACKET       reduce using rule 170 (Value -> NAME .)
    COMMA           reduce using rule 170 (Value -> NAME .)
    SEMICOLON       reduce using rule 170 (Value -> NAME .)
    R_PAR           reduce using rule 170 (Value -> NAME .)
    COLON           reduce using rule 170 (Value -> NAME .)
    INTEGER         reduce using rule 170 (Value -> NAME .)
    STRING          reduce using rule 170 (Value -> NAME .)
    CHARACTER       reduce using rule 170 (Value -> NAME .)
    DECIMAL         reduce using rule 170 (Value -> NAME .)
    NAME            reduce using rule 170 (Value -> NAME .)
    L_PAR           shift and go to state 225

  ! L_PAR           [ reduce using rule 170 (Value -> NAME .) ]


state 133

    (165) Op_Pointer -> Value .

    PLUSPLUS        reduce using rule 165 (Op_Pointer -> Value .)
    MINUSMINUS      reduce using rule 165 (Op_Pointer -> Value .)
    DOT             reduce using rule 165 (Op_Pointer -> Value .)
    ACCESS          reduce using rule 165 (Op_Pointer -> Value .)
    L_BRACKET       reduce using rule 165 (Op_Pointer -> Value .)
    MULTIPLY        reduce using rule 165 (Op_Pointer -> Value .)
    DIVIDE          reduce using rule 165 (Op_Pointer -> Value .)
    REMAINDER       reduce using rule 165 (Op_Pointer -> Value .)
    PLUS            reduce using rule 165 (Op_Pointer -> Value .)
    MINUS           reduce using rule 165 (Op_Pointer -> Value .)
    SHIFT_L         reduce using rule 165 (Op_Pointer -> Value .)
    SHIFT_R         reduce using rule 165 (Op_Pointer -> Value .)
    LESS            reduce using rule 165 (Op_Pointer -> Value .)
    GREATER         reduce using rule 165 (Op_Pointer -> Value .)
    LESS_EQUAL      reduce using rule 165 (Op_Pointer -> Value .)
    GREATER_EQUAL   reduce using rule 165 (Op_Pointer -> Value .)
    EQUAL           reduce using rule 165 (Op_Pointer -> Value .)
    NOT_EQUAL       reduce using rule 165 (Op_Pointer -> Value .)
    AND_B           reduce using rule 165 (Op_Pointer -> Value .)
    XOR_B           reduce using rule 165 (Op_Pointer -> Value .)
    OR_B            reduce using rule 165 (Op_Pointer -> Value .)
    AND             reduce using rule 165 (Op_Pointer -> Value .)
    QUESTION        reduce using rule 165 (Op_Pointer -> Value .)
    OR              reduce using rule 165 (Op_Pointer -> Value .)
    ASSIGN          reduce using rule 165 (Op_Pointer -> Value .)
    APLUS           reduce using rule 165 (Op_Pointer -> Value .)
    AMINUS          reduce using rule 165 (Op_Pointer -> Value .)
    AMULTIPLY       reduce using rule 165 (Op_Pointer -> Value .)
    ADIVIDE         reduce using rule 165 (Op_Pointer -> Value .)
    AXOR            reduce using rule 165 (Op_Pointer -> Value .)
    AAND            reduce using rule 165 (Op_Pointer -> Value .)
    AOR             reduce using rule 165 (Op_Pointer -> Value .)
    ASHIFT_R        reduce using rule 165 (Op_Pointer -> Value .)
    ASHIFT_L        reduce using rule 165 (Op_Pointer -> Value .)
    R_BRACKET       reduce using rule 165 (Op_Pointer -> Value .)
    COMMA           reduce using rule 165 (Op_Pointer -> Value .)
    SEMICOLON       reduce using rule 165 (Op_Pointer -> Value .)
    R_PAR           reduce using rule 165 (Op_Pointer -> Value .)
    COLON           reduce using rule 165 (Op_Pointer -> Value .)
    INTEGER         reduce using rule 165 (Op_Pointer -> Value .)
    STRING          reduce using rule 165 (Op_Pointer -> Value .)
    CHARACTER       reduce using rule 165 (Op_Pointer -> Value .)
    DECIMAL         reduce using rule 165 (Op_Pointer -> Value .)
    NAME            reduce using rule 165 (Op_Pointer -> Value .)
    L_PAR           reduce using rule 165 (Op_Pointer -> Value .)


state 134

    (166) Value -> INTEGER .

    PLUSPLUS        reduce using rule 166 (Value -> INTEGER .)
    MINUSMINUS      reduce using rule 166 (Value -> INTEGER .)
    DOT             reduce using rule 166 (Value -> INTEGER .)
    ACCESS          reduce using rule 166 (Value -> INTEGER .)
    L_BRACKET       reduce using rule 166 (Value -> INTEGER .)
    MULTIPLY        reduce using rule 166 (Value -> INTEGER .)
    DIVIDE          reduce using rule 166 (Value -> INTEGER .)
    REMAINDER       reduce using rule 166 (Value -> INTEGER .)
    PLUS            reduce using rule 166 (Value -> INTEGER .)
    MINUS           reduce using rule 166 (Value -> INTEGER .)
    SHIFT_L         reduce using rule 166 (Value -> INTEGER .)
    SHIFT_R         reduce using rule 166 (Value -> INTEGER .)
    LESS            reduce using rule 166 (Value -> INTEGER .)
    GREATER         reduce using rule 166 (Value -> INTEGER .)
    LESS_EQUAL      reduce using rule 166 (Value -> INTEGER .)
    GREATER_EQUAL   reduce using rule 166 (Value -> INTEGER .)
    EQUAL           reduce using rule 166 (Value -> INTEGER .)
    NOT_EQUAL       reduce using rule 166 (Value -> INTEGER .)
    AND_B           reduce using rule 166 (Value -> INTEGER .)
    XOR_B           reduce using rule 166 (Value -> INTEGER .)
    OR_B            reduce using rule 166 (Value -> INTEGER .)
    AND             reduce using rule 166 (Value -> INTEGER .)
    QUESTION        reduce using rule 166 (Value -> INTEGER .)
    OR              reduce using rule 166 (Value -> INTEGER .)
    ASSIGN          reduce using rule 166 (Value -> INTEGER .)
    APLUS           reduce using rule 166 (Value -> INTEGER .)
    AMINUS          reduce using rule 166 (Value -> INTEGER .)
    AMULTIPLY       reduce using rule 166 (Value -> INTEGER .)
    ADIVIDE         reduce using rule 166 (Value -> INTEGER .)
    AXOR            reduce using rule 166 (Value -> INTEGER .)
    AAND            reduce using rule 166 (Value -> INTEGER .)
    AOR             reduce using rule 166 (Value -> INTEGER .)
    ASHIFT_R        reduce using rule 166 (Value -> INTEGER .)
    ASHIFT_L        reduce using rule 166 (Value -> INTEGER .)
    R_BRACKET       reduce using rule 166 (Value -> INTEGER .)
    COMMA           reduce using rule 166 (Value -> INTEGER .)
    SEMICOLON       reduce using rule 166 (Value -> INTEGER .)
    R_PAR           reduce using rule 166 (Value -> INTEGER .)
    COLON           reduce using rule 166 (Value -> INTEGER .)
    INTEGER         reduce using rule 166 (Value -> INTEGER .)
    STRING          reduce using rule 166 (Value -> INTEGER .)
    CHARACTER       reduce using rule 166 (Value -> INTEGER .)
    DECIMAL         reduce using rule 166 (Value -> INTEGER .)
    NAME            reduce using rule 166 (Value -> INTEGER .)
    L_PAR           reduce using rule 166 (Value -> INTEGER .)


state 135

    (167) Value -> STRING .

    PLUSPLUS        reduce using rule 167 (Value -> STRING .)
    MINUSMINUS      reduce using rule 167 (Value -> STRING .)
    DOT             reduce using rule 167 (Value -> STRING .)
    ACCESS          reduce using rule 167 (Value -> STRING .)
    L_BRACKET       reduce using rule 167 (Value -> STRING .)
    MULTIPLY        reduce using rule 167 (Value -> STRING .)
    DIVIDE          reduce using rule 167 (Value -> STRING .)
    REMAINDER       reduce using rule 167 (Value -> STRING .)
    PLUS            reduce using rule 167 (Value -> STRING .)
    MINUS           reduce using rule 167 (Value -> STRING .)
    SHIFT_L         reduce using rule 167 (Value -> STRING .)
    SHIFT_R         reduce using rule 167 (Value -> STRING .)
    LESS            reduce using rule 167 (Value -> STRING .)
    GREATER         reduce using rule 167 (Value -> STRING .)
    LESS_EQUAL      reduce using rule 167 (Value -> STRING .)
    GREATER_EQUAL   reduce using rule 167 (Value -> STRING .)
    EQUAL           reduce using rule 167 (Value -> STRING .)
    NOT_EQUAL       reduce using rule 167 (Value -> STRING .)
    AND_B           reduce using rule 167 (Value -> STRING .)
    XOR_B           reduce using rule 167 (Value -> STRING .)
    OR_B            reduce using rule 167 (Value -> STRING .)
    AND             reduce using rule 167 (Value -> STRING .)
    QUESTION        reduce using rule 167 (Value -> STRING .)
    OR              reduce using rule 167 (Value -> STRING .)
    ASSIGN          reduce using rule 167 (Value -> STRING .)
    APLUS           reduce using rule 167 (Value -> STRING .)
    AMINUS          reduce using rule 167 (Value -> STRING .)
    AMULTIPLY       reduce using rule 167 (Value -> STRING .)
    ADIVIDE         reduce using rule 167 (Value -> STRING .)
    AXOR            reduce using rule 167 (Value -> STRING .)
    AAND            reduce using rule 167 (Value -> STRING .)
    AOR             reduce using rule 167 (Value -> STRING .)
    ASHIFT_R        reduce using rule 167 (Value -> STRING .)
    ASHIFT_L        reduce using rule 167 (Value -> STRING .)
    R_BRACKET       reduce using rule 167 (Value -> STRING .)
    COMMA           reduce using rule 167 (Value -> STRING .)
    SEMICOLON       reduce using rule 167 (Value -> STRING .)
    R_PAR           reduce using rule 167 (Value -> STRING .)
    COLON           reduce using rule 167 (Value -> STRING .)
    INTEGER         reduce using rule 167 (Value -> STRING .)
    STRING          reduce using rule 167 (Value -> STRING .)
    CHARACTER       reduce using rule 167 (Value -> STRING .)
    DECIMAL         reduce using rule 167 (Value -> STRING .)
    NAME            reduce using rule 167 (Value -> STRING .)
    L_PAR           reduce using rule 167 (Value -> STRING .)


state 136

    (168) Value -> CHARACTER .

    PLUSPLUS        reduce using rule 168 (Value -> CHARACTER .)
    MINUSMINUS      reduce using rule 168 (Value -> CHARACTER .)
    DOT             reduce using rule 168 (Value -> CHARACTER .)
    ACCESS          reduce using rule 168 (Value -> CHARACTER .)
    L_BRACKET       reduce using rule 168 (Value -> CHARACTER .)
    MULTIPLY        reduce using rule 168 (Value -> CHARACTER .)
    DIVIDE          reduce using rule 168 (Value -> CHARACTER .)
    REMAINDER       reduce using rule 168 (Value -> CHARACTER .)
    PLUS            reduce using rule 168 (Value -> CHARACTER .)
    MINUS           reduce using rule 168 (Value -> CHARACTER .)
    SHIFT_L         reduce using rule 168 (Value -> CHARACTER .)
    SHIFT_R         reduce using rule 168 (Value -> CHARACTER .)
    LESS            reduce using rule 168 (Value -> CHARACTER .)
    GREATER         reduce using rule 168 (Value -> CHARACTER .)
    LESS_EQUAL      reduce using rule 168 (Value -> CHARACTER .)
    GREATER_EQUAL   reduce using rule 168 (Value -> CHARACTER .)
    EQUAL           reduce using rule 168 (Value -> CHARACTER .)
    NOT_EQUAL       reduce using rule 168 (Value -> CHARACTER .)
    AND_B           reduce using rule 168 (Value -> CHARACTER .)
    XOR_B           reduce using rule 168 (Value -> CHARACTER .)
    OR_B            reduce using rule 168 (Value -> CHARACTER .)
    AND             reduce using rule 168 (Value -> CHARACTER .)
    QUESTION        reduce using rule 168 (Value -> CHARACTER .)
    OR              reduce using rule 168 (Value -> CHARACTER .)
    ASSIGN          reduce using rule 168 (Value -> CHARACTER .)
    APLUS           reduce using rule 168 (Value -> CHARACTER .)
    AMINUS          reduce using rule 168 (Value -> CHARACTER .)
    AMULTIPLY       reduce using rule 168 (Value -> CHARACTER .)
    ADIVIDE         reduce using rule 168 (Value -> CHARACTER .)
    AXOR            reduce using rule 168 (Value -> CHARACTER .)
    AAND            reduce using rule 168 (Value -> CHARACTER .)
    AOR             reduce using rule 168 (Value -> CHARACTER .)
    ASHIFT_R        reduce using rule 168 (Value -> CHARACTER .)
    ASHIFT_L        reduce using rule 168 (Value -> CHARACTER .)
    R_BRACKET       reduce using rule 168 (Value -> CHARACTER .)
    COMMA           reduce using rule 168 (Value -> CHARACTER .)
    SEMICOLON       reduce using rule 168 (Value -> CHARACTER .)
    R_PAR           reduce using rule 168 (Value -> CHARACTER .)
    COLON           reduce using rule 168 (Value -> CHARACTER .)
    INTEGER         reduce using rule 168 (Value -> CHARACTER .)
    STRING          reduce using rule 168 (Value -> CHARACTER .)
    CHARACTER       reduce using rule 168 (Value -> CHARACTER .)
    DECIMAL         reduce using rule 168 (Value -> CHARACTER .)
    NAME            reduce using rule 168 (Value -> CHARACTER .)
    L_PAR           reduce using rule 168 (Value -> CHARACTER .)


state 137

    (169) Value -> DECIMAL .

    PLUSPLUS        reduce using rule 169 (Value -> DECIMAL .)
    MINUSMINUS      reduce using rule 169 (Value -> DECIMAL .)
    DOT             reduce using rule 169 (Value -> DECIMAL .)
    ACCESS          reduce using rule 169 (Value -> DECIMAL .)
    L_BRACKET       reduce using rule 169 (Value -> DECIMAL .)
    MULTIPLY        reduce using rule 169 (Value -> DECIMAL .)
    DIVIDE          reduce using rule 169 (Value -> DECIMAL .)
    REMAINDER       reduce using rule 169 (Value -> DECIMAL .)
    PLUS            reduce using rule 169 (Value -> DECIMAL .)
    MINUS           reduce using rule 169 (Value -> DECIMAL .)
    SHIFT_L         reduce using rule 169 (Value -> DECIMAL .)
    SHIFT_R         reduce using rule 169 (Value -> DECIMAL .)
    LESS            reduce using rule 169 (Value -> DECIMAL .)
    GREATER         reduce using rule 169 (Value -> DECIMAL .)
    LESS_EQUAL      reduce using rule 169 (Value -> DECIMAL .)
    GREATER_EQUAL   reduce using rule 169 (Value -> DECIMAL .)
    EQUAL           reduce using rule 169 (Value -> DECIMAL .)
    NOT_EQUAL       reduce using rule 169 (Value -> DECIMAL .)
    AND_B           reduce using rule 169 (Value -> DECIMAL .)
    XOR_B           reduce using rule 169 (Value -> DECIMAL .)
    OR_B            reduce using rule 169 (Value -> DECIMAL .)
    AND             reduce using rule 169 (Value -> DECIMAL .)
    QUESTION        reduce using rule 169 (Value -> DECIMAL .)
    OR              reduce using rule 169 (Value -> DECIMAL .)
    ASSIGN          reduce using rule 169 (Value -> DECIMAL .)
    APLUS           reduce using rule 169 (Value -> DECIMAL .)
    AMINUS          reduce using rule 169 (Value -> DECIMAL .)
    AMULTIPLY       reduce using rule 169 (Value -> DECIMAL .)
    ADIVIDE         reduce using rule 169 (Value -> DECIMAL .)
    AXOR            reduce using rule 169 (Value -> DECIMAL .)
    AAND            reduce using rule 169 (Value -> DECIMAL .)
    AOR             reduce using rule 169 (Value -> DECIMAL .)
    ASHIFT_R        reduce using rule 169 (Value -> DECIMAL .)
    ASHIFT_L        reduce using rule 169 (Value -> DECIMAL .)
    R_BRACKET       reduce using rule 169 (Value -> DECIMAL .)
    COMMA           reduce using rule 169 (Value -> DECIMAL .)
    SEMICOLON       reduce using rule 169 (Value -> DECIMAL .)
    R_PAR           reduce using rule 169 (Value -> DECIMAL .)
    COLON           reduce using rule 169 (Value -> DECIMAL .)
    INTEGER         reduce using rule 169 (Value -> DECIMAL .)
    STRING          reduce using rule 169 (Value -> DECIMAL .)
    CHARACTER       reduce using rule 169 (Value -> DECIMAL .)
    DECIMAL         reduce using rule 169 (Value -> DECIMAL .)
    NAME            reduce using rule 169 (Value -> DECIMAL .)
    L_PAR           reduce using rule 169 (Value -> DECIMAL .)


state 138

    (32) Var_Decl -> Type Var Var_List SEMICOLON .

    STRUCT          reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    UNION           reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    ENUM            reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    TYPEDEF         reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    NAME            reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    EXTERN          reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    STATIC          reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    REGISTER        reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    AUTO            reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    VOLATILE        reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    CONST           reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    SIGNED          reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    UNSIGNED        reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    CHAR            reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    INT             reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    FLOAT           reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    DOUBLE          reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    VOID            reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    $end            reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    R_CURLY         reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    L_CURLY         reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    PRINTF          reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    SCANF           reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    IF              reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    WHILE           reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    FOR             reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    DO              reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    SWITCH          reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    GOTO            reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    BREAK           reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    CONTINUE        reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    RETURN          reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    SEMICOLON       reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    NOT             reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    NOT_B           reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    UMINUS          reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    MULTIPLY        reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    AND_B           reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    PLUSPLUS        reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    MINUSMINUS      reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    L_PAR           reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    SIZEOF          reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    INTEGER         reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    STRING          reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    CHARACTER       reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    DECIMAL         reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    CASE            reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)
    DEFAULT         reduce using rule 32 (Var_Decl -> Type Var Var_List SEMICOLON .)


state 139

    (26) Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .

    STRUCT          reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    UNION           reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    ENUM            reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    TYPEDEF         reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    NAME            reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    EXTERN          reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    STATIC          reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    REGISTER        reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    AUTO            reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    VOLATILE        reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    CONST           reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    SIGNED          reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    UNSIGNED        reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    CHAR            reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    INT             reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    FLOAT           reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    DOUBLE          reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    VOID            reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)
    $end            reduce using rule 26 (Typedef_Decl -> TYPEDEF Type NAME SEMICOLON .)


state 140

    (13) Func_Decl -> Func_ID L_PAR Params R_PAR Block .

    STRUCT          reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    UNION           reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    ENUM            reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    TYPEDEF         reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    NAME            reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    EXTERN          reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    STATIC          reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    REGISTER        reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    AUTO            reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    VOLATILE        reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    CONST           reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    SIGNED          reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    UNSIGNED        reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    CHAR            reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    INT             reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    FLOAT           reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    DOUBLE          reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    VOID            reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)
    $end            reduce using rule 13 (Func_Decl -> Func_ID L_PAR Params R_PAR Block .)


state 141

    (11) Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .

    STRUCT          reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    UNION           reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    ENUM            reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    TYPEDEF         reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    NAME            reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    EXTERN          reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    STATIC          reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    REGISTER        reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    AUTO            reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    VOLATILE        reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    CONST           reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    SIGNED          reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    UNSIGNED        reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    CHAR            reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    INT             reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    FLOAT           reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    DOUBLE          reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    VOID            reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)
    $end            reduce using rule 11 (Func_Proto -> Func_ID L_PAR Params R_PAR SEMICOLON .)


state 142

    (103) Block -> L_CURLY Stm_List . R_CURLY

    R_CURLY         shift and go to state 226


state 143

    (104) Stm_List -> Stm . Stm_List
    (104) Stm_List -> . Stm Stm_List
    (105) Stm_List -> . empty
    (70) Stm -> . PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
    (75) Stm -> . SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
    (78) Stm -> . Var_Decl
    (79) Stm -> . NAME COLON
    (80) Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> . IF L_PAR Expr R_PAR Stm
    (82) Stm -> . WHILE L_PAR Expr R_PAR Stm
    (83) Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (84) Stm -> . Normal_Stm
    (174) empty -> .
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (89) Normal_Stm -> . DO Stm WHILE L_PAR Expr R_PAR
    (90) Normal_Stm -> . SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
    (91) Normal_Stm -> . Block
    (92) Normal_Stm -> . Expr SEMICOLON
    (93) Normal_Stm -> . GOTO NAME SEMICOLON
    (94) Normal_Stm -> . BREAK SEMICOLON
    (95) Normal_Stm -> . CONTINUE SEMICOLON
    (96) Normal_Stm -> . RETURN Expr SEMICOLON
    (97) Normal_Stm -> . SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (103) Block -> . L_CURLY Stm_List R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    PRINTF          shift and go to state 145
    SCANF           shift and go to state 147
    NAME            shift and go to state 149
    IF              shift and go to state 150
    WHILE           shift and go to state 152
    FOR             shift and go to state 153
    R_CURLY         reduce using rule 174 (empty -> .)
    CASE            reduce using rule 174 (empty -> .)
    DEFAULT         reduce using rule 174 (empty -> .)
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    DO              shift and go to state 155
    SWITCH          shift and go to state 156
    GOTO            shift and go to state 158
    BREAK           shift and go to state 159
    CONTINUE        shift and go to state 160
    RETURN          shift and go to state 161
    SEMICOLON       shift and go to state 146
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    L_CURLY         shift and go to state 86
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137

    Stm                            shift and go to state 143
    Stm_List                       shift and go to state 227
    empty                          shift and go to state 144
    Var_Decl                       shift and go to state 148
    Expr                           shift and go to state 151
    Normal_Stm                     shift and go to state 154
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Block                          shift and go to state 157
    Base                           shift and go to state 25
    Op_Assign                      shift and go to state 109
    Sign                           shift and go to state 26
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 144

    (105) Stm_List -> empty .
    (62) Sign -> empty .

    R_CURLY         reduce using rule 105 (Stm_List -> empty .)
    CASE            reduce using rule 105 (Stm_List -> empty .)
    DEFAULT         reduce using rule 105 (Stm_List -> empty .)
    CHAR            reduce using rule 62 (Sign -> empty .)
    INT             reduce using rule 62 (Sign -> empty .)
    FLOAT           reduce using rule 62 (Sign -> empty .)
    DOUBLE          reduce using rule 62 (Sign -> empty .)
    VOID            reduce using rule 62 (Sign -> empty .)


state 145

    (70) Stm -> PRINTF . L_PAR STRING Printf_Params R_PAR SEMICOLON

    L_PAR           shift and go to state 228


state 146

    (97) Normal_Stm -> SEMICOLON .

    PRINTF          reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    SCANF           reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    NAME            reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    IF              reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    WHILE           reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    FOR             reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    DO              reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    SWITCH          reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    GOTO            reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    BREAK           reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    CONTINUE        reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    RETURN          reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    SEMICOLON       reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    EXTERN          reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    STATIC          reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    REGISTER        reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    AUTO            reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    VOLATILE        reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    CONST           reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    L_CURLY         reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    STRUCT          reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    UNION           reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    ENUM            reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    SIGNED          reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    UNSIGNED        reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    NOT             reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    NOT_B           reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    UMINUS          reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    MULTIPLY        reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    AND_B           reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    PLUSPLUS        reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    MINUSMINUS      reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    L_PAR           reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    SIZEOF          reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    INTEGER         reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    STRING          reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    CHARACTER       reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    DECIMAL         reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    CHAR            reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    INT             reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    FLOAT           reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    DOUBLE          reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    VOID            reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    R_CURLY         reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    CASE            reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    DEFAULT         reduce using rule 97 (Normal_Stm -> SEMICOLON .)
    ELSE            reduce using rule 97 (Normal_Stm -> SEMICOLON .)


state 147

    (75) Stm -> SCANF . L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON

    L_PAR           shift and go to state 229


state 148

    (78) Stm -> Var_Decl .

    PRINTF          reduce using rule 78 (Stm -> Var_Decl .)
    SCANF           reduce using rule 78 (Stm -> Var_Decl .)
    NAME            reduce using rule 78 (Stm -> Var_Decl .)
    IF              reduce using rule 78 (Stm -> Var_Decl .)
    WHILE           reduce using rule 78 (Stm -> Var_Decl .)
    FOR             reduce using rule 78 (Stm -> Var_Decl .)
    DO              reduce using rule 78 (Stm -> Var_Decl .)
    SWITCH          reduce using rule 78 (Stm -> Var_Decl .)
    GOTO            reduce using rule 78 (Stm -> Var_Decl .)
    BREAK           reduce using rule 78 (Stm -> Var_Decl .)
    CONTINUE        reduce using rule 78 (Stm -> Var_Decl .)
    RETURN          reduce using rule 78 (Stm -> Var_Decl .)
    SEMICOLON       reduce using rule 78 (Stm -> Var_Decl .)
    EXTERN          reduce using rule 78 (Stm -> Var_Decl .)
    STATIC          reduce using rule 78 (Stm -> Var_Decl .)
    REGISTER        reduce using rule 78 (Stm -> Var_Decl .)
    AUTO            reduce using rule 78 (Stm -> Var_Decl .)
    VOLATILE        reduce using rule 78 (Stm -> Var_Decl .)
    CONST           reduce using rule 78 (Stm -> Var_Decl .)
    L_CURLY         reduce using rule 78 (Stm -> Var_Decl .)
    STRUCT          reduce using rule 78 (Stm -> Var_Decl .)
    UNION           reduce using rule 78 (Stm -> Var_Decl .)
    ENUM            reduce using rule 78 (Stm -> Var_Decl .)
    SIGNED          reduce using rule 78 (Stm -> Var_Decl .)
    UNSIGNED        reduce using rule 78 (Stm -> Var_Decl .)
    NOT             reduce using rule 78 (Stm -> Var_Decl .)
    NOT_B           reduce using rule 78 (Stm -> Var_Decl .)
    UMINUS          reduce using rule 78 (Stm -> Var_Decl .)
    MULTIPLY        reduce using rule 78 (Stm -> Var_Decl .)
    AND_B           reduce using rule 78 (Stm -> Var_Decl .)
    PLUSPLUS        reduce using rule 78 (Stm -> Var_Decl .)
    MINUSMINUS      reduce using rule 78 (Stm -> Var_Decl .)
    L_PAR           reduce using rule 78 (Stm -> Var_Decl .)
    SIZEOF          reduce using rule 78 (Stm -> Var_Decl .)
    INTEGER         reduce using rule 78 (Stm -> Var_Decl .)
    STRING          reduce using rule 78 (Stm -> Var_Decl .)
    CHARACTER       reduce using rule 78 (Stm -> Var_Decl .)
    DECIMAL         reduce using rule 78 (Stm -> Var_Decl .)
    CHAR            reduce using rule 78 (Stm -> Var_Decl .)
    INT             reduce using rule 78 (Stm -> Var_Decl .)
    FLOAT           reduce using rule 78 (Stm -> Var_Decl .)
    DOUBLE          reduce using rule 78 (Stm -> Var_Decl .)
    VOID            reduce using rule 78 (Stm -> Var_Decl .)
    R_CURLY         reduce using rule 78 (Stm -> Var_Decl .)
    CASE            reduce using rule 78 (Stm -> Var_Decl .)
    DEFAULT         reduce using rule 78 (Stm -> Var_Decl .)


state 149

    (79) Stm -> NAME . COLON
    (170) Value -> NAME .
    (171) Value -> NAME . L_PAR Expr R_PAR
    (172) Value -> NAME . L_PAR R_PAR

    COLON           shift and go to state 230
    PLUSPLUS        reduce using rule 170 (Value -> NAME .)
    MINUSMINUS      reduce using rule 170 (Value -> NAME .)
    DOT             reduce using rule 170 (Value -> NAME .)
    ACCESS          reduce using rule 170 (Value -> NAME .)
    L_BRACKET       reduce using rule 170 (Value -> NAME .)
    MULTIPLY        reduce using rule 170 (Value -> NAME .)
    DIVIDE          reduce using rule 170 (Value -> NAME .)
    REMAINDER       reduce using rule 170 (Value -> NAME .)
    PLUS            reduce using rule 170 (Value -> NAME .)
    MINUS           reduce using rule 170 (Value -> NAME .)
    SHIFT_L         reduce using rule 170 (Value -> NAME .)
    SHIFT_R         reduce using rule 170 (Value -> NAME .)
    LESS            reduce using rule 170 (Value -> NAME .)
    GREATER         reduce using rule 170 (Value -> NAME .)
    LESS_EQUAL      reduce using rule 170 (Value -> NAME .)
    GREATER_EQUAL   reduce using rule 170 (Value -> NAME .)
    EQUAL           reduce using rule 170 (Value -> NAME .)
    NOT_EQUAL       reduce using rule 170 (Value -> NAME .)
    AND_B           reduce using rule 170 (Value -> NAME .)
    XOR_B           reduce using rule 170 (Value -> NAME .)
    OR_B            reduce using rule 170 (Value -> NAME .)
    AND             reduce using rule 170 (Value -> NAME .)
    QUESTION        reduce using rule 170 (Value -> NAME .)
    OR              reduce using rule 170 (Value -> NAME .)
    ASSIGN          reduce using rule 170 (Value -> NAME .)
    APLUS           reduce using rule 170 (Value -> NAME .)
    AMINUS          reduce using rule 170 (Value -> NAME .)
    AMULTIPLY       reduce using rule 170 (Value -> NAME .)
    ADIVIDE         reduce using rule 170 (Value -> NAME .)
    AXOR            reduce using rule 170 (Value -> NAME .)
    AAND            reduce using rule 170 (Value -> NAME .)
    AOR             reduce using rule 170 (Value -> NAME .)
    ASHIFT_R        reduce using rule 170 (Value -> NAME .)
    ASHIFT_L        reduce using rule 170 (Value -> NAME .)
    SEMICOLON       reduce using rule 170 (Value -> NAME .)
    COMMA           reduce using rule 170 (Value -> NAME .)
    L_PAR           shift and go to state 225


state 150

    (80) Stm -> IF . L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> IF . L_PAR Expr R_PAR Stm

    L_PAR           shift and go to state 231


state 151

    (92) Normal_Stm -> Expr . SEMICOLON
    (106) Expr -> Expr . COMMA Op_Assign

    SEMICOLON       shift and go to state 232
    COMMA           shift and go to state 180


state 152

    (82) Stm -> WHILE . L_PAR Expr R_PAR Stm

    L_PAR           shift and go to state 233


state 153

    (83) Stm -> FOR . L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm

    L_PAR           shift and go to state 234


state 154

    (84) Stm -> Normal_Stm .

    PRINTF          reduce using rule 84 (Stm -> Normal_Stm .)
    SCANF           reduce using rule 84 (Stm -> Normal_Stm .)
    NAME            reduce using rule 84 (Stm -> Normal_Stm .)
    IF              reduce using rule 84 (Stm -> Normal_Stm .)
    WHILE           reduce using rule 84 (Stm -> Normal_Stm .)
    FOR             reduce using rule 84 (Stm -> Normal_Stm .)
    DO              reduce using rule 84 (Stm -> Normal_Stm .)
    SWITCH          reduce using rule 84 (Stm -> Normal_Stm .)
    GOTO            reduce using rule 84 (Stm -> Normal_Stm .)
    BREAK           reduce using rule 84 (Stm -> Normal_Stm .)
    CONTINUE        reduce using rule 84 (Stm -> Normal_Stm .)
    RETURN          reduce using rule 84 (Stm -> Normal_Stm .)
    SEMICOLON       reduce using rule 84 (Stm -> Normal_Stm .)
    EXTERN          reduce using rule 84 (Stm -> Normal_Stm .)
    STATIC          reduce using rule 84 (Stm -> Normal_Stm .)
    REGISTER        reduce using rule 84 (Stm -> Normal_Stm .)
    AUTO            reduce using rule 84 (Stm -> Normal_Stm .)
    VOLATILE        reduce using rule 84 (Stm -> Normal_Stm .)
    CONST           reduce using rule 84 (Stm -> Normal_Stm .)
    L_CURLY         reduce using rule 84 (Stm -> Normal_Stm .)
    STRUCT          reduce using rule 84 (Stm -> Normal_Stm .)
    UNION           reduce using rule 84 (Stm -> Normal_Stm .)
    ENUM            reduce using rule 84 (Stm -> Normal_Stm .)
    SIGNED          reduce using rule 84 (Stm -> Normal_Stm .)
    UNSIGNED        reduce using rule 84 (Stm -> Normal_Stm .)
    NOT             reduce using rule 84 (Stm -> Normal_Stm .)
    NOT_B           reduce using rule 84 (Stm -> Normal_Stm .)
    UMINUS          reduce using rule 84 (Stm -> Normal_Stm .)
    MULTIPLY        reduce using rule 84 (Stm -> Normal_Stm .)
    AND_B           reduce using rule 84 (Stm -> Normal_Stm .)
    PLUSPLUS        reduce using rule 84 (Stm -> Normal_Stm .)
    MINUSMINUS      reduce using rule 84 (Stm -> Normal_Stm .)
    L_PAR           reduce using rule 84 (Stm -> Normal_Stm .)
    SIZEOF          reduce using rule 84 (Stm -> Normal_Stm .)
    INTEGER         reduce using rule 84 (Stm -> Normal_Stm .)
    STRING          reduce using rule 84 (Stm -> Normal_Stm .)
    CHARACTER       reduce using rule 84 (Stm -> Normal_Stm .)
    DECIMAL         reduce using rule 84 (Stm -> Normal_Stm .)
    CHAR            reduce using rule 84 (Stm -> Normal_Stm .)
    INT             reduce using rule 84 (Stm -> Normal_Stm .)
    FLOAT           reduce using rule 84 (Stm -> Normal_Stm .)
    DOUBLE          reduce using rule 84 (Stm -> Normal_Stm .)
    VOID            reduce using rule 84 (Stm -> Normal_Stm .)
    R_CURLY         reduce using rule 84 (Stm -> Normal_Stm .)
    CASE            reduce using rule 84 (Stm -> Normal_Stm .)
    DEFAULT         reduce using rule 84 (Stm -> Normal_Stm .)


state 155

    (89) Normal_Stm -> DO . Stm WHILE L_PAR Expr R_PAR
    (70) Stm -> . PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
    (75) Stm -> . SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
    (78) Stm -> . Var_Decl
    (79) Stm -> . NAME COLON
    (80) Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> . IF L_PAR Expr R_PAR Stm
    (82) Stm -> . WHILE L_PAR Expr R_PAR Stm
    (83) Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (84) Stm -> . Normal_Stm
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (89) Normal_Stm -> . DO Stm WHILE L_PAR Expr R_PAR
    (90) Normal_Stm -> . SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
    (91) Normal_Stm -> . Block
    (92) Normal_Stm -> . Expr SEMICOLON
    (93) Normal_Stm -> . GOTO NAME SEMICOLON
    (94) Normal_Stm -> . BREAK SEMICOLON
    (95) Normal_Stm -> . CONTINUE SEMICOLON
    (96) Normal_Stm -> . RETURN Expr SEMICOLON
    (97) Normal_Stm -> . SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (103) Block -> . L_CURLY Stm_List R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (174) empty -> .
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    PRINTF          shift and go to state 145
    SCANF           shift and go to state 147
    NAME            shift and go to state 149
    IF              shift and go to state 150
    WHILE           shift and go to state 152
    FOR             shift and go to state 153
    DO              shift and go to state 155
    SWITCH          shift and go to state 156
    GOTO            shift and go to state 158
    BREAK           shift and go to state 159
    CONTINUE        shift and go to state 160
    RETURN          shift and go to state 161
    SEMICOLON       shift and go to state 146
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    L_CURLY         shift and go to state 86
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137

    Stm                            shift and go to state 235
    Expr                           shift and go to state 151
    Var_Decl                       shift and go to state 148
    Normal_Stm                     shift and go to state 154
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Block                          shift and go to state 157
    Base                           shift and go to state 25
    Op_Assign                      shift and go to state 109
    Sign                           shift and go to state 26
    Op_If                          shift and go to state 110
    empty                          shift and go to state 42
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 156

    (90) Normal_Stm -> SWITCH . L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY

    L_PAR           shift and go to state 236


state 157

    (91) Normal_Stm -> Block .

    PRINTF          reduce using rule 91 (Normal_Stm -> Block .)
    SCANF           reduce using rule 91 (Normal_Stm -> Block .)
    NAME            reduce using rule 91 (Normal_Stm -> Block .)
    IF              reduce using rule 91 (Normal_Stm -> Block .)
    WHILE           reduce using rule 91 (Normal_Stm -> Block .)
    FOR             reduce using rule 91 (Normal_Stm -> Block .)
    DO              reduce using rule 91 (Normal_Stm -> Block .)
    SWITCH          reduce using rule 91 (Normal_Stm -> Block .)
    GOTO            reduce using rule 91 (Normal_Stm -> Block .)
    BREAK           reduce using rule 91 (Normal_Stm -> Block .)
    CONTINUE        reduce using rule 91 (Normal_Stm -> Block .)
    RETURN          reduce using rule 91 (Normal_Stm -> Block .)
    SEMICOLON       reduce using rule 91 (Normal_Stm -> Block .)
    EXTERN          reduce using rule 91 (Normal_Stm -> Block .)
    STATIC          reduce using rule 91 (Normal_Stm -> Block .)
    REGISTER        reduce using rule 91 (Normal_Stm -> Block .)
    AUTO            reduce using rule 91 (Normal_Stm -> Block .)
    VOLATILE        reduce using rule 91 (Normal_Stm -> Block .)
    CONST           reduce using rule 91 (Normal_Stm -> Block .)
    L_CURLY         reduce using rule 91 (Normal_Stm -> Block .)
    STRUCT          reduce using rule 91 (Normal_Stm -> Block .)
    UNION           reduce using rule 91 (Normal_Stm -> Block .)
    ENUM            reduce using rule 91 (Normal_Stm -> Block .)
    SIGNED          reduce using rule 91 (Normal_Stm -> Block .)
    UNSIGNED        reduce using rule 91 (Normal_Stm -> Block .)
    NOT             reduce using rule 91 (Normal_Stm -> Block .)
    NOT_B           reduce using rule 91 (Normal_Stm -> Block .)
    UMINUS          reduce using rule 91 (Normal_Stm -> Block .)
    MULTIPLY        reduce using rule 91 (Normal_Stm -> Block .)
    AND_B           reduce using rule 91 (Normal_Stm -> Block .)
    PLUSPLUS        reduce using rule 91 (Normal_Stm -> Block .)
    MINUSMINUS      reduce using rule 91 (Normal_Stm -> Block .)
    L_PAR           reduce using rule 91 (Normal_Stm -> Block .)
    SIZEOF          reduce using rule 91 (Normal_Stm -> Block .)
    INTEGER         reduce using rule 91 (Normal_Stm -> Block .)
    STRING          reduce using rule 91 (Normal_Stm -> Block .)
    CHARACTER       reduce using rule 91 (Normal_Stm -> Block .)
    DECIMAL         reduce using rule 91 (Normal_Stm -> Block .)
    CHAR            reduce using rule 91 (Normal_Stm -> Block .)
    INT             reduce using rule 91 (Normal_Stm -> Block .)
    FLOAT           reduce using rule 91 (Normal_Stm -> Block .)
    DOUBLE          reduce using rule 91 (Normal_Stm -> Block .)
    VOID            reduce using rule 91 (Normal_Stm -> Block .)
    R_CURLY         reduce using rule 91 (Normal_Stm -> Block .)
    CASE            reduce using rule 91 (Normal_Stm -> Block .)
    DEFAULT         reduce using rule 91 (Normal_Stm -> Block .)
    ELSE            reduce using rule 91 (Normal_Stm -> Block .)


state 158

    (93) Normal_Stm -> GOTO . NAME SEMICOLON

    NAME            shift and go to state 237


state 159

    (94) Normal_Stm -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 238


state 160

    (95) Normal_Stm -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 239


state 161

    (96) Normal_Stm -> RETURN . Expr SEMICOLON
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Expr                           shift and go to state 240
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 162

    (14) Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def . Block
    (103) Block -> . L_CURLY Stm_List R_CURLY

    L_CURLY         shift and go to state 86

    Block                          shift and go to state 241

state 163

    (10) Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .

    STRUCT          reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    UNION           reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    ENUM            reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    TYPEDEF         reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    NAME            reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    EXTERN          reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    STATIC          reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    REGISTER        reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    AUTO            reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    VOLATILE        reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    CONST           reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    SIGNED          reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    UNSIGNED        reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    CHAR            reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    INT             reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    FLOAT           reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    DOUBLE          reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    VOID            reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)
    $end            reduce using rule 10 (Func_Proto -> Func_ID L_PAR Types R_PAR SEMICOLON .)


state 164

    (16) Params -> Param COMMA Params .

    R_PAR           reduce using rule 16 (Params -> Param COMMA Params .)


state 165

    (19) Param -> Type . NAME

    NAME            shift and go to state 92


state 166

    (22) Id_List -> NAME COMMA Id_List .

    R_PAR           reduce using rule 22 (Id_List -> NAME COMMA Id_List .)


state 167

    (20) Types -> Type . COMMA Types
    (21) Types -> Type .

    COMMA           shift and go to state 91
    R_PAR           reduce using rule 21 (Types -> Type .)


state 168

    (20) Types -> Type COMMA Types .

    R_PAR           reduce using rule 20 (Types -> Type COMMA Types .)


state 169

    (18) Param -> CONST Type NAME .

    COMMA           reduce using rule 18 (Param -> CONST Type NAME .)
    R_PAR           reduce using rule 18 (Param -> CONST Type NAME .)


state 170

    (27) Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY . SEMICOLON

    SEMICOLON       shift and go to state 242


state 171

    (28) Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY . SEMICOLON

    SEMICOLON       shift and go to state 243


state 172

    (52) Enum_Val -> NAME ASSIGN . INTEGER

    INTEGER         shift and go to state 244


state 173

    (48) Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY . SEMICOLON

    SEMICOLON       shift and go to state 245


state 174

    (49) Enum_Def -> Enum_Val COMMA . Enum_Def
    (49) Enum_Def -> . Enum_Val COMMA Enum_Def
    (50) Enum_Def -> . Enum_Val
    (51) Enum_Val -> . NAME
    (52) Enum_Val -> . NAME ASSIGN INTEGER

    NAME            shift and go to state 99

    Enum_Val                       shift and go to state 101
    Enum_Def                       shift and go to state 246

state 175

    (31) Var_Decl -> Mod Type Var Var_List SEMICOLON .

    STRUCT          reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    UNION           reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    ENUM            reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    TYPEDEF         reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    NAME            reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    EXTERN          reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    STATIC          reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    REGISTER        reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    AUTO            reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    VOLATILE        reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    CONST           reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    SIGNED          reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    UNSIGNED        reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    CHAR            reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    INT             reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    FLOAT           reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    DOUBLE          reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    VOID            reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    $end            reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    R_CURLY         reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    L_CURLY         reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    PRINTF          reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    SCANF           reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    IF              reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    WHILE           reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    FOR             reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    DO              reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    SWITCH          reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    GOTO            reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    BREAK           reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    CONTINUE        reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    RETURN          reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    SEMICOLON       reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    NOT             reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    NOT_B           reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    UMINUS          reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    MULTIPLY        reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    AND_B           reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    PLUSPLUS        reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    MINUSMINUS      reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    L_PAR           reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    SIZEOF          reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    INTEGER         reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    STRING          reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    CHARACTER       reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    DECIMAL         reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    CASE            reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)
    DEFAULT         reduce using rule 31 (Var_Decl -> Mod Type Var Var_List SEMICOLON .)


state 176

    (39) Var_List -> COMMA Var_Item Var_List .

    SEMICOLON       reduce using rule 39 (Var_List -> COMMA Var_Item Var_List .)


state 177

    (41) Var_Item -> Pointers Var .

    COMMA           reduce using rule 41 (Var_Item -> Pointers Var .)
    SEMICOLON       reduce using rule 41 (Var_Item -> Pointers Var .)


state 178

    (35) Var -> NAME Array ASSIGN Op_If .

    COMMA           reduce using rule 35 (Var -> NAME Array ASSIGN Op_If .)
    SEMICOLON       reduce using rule 35 (Var -> NAME Array ASSIGN Op_If .)


state 179

    (36) Array -> L_BRACKET Expr R_BRACKET .

    ASSIGN          reduce using rule 36 (Array -> L_BRACKET Expr R_BRACKET .)
    COMMA           reduce using rule 36 (Array -> L_BRACKET Expr R_BRACKET .)
    SEMICOLON       reduce using rule 36 (Array -> L_BRACKET Expr R_BRACKET .)


state 180

    (106) Expr -> Expr COMMA . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Assign                      shift and go to state 247
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 181

    (108) Op_Assign -> Op_If ASSIGN . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_If                          shift and go to state 110
    Op_Assign                      shift and go to state 248
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 182

    (109) Op_Assign -> Op_If APLUS . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_If                          shift and go to state 110
    Op_Assign                      shift and go to state 249
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 183

    (110) Op_Assign -> Op_If AMINUS . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_If                          shift and go to state 110
    Op_Assign                      shift and go to state 250
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 184

    (111) Op_Assign -> Op_If AMULTIPLY . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_If                          shift and go to state 110
    Op_Assign                      shift and go to state 251
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 185

    (112) Op_Assign -> Op_If ADIVIDE . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_If                          shift and go to state 110
    Op_Assign                      shift and go to state 252
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 186

    (113) Op_Assign -> Op_If AXOR . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_If                          shift and go to state 110
    Op_Assign                      shift and go to state 253
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 187

    (114) Op_Assign -> Op_If AAND . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_If                          shift and go to state 110
    Op_Assign                      shift and go to state 254
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 188

    (115) Op_Assign -> Op_If AOR . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_If                          shift and go to state 110
    Op_Assign                      shift and go to state 255
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 189

    (116) Op_Assign -> Op_If ASHIFT_R . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_If                          shift and go to state 110
    Op_Assign                      shift and go to state 256
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 190

    (117) Op_Assign -> Op_If ASHIFT_L . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_If                          shift and go to state 110
    Op_Assign                      shift and go to state 257
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 191

    (119) Op_If -> Op_Or QUESTION . Op_If COLON Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Or                          shift and go to state 111
    Op_If                          shift and go to state 258
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 192

    (121) Op_Or -> Op_Or OR . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_And                         shift and go to state 259
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 193

    (123) Op_And -> Op_And AND . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_BinOR                       shift and go to state 260
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 194

    (125) Op_BinOR -> Op_BinOR OR_B . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_BinXOR                      shift and go to state 261
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 195

    (127) Op_BinXOR -> Op_BinXOR XOR_B . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_BinAND                      shift and go to state 262
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 196

    (129) Op_BinAND -> Op_BinAND AND_B . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Equate                      shift and go to state 263
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 197

    (153) Op_Unary -> AND_B Op_Unary .

    MULTIPLY        reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    DIVIDE          reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    REMAINDER       reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    PLUS            reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    MINUS           reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    SHIFT_L         reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    SHIFT_R         reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    LESS            reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    GREATER         reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    LESS_EQUAL      reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    GREATER_EQUAL   reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    EQUAL           reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    NOT_EQUAL       reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    AND_B           reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    XOR_B           reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    OR_B            reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    AND             reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    QUESTION        reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    OR              reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    ASSIGN          reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    APLUS           reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    AMINUS          reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    AMULTIPLY       reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    ADIVIDE         reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    AXOR            reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    AAND            reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    AOR             reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    ASHIFT_R        reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    ASHIFT_L        reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    R_BRACKET       reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    COMMA           reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    SEMICOLON       reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    R_PAR           reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)
    COLON           reduce using rule 153 (Op_Unary -> AND_B Op_Unary .)


state 198

    (131) Op_Equate -> Op_Equate EQUAL . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Compare                     shift and go to state 264
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 199

    (132) Op_Equate -> Op_Equate NOT_EQUAL . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Compare                     shift and go to state 265
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 200

    (134) Op_Compare -> Op_Compare LESS . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Shift                       shift and go to state 266
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 201

    (135) Op_Compare -> Op_Compare GREATER . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Shift                       shift and go to state 267
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 202

    (136) Op_Compare -> Op_Compare LESS_EQUAL . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Shift                       shift and go to state 268
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 203

    (137) Op_Compare -> Op_Compare GREATER_EQUAL . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Shift                       shift and go to state 269
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 204

    (139) Op_Shift -> Op_Shift SHIFT_L . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Add                         shift and go to state 270
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 205

    (140) Op_Shift -> Op_Shift SHIFT_R . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Add                         shift and go to state 271
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 206

    (142) Op_Add -> Op_Add PLUS . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Mult                        shift and go to state 272
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 207

    (143) Op_Add -> Op_Add MINUS . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Mult                        shift and go to state 273
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 208

    (145) Op_Mult -> Op_Mult MULTIPLY . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Unary                       shift and go to state 274
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 209

    (146) Op_Mult -> Op_Mult DIVIDE . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Unary                       shift and go to state 275
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 210

    (147) Op_Mult -> Op_Mult REMAINDER . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Unary                       shift and go to state 276
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 211

    (152) Op_Unary -> MULTIPLY Op_Unary .

    MULTIPLY        reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    DIVIDE          reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    REMAINDER       reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    PLUS            reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    MINUS           reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    SHIFT_L         reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    SHIFT_R         reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    LESS            reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    GREATER         reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    LESS_EQUAL      reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    GREATER_EQUAL   reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    EQUAL           reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    NOT_EQUAL       reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    AND_B           reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    XOR_B           reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    OR_B            reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    AND             reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    QUESTION        reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    OR              reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    ASSIGN          reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    APLUS           reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    AMINUS          reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    AMULTIPLY       reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    ADIVIDE         reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    AXOR            reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    AAND            reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    AOR             reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    ASHIFT_R        reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    ASHIFT_L        reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    R_BRACKET       reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    COMMA           reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    SEMICOLON       reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    R_PAR           reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)
    COLON           reduce using rule 152 (Op_Unary -> MULTIPLY Op_Unary .)


state 212

    (149) Op_Unary -> NOT Op_Unary .

    MULTIPLY        reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    DIVIDE          reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    REMAINDER       reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    PLUS            reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    MINUS           reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    SHIFT_L         reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    SHIFT_R         reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    LESS            reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    GREATER         reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    LESS_EQUAL      reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    GREATER_EQUAL   reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    EQUAL           reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    NOT_EQUAL       reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    AND_B           reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    XOR_B           reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    OR_B            reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    AND             reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    QUESTION        reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    OR              reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    ASSIGN          reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    APLUS           reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    AMINUS          reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    AMULTIPLY       reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    ADIVIDE         reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    AXOR            reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    AAND            reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    AOR             reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    ASHIFT_R        reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    ASHIFT_L        reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    R_BRACKET       reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    COMMA           reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    SEMICOLON       reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    R_PAR           reduce using rule 149 (Op_Unary -> NOT Op_Unary .)
    COLON           reduce using rule 149 (Op_Unary -> NOT Op_Unary .)


state 213

    (150) Op_Unary -> NOT_B Op_Unary .

    MULTIPLY        reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    DIVIDE          reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    REMAINDER       reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    PLUS            reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    MINUS           reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    SHIFT_L         reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    SHIFT_R         reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    LESS            reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    GREATER         reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    LESS_EQUAL      reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    GREATER_EQUAL   reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    EQUAL           reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    NOT_EQUAL       reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    AND_B           reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    XOR_B           reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    OR_B            reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    AND             reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    QUESTION        reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    OR              reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    ASSIGN          reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    APLUS           reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    AMINUS          reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    AMULTIPLY       reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    ADIVIDE         reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    AXOR            reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    AAND            reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    AOR             reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    ASHIFT_R        reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    ASHIFT_L        reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    R_BRACKET       reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    COMMA           reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    SEMICOLON       reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    R_PAR           reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)
    COLON           reduce using rule 150 (Op_Unary -> NOT_B Op_Unary .)


state 214

    (151) Op_Unary -> UMINUS Op_Unary .

    MULTIPLY        reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    DIVIDE          reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    REMAINDER       reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    PLUS            reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    MINUS           reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    SHIFT_L         reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    SHIFT_R         reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    LESS            reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    GREATER         reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    LESS_EQUAL      reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    GREATER_EQUAL   reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    EQUAL           reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    NOT_EQUAL       reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    AND_B           reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    XOR_B           reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    OR_B            reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    AND             reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    QUESTION        reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    OR              reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    ASSIGN          reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    APLUS           reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    AMINUS          reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    AMULTIPLY       reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    ADIVIDE         reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    AXOR            reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    AAND            reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    AOR             reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    ASHIFT_R        reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    ASHIFT_L        reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    R_BRACKET       reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    COMMA           reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    SEMICOLON       reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    R_PAR           reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)
    COLON           reduce using rule 151 (Op_Unary -> UMINUS Op_Unary .)


state 215

    (154) Op_Unary -> PLUSPLUS Op_Unary .

    MULTIPLY        reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    DIVIDE          reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    REMAINDER       reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    PLUS            reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    MINUS           reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    SHIFT_L         reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    SHIFT_R         reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    LESS            reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    GREATER         reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    LESS_EQUAL      reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    GREATER_EQUAL   reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    EQUAL           reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    NOT_EQUAL       reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    AND_B           reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    XOR_B           reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    OR_B            reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    AND             reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    QUESTION        reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    OR              reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    ASSIGN          reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    APLUS           reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    AMINUS          reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    AMULTIPLY       reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    ADIVIDE         reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    AXOR            reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    AAND            reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    AOR             reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    ASHIFT_R        reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    ASHIFT_L        reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    R_BRACKET       reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    COMMA           reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    SEMICOLON       reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    R_PAR           reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)
    COLON           reduce using rule 154 (Op_Unary -> PLUSPLUS Op_Unary .)


state 216

    (155) Op_Unary -> MINUSMINUS Op_Unary .

    MULTIPLY        reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    DIVIDE          reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    REMAINDER       reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    PLUS            reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    MINUS           reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    SHIFT_L         reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    SHIFT_R         reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    LESS            reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    GREATER         reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    LESS_EQUAL      reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    GREATER_EQUAL   reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    EQUAL           reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    NOT_EQUAL       reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    AND_B           reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    XOR_B           reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    OR_B            reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    AND             reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    QUESTION        reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    OR              reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    ASSIGN          reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    APLUS           reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    AMINUS          reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    AMULTIPLY       reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    ADIVIDE         reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    AXOR            reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    AAND            reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    AOR             reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    ASHIFT_R        reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    ASHIFT_L        reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    R_BRACKET       reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    COMMA           reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    SEMICOLON       reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    R_PAR           reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)
    COLON           reduce using rule 155 (Op_Unary -> MINUSMINUS Op_Unary .)


state 217

    (156) Op_Unary -> Op_Pointer PLUSPLUS .

    MULTIPLY        reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    DIVIDE          reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    REMAINDER       reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    PLUS            reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    MINUS           reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    SHIFT_L         reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    SHIFT_R         reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    LESS            reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    GREATER         reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    LESS_EQUAL      reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    GREATER_EQUAL   reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    EQUAL           reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    NOT_EQUAL       reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    AND_B           reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    XOR_B           reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    OR_B            reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    AND             reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    QUESTION        reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    OR              reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    ASSIGN          reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    APLUS           reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    AMINUS          reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    AMULTIPLY       reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    ADIVIDE         reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    AXOR            reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    AAND            reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    AOR             reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    ASHIFT_R        reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    ASHIFT_L        reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    R_BRACKET       reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    COMMA           reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    SEMICOLON       reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    R_PAR           reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)
    COLON           reduce using rule 156 (Op_Unary -> Op_Pointer PLUSPLUS .)


state 218

    (157) Op_Unary -> Op_Pointer MINUSMINUS .

    MULTIPLY        reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    DIVIDE          reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    REMAINDER       reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    PLUS            reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    MINUS           reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    SHIFT_L         reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    SHIFT_R         reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    LESS            reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    GREATER         reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    LESS_EQUAL      reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    GREATER_EQUAL   reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    EQUAL           reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    NOT_EQUAL       reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    AND_B           reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    XOR_B           reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    OR_B            reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    AND             reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    QUESTION        reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    OR              reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    ASSIGN          reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    APLUS           reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    AMINUS          reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    AMULTIPLY       reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    ADIVIDE         reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    AXOR            reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    AAND            reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    AOR             reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    ASHIFT_R        reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    ASHIFT_L        reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    R_BRACKET       reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    COMMA           reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    SEMICOLON       reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    R_PAR           reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)
    COLON           reduce using rule 157 (Op_Unary -> Op_Pointer MINUSMINUS .)


state 219

    (162) Op_Pointer -> Op_Pointer DOT . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132
    L_PAR           shift and go to state 278

    Value                          shift and go to state 277

state 220

    (163) Op_Pointer -> Op_Pointer ACCESS . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132
    L_PAR           shift and go to state 278

    Value                          shift and go to state 279

state 221

    (164) Op_Pointer -> Op_Pointer L_BRACKET . Expr R_BRACKET
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Pointer                     shift and go to state 129
    Expr                           shift and go to state 280
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Value                          shift and go to state 133

state 222

    (158) Op_Unary -> L_PAR Type . R_PAR Op_Unary

    R_PAR           shift and go to state 281


state 223

    (173) Value -> L_PAR Expr . R_PAR
    (106) Expr -> Expr . COMMA Op_Assign

    R_PAR           shift and go to state 282
    COMMA           shift and go to state 180


state 224

    (159) Op_Unary -> SIZEOF L_PAR . Type R_PAR
    (160) Op_Unary -> SIZEOF L_PAR . NAME Pointers R_PAR
    (53) Type -> . Base Pointers
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (174) empty -> .

    NAME            shift and go to state 284
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)

    Type                           shift and go to state 283
    Base                           shift and go to state 25
    Sign                           shift and go to state 26
    empty                          shift and go to state 42

state 225

    (171) Value -> NAME L_PAR . Expr R_PAR
    (172) Value -> NAME L_PAR . R_PAR
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    R_PAR           shift and go to state 286
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Expr                           shift and go to state 285
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 226

    (103) Block -> L_CURLY Stm_List R_CURLY .

    STRUCT          reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    UNION           reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    ENUM            reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    TYPEDEF         reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    NAME            reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    EXTERN          reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    STATIC          reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    REGISTER        reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    AUTO            reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    VOLATILE        reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    CONST           reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    SIGNED          reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    UNSIGNED        reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    CHAR            reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    INT             reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    FLOAT           reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    DOUBLE          reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    VOID            reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    $end            reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    PRINTF          reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    SCANF           reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    IF              reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    WHILE           reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    FOR             reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    DO              reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    SWITCH          reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    GOTO            reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    BREAK           reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    CONTINUE        reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    RETURN          reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    SEMICOLON       reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    L_CURLY         reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    NOT             reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    NOT_B           reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    UMINUS          reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    MULTIPLY        reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    AND_B           reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    PLUSPLUS        reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    MINUSMINUS      reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    L_PAR           reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    SIZEOF          reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    INTEGER         reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    STRING          reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    CHARACTER       reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    DECIMAL         reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    R_CURLY         reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    CASE            reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    DEFAULT         reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)
    ELSE            reduce using rule 103 (Block -> L_CURLY Stm_List R_CURLY .)


state 227

    (104) Stm_List -> Stm Stm_List .

    R_CURLY         reduce using rule 104 (Stm_List -> Stm Stm_List .)
    CASE            reduce using rule 104 (Stm_List -> Stm Stm_List .)
    DEFAULT         reduce using rule 104 (Stm_List -> Stm Stm_List .)


state 228

    (70) Stm -> PRINTF L_PAR . STRING Printf_Params R_PAR SEMICOLON

    STRING          shift and go to state 287


state 229

    (75) Stm -> SCANF L_PAR . STRING COMMA Scanf_Param R_PAR SEMICOLON

    STRING          shift and go to state 288


state 230

    (79) Stm -> NAME COLON .

    PRINTF          reduce using rule 79 (Stm -> NAME COLON .)
    SCANF           reduce using rule 79 (Stm -> NAME COLON .)
    NAME            reduce using rule 79 (Stm -> NAME COLON .)
    IF              reduce using rule 79 (Stm -> NAME COLON .)
    WHILE           reduce using rule 79 (Stm -> NAME COLON .)
    FOR             reduce using rule 79 (Stm -> NAME COLON .)
    DO              reduce using rule 79 (Stm -> NAME COLON .)
    SWITCH          reduce using rule 79 (Stm -> NAME COLON .)
    GOTO            reduce using rule 79 (Stm -> NAME COLON .)
    BREAK           reduce using rule 79 (Stm -> NAME COLON .)
    CONTINUE        reduce using rule 79 (Stm -> NAME COLON .)
    RETURN          reduce using rule 79 (Stm -> NAME COLON .)
    SEMICOLON       reduce using rule 79 (Stm -> NAME COLON .)
    EXTERN          reduce using rule 79 (Stm -> NAME COLON .)
    STATIC          reduce using rule 79 (Stm -> NAME COLON .)
    REGISTER        reduce using rule 79 (Stm -> NAME COLON .)
    AUTO            reduce using rule 79 (Stm -> NAME COLON .)
    VOLATILE        reduce using rule 79 (Stm -> NAME COLON .)
    CONST           reduce using rule 79 (Stm -> NAME COLON .)
    L_CURLY         reduce using rule 79 (Stm -> NAME COLON .)
    STRUCT          reduce using rule 79 (Stm -> NAME COLON .)
    UNION           reduce using rule 79 (Stm -> NAME COLON .)
    ENUM            reduce using rule 79 (Stm -> NAME COLON .)
    SIGNED          reduce using rule 79 (Stm -> NAME COLON .)
    UNSIGNED        reduce using rule 79 (Stm -> NAME COLON .)
    NOT             reduce using rule 79 (Stm -> NAME COLON .)
    NOT_B           reduce using rule 79 (Stm -> NAME COLON .)
    UMINUS          reduce using rule 79 (Stm -> NAME COLON .)
    MULTIPLY        reduce using rule 79 (Stm -> NAME COLON .)
    AND_B           reduce using rule 79 (Stm -> NAME COLON .)
    PLUSPLUS        reduce using rule 79 (Stm -> NAME COLON .)
    MINUSMINUS      reduce using rule 79 (Stm -> NAME COLON .)
    L_PAR           reduce using rule 79 (Stm -> NAME COLON .)
    SIZEOF          reduce using rule 79 (Stm -> NAME COLON .)
    INTEGER         reduce using rule 79 (Stm -> NAME COLON .)
    STRING          reduce using rule 79 (Stm -> NAME COLON .)
    CHARACTER       reduce using rule 79 (Stm -> NAME COLON .)
    DECIMAL         reduce using rule 79 (Stm -> NAME COLON .)
    CHAR            reduce using rule 79 (Stm -> NAME COLON .)
    INT             reduce using rule 79 (Stm -> NAME COLON .)
    FLOAT           reduce using rule 79 (Stm -> NAME COLON .)
    DOUBLE          reduce using rule 79 (Stm -> NAME COLON .)
    VOID            reduce using rule 79 (Stm -> NAME COLON .)
    R_CURLY         reduce using rule 79 (Stm -> NAME COLON .)
    CASE            reduce using rule 79 (Stm -> NAME COLON .)
    DEFAULT         reduce using rule 79 (Stm -> NAME COLON .)


state 231

    (80) Stm -> IF L_PAR . Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> IF L_PAR . Expr R_PAR Stm
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Expr                           shift and go to state 289
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 232

    (92) Normal_Stm -> Expr SEMICOLON .

    PRINTF          reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    SCANF           reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    NAME            reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    IF              reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    WHILE           reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    FOR             reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    DO              reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    SWITCH          reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    GOTO            reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    BREAK           reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    CONTINUE        reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    RETURN          reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    SEMICOLON       reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    EXTERN          reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    STATIC          reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    REGISTER        reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    AUTO            reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    VOLATILE        reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    CONST           reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    L_CURLY         reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    STRUCT          reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    UNION           reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    ENUM            reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    SIGNED          reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    UNSIGNED        reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    NOT             reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    NOT_B           reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    UMINUS          reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    MULTIPLY        reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    AND_B           reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    PLUSPLUS        reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    MINUSMINUS      reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    L_PAR           reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    SIZEOF          reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    INTEGER         reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    STRING          reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    CHARACTER       reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    DECIMAL         reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    CHAR            reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    INT             reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    FLOAT           reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    DOUBLE          reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    VOID            reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    R_CURLY         reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    CASE            reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    DEFAULT         reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)
    ELSE            reduce using rule 92 (Normal_Stm -> Expr SEMICOLON .)


state 233

    (82) Stm -> WHILE L_PAR . Expr R_PAR Stm
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Expr                           shift and go to state 290
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 234

    (83) Stm -> FOR L_PAR . Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (98) Arg -> . Expr
    (99) Arg -> . empty
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (174) empty -> .
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    SEMICOLON       reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Arg                            shift and go to state 291
    Expr                           shift and go to state 292
    empty                          shift and go to state 293
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 235

    (89) Normal_Stm -> DO Stm . WHILE L_PAR Expr R_PAR

    WHILE           shift and go to state 294


state 236

    (90) Normal_Stm -> SWITCH L_PAR . Expr R_PAR L_CURLY Case_Stms R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Expr                           shift and go to state 295
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 237

    (93) Normal_Stm -> GOTO NAME . SEMICOLON

    SEMICOLON       shift and go to state 296


state 238

    (94) Normal_Stm -> BREAK SEMICOLON .

    PRINTF          reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    SCANF           reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    NAME            reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    IF              reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    WHILE           reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    FOR             reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    DO              reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    SWITCH          reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    GOTO            reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    BREAK           reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    RETURN          reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    EXTERN          reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    STATIC          reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    REGISTER        reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    AUTO            reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    VOLATILE        reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    CONST           reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    L_CURLY         reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    STRUCT          reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    UNION           reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    ENUM            reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    SIGNED          reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    UNSIGNED        reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    NOT             reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    NOT_B           reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    UMINUS          reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    MULTIPLY        reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    AND_B           reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    PLUSPLUS        reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    MINUSMINUS      reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    L_PAR           reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    SIZEOF          reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    INTEGER         reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    STRING          reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    CHARACTER       reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    DECIMAL         reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    CHAR            reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    INT             reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    DOUBLE          reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    VOID            reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    R_CURLY         reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    CASE            reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    DEFAULT         reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)
    ELSE            reduce using rule 94 (Normal_Stm -> BREAK SEMICOLON .)


state 239

    (95) Normal_Stm -> CONTINUE SEMICOLON .

    PRINTF          reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    SCANF           reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    NAME            reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    IF              reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    DO              reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    SWITCH          reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    GOTO            reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    EXTERN          reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    STATIC          reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    REGISTER        reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    AUTO            reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    VOLATILE        reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    CONST           reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    L_CURLY         reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    STRUCT          reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    UNION           reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    ENUM            reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    SIGNED          reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    UNSIGNED        reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    NOT             reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    NOT_B           reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    UMINUS          reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    MULTIPLY        reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    AND_B           reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    PLUSPLUS        reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    MINUSMINUS      reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    L_PAR           reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    SIZEOF          reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    INTEGER         reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    STRING          reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    CHARACTER       reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    DECIMAL         reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    CHAR            reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    INT             reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    DOUBLE          reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    R_CURLY         reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    CASE            reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    DEFAULT         reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 95 (Normal_Stm -> CONTINUE SEMICOLON .)


state 240

    (96) Normal_Stm -> RETURN Expr . SEMICOLON
    (106) Expr -> Expr . COMMA Op_Assign

    SEMICOLON       shift and go to state 297
    COMMA           shift and go to state 180


state 241

    (14) Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .

    STRUCT          reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    UNION           reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    ENUM            reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    TYPEDEF         reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    NAME            reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    EXTERN          reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    STATIC          reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    REGISTER        reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    AUTO            reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    VOLATILE        reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    CONST           reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    SIGNED          reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    UNSIGNED        reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    CHAR            reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    INT             reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    FLOAT           reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    DOUBLE          reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    VOID            reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)
    $end            reduce using rule 14 (Func_Decl -> Func_ID L_PAR Id_List R_PAR Struct_Def Block .)


state 242

    (27) Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .

    STRUCT          reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    UNION           reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    ENUM            reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    TYPEDEF         reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    NAME            reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    EXTERN          reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    STATIC          reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    REGISTER        reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    AUTO            reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    VOLATILE        reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    CONST           reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    SIGNED          reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    UNSIGNED        reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    CHAR            reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    INT             reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    FLOAT           reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    DOUBLE          reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    VOID            reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    $end            reduce using rule 27 (Struct_Decl -> STRUCT NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)


state 243

    (28) Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .

    STRUCT          reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    UNION           reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    ENUM            reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    TYPEDEF         reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    NAME            reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    EXTERN          reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    STATIC          reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    REGISTER        reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    AUTO            reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    VOLATILE        reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    CONST           reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    SIGNED          reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    UNSIGNED        reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    CHAR            reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    INT             reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    FLOAT           reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    DOUBLE          reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    VOID            reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)
    $end            reduce using rule 28 (Union_Decl -> UNION NAME L_CURLY Struct_Def R_CURLY SEMICOLON .)


state 244

    (52) Enum_Val -> NAME ASSIGN INTEGER .

    COMMA           reduce using rule 52 (Enum_Val -> NAME ASSIGN INTEGER .)
    R_CURLY         reduce using rule 52 (Enum_Val -> NAME ASSIGN INTEGER .)


state 245

    (48) Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .

    STRUCT          reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    UNION           reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    ENUM            reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    TYPEDEF         reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    NAME            reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    EXTERN          reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    STATIC          reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    REGISTER        reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    AUTO            reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    VOLATILE        reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    CONST           reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    SIGNED          reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    UNSIGNED        reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    CHAR            reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    INT             reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    FLOAT           reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    DOUBLE          reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    VOID            reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)
    $end            reduce using rule 48 (Enum_Decl -> ENUM NAME L_CURLY Enum_Def R_CURLY SEMICOLON .)


state 246

    (49) Enum_Def -> Enum_Val COMMA Enum_Def .

    R_CURLY         reduce using rule 49 (Enum_Def -> Enum_Val COMMA Enum_Def .)


state 247

    (106) Expr -> Expr COMMA Op_Assign .

    R_BRACKET       reduce using rule 106 (Expr -> Expr COMMA Op_Assign .)
    COMMA           reduce using rule 106 (Expr -> Expr COMMA Op_Assign .)
    SEMICOLON       reduce using rule 106 (Expr -> Expr COMMA Op_Assign .)
    R_PAR           reduce using rule 106 (Expr -> Expr COMMA Op_Assign .)


state 248

    (108) Op_Assign -> Op_If ASSIGN Op_Assign .

    R_BRACKET       reduce using rule 108 (Op_Assign -> Op_If ASSIGN Op_Assign .)
    COMMA           reduce using rule 108 (Op_Assign -> Op_If ASSIGN Op_Assign .)
    SEMICOLON       reduce using rule 108 (Op_Assign -> Op_If ASSIGN Op_Assign .)
    R_PAR           reduce using rule 108 (Op_Assign -> Op_If ASSIGN Op_Assign .)


state 249

    (109) Op_Assign -> Op_If APLUS Op_Assign .

    R_BRACKET       reduce using rule 109 (Op_Assign -> Op_If APLUS Op_Assign .)
    COMMA           reduce using rule 109 (Op_Assign -> Op_If APLUS Op_Assign .)
    SEMICOLON       reduce using rule 109 (Op_Assign -> Op_If APLUS Op_Assign .)
    R_PAR           reduce using rule 109 (Op_Assign -> Op_If APLUS Op_Assign .)


state 250

    (110) Op_Assign -> Op_If AMINUS Op_Assign .

    R_BRACKET       reduce using rule 110 (Op_Assign -> Op_If AMINUS Op_Assign .)
    COMMA           reduce using rule 110 (Op_Assign -> Op_If AMINUS Op_Assign .)
    SEMICOLON       reduce using rule 110 (Op_Assign -> Op_If AMINUS Op_Assign .)
    R_PAR           reduce using rule 110 (Op_Assign -> Op_If AMINUS Op_Assign .)


state 251

    (111) Op_Assign -> Op_If AMULTIPLY Op_Assign .

    R_BRACKET       reduce using rule 111 (Op_Assign -> Op_If AMULTIPLY Op_Assign .)
    COMMA           reduce using rule 111 (Op_Assign -> Op_If AMULTIPLY Op_Assign .)
    SEMICOLON       reduce using rule 111 (Op_Assign -> Op_If AMULTIPLY Op_Assign .)
    R_PAR           reduce using rule 111 (Op_Assign -> Op_If AMULTIPLY Op_Assign .)


state 252

    (112) Op_Assign -> Op_If ADIVIDE Op_Assign .

    R_BRACKET       reduce using rule 112 (Op_Assign -> Op_If ADIVIDE Op_Assign .)
    COMMA           reduce using rule 112 (Op_Assign -> Op_If ADIVIDE Op_Assign .)
    SEMICOLON       reduce using rule 112 (Op_Assign -> Op_If ADIVIDE Op_Assign .)
    R_PAR           reduce using rule 112 (Op_Assign -> Op_If ADIVIDE Op_Assign .)


state 253

    (113) Op_Assign -> Op_If AXOR Op_Assign .

    R_BRACKET       reduce using rule 113 (Op_Assign -> Op_If AXOR Op_Assign .)
    COMMA           reduce using rule 113 (Op_Assign -> Op_If AXOR Op_Assign .)
    SEMICOLON       reduce using rule 113 (Op_Assign -> Op_If AXOR Op_Assign .)
    R_PAR           reduce using rule 113 (Op_Assign -> Op_If AXOR Op_Assign .)


state 254

    (114) Op_Assign -> Op_If AAND Op_Assign .

    R_BRACKET       reduce using rule 114 (Op_Assign -> Op_If AAND Op_Assign .)
    COMMA           reduce using rule 114 (Op_Assign -> Op_If AAND Op_Assign .)
    SEMICOLON       reduce using rule 114 (Op_Assign -> Op_If AAND Op_Assign .)
    R_PAR           reduce using rule 114 (Op_Assign -> Op_If AAND Op_Assign .)


state 255

    (115) Op_Assign -> Op_If AOR Op_Assign .

    R_BRACKET       reduce using rule 115 (Op_Assign -> Op_If AOR Op_Assign .)
    COMMA           reduce using rule 115 (Op_Assign -> Op_If AOR Op_Assign .)
    SEMICOLON       reduce using rule 115 (Op_Assign -> Op_If AOR Op_Assign .)
    R_PAR           reduce using rule 115 (Op_Assign -> Op_If AOR Op_Assign .)


state 256

    (116) Op_Assign -> Op_If ASHIFT_R Op_Assign .

    R_BRACKET       reduce using rule 116 (Op_Assign -> Op_If ASHIFT_R Op_Assign .)
    COMMA           reduce using rule 116 (Op_Assign -> Op_If ASHIFT_R Op_Assign .)
    SEMICOLON       reduce using rule 116 (Op_Assign -> Op_If ASHIFT_R Op_Assign .)
    R_PAR           reduce using rule 116 (Op_Assign -> Op_If ASHIFT_R Op_Assign .)


state 257

    (117) Op_Assign -> Op_If ASHIFT_L Op_Assign .

    R_BRACKET       reduce using rule 117 (Op_Assign -> Op_If ASHIFT_L Op_Assign .)
    COMMA           reduce using rule 117 (Op_Assign -> Op_If ASHIFT_L Op_Assign .)
    SEMICOLON       reduce using rule 117 (Op_Assign -> Op_If ASHIFT_L Op_Assign .)
    R_PAR           reduce using rule 117 (Op_Assign -> Op_If ASHIFT_L Op_Assign .)


state 258

    (119) Op_If -> Op_Or QUESTION Op_If . COLON Op_If

    COLON           shift and go to state 298


state 259

    (121) Op_Or -> Op_Or OR Op_And .
    (123) Op_And -> Op_And . AND Op_BinOR

    QUESTION        reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    OR              reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    ASSIGN          reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    APLUS           reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    AMINUS          reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    AMULTIPLY       reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    ADIVIDE         reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    AXOR            reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    AAND            reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    AOR             reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    ASHIFT_R        reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    ASHIFT_L        reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    R_BRACKET       reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    COMMA           reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    SEMICOLON       reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    R_PAR           reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    COLON           reduce using rule 121 (Op_Or -> Op_Or OR Op_And .)
    AND             shift and go to state 193


state 260

    (123) Op_And -> Op_And AND Op_BinOR .
    (125) Op_BinOR -> Op_BinOR . OR_B Op_BinXOR

    AND             reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    QUESTION        reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    OR              reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    ASSIGN          reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    APLUS           reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    AMINUS          reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    AMULTIPLY       reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    ADIVIDE         reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    AXOR            reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    AAND            reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    AOR             reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    ASHIFT_R        reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    ASHIFT_L        reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    R_BRACKET       reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    COMMA           reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    SEMICOLON       reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    R_PAR           reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    COLON           reduce using rule 123 (Op_And -> Op_And AND Op_BinOR .)
    OR_B            shift and go to state 194


state 261

    (125) Op_BinOR -> Op_BinOR OR_B Op_BinXOR .
    (127) Op_BinXOR -> Op_BinXOR . XOR_B Op_BinAND

    OR_B            reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    AND             reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    QUESTION        reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    OR              reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    ASSIGN          reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    APLUS           reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    AMINUS          reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    AMULTIPLY       reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    ADIVIDE         reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    AXOR            reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    AAND            reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    AOR             reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    ASHIFT_R        reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    ASHIFT_L        reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    R_BRACKET       reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    COMMA           reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    SEMICOLON       reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    R_PAR           reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    COLON           reduce using rule 125 (Op_BinOR -> Op_BinOR OR_B Op_BinXOR .)
    XOR_B           shift and go to state 195


state 262

    (127) Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .
    (129) Op_BinAND -> Op_BinAND . AND_B Op_Equate

    XOR_B           reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    OR_B            reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    AND             reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    QUESTION        reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    OR              reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    ASSIGN          reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    APLUS           reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    AMINUS          reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    AMULTIPLY       reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    ADIVIDE         reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    AXOR            reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    AAND            reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    AOR             reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    ASHIFT_R        reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    ASHIFT_L        reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    R_BRACKET       reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    COMMA           reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    SEMICOLON       reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    R_PAR           reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    COLON           reduce using rule 127 (Op_BinXOR -> Op_BinXOR XOR_B Op_BinAND .)
    AND_B           shift and go to state 196


state 263

    (129) Op_BinAND -> Op_BinAND AND_B Op_Equate .
    (131) Op_Equate -> Op_Equate . EQUAL Op_Compare
    (132) Op_Equate -> Op_Equate . NOT_EQUAL Op_Compare

    AND_B           reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    XOR_B           reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    OR_B            reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    AND             reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    QUESTION        reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    OR              reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    ASSIGN          reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    APLUS           reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    AMINUS          reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    AMULTIPLY       reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    ADIVIDE         reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    AXOR            reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    AAND            reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    AOR             reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    ASHIFT_R        reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    ASHIFT_L        reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    R_BRACKET       reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    COMMA           reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    SEMICOLON       reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    R_PAR           reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    COLON           reduce using rule 129 (Op_BinAND -> Op_BinAND AND_B Op_Equate .)
    EQUAL           shift and go to state 198
    NOT_EQUAL       shift and go to state 199


state 264

    (131) Op_Equate -> Op_Equate EQUAL Op_Compare .
    (134) Op_Compare -> Op_Compare . LESS Op_Shift
    (135) Op_Compare -> Op_Compare . GREATER Op_Shift
    (136) Op_Compare -> Op_Compare . LESS_EQUAL Op_Shift
    (137) Op_Compare -> Op_Compare . GREATER_EQUAL Op_Shift

    EQUAL           reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    NOT_EQUAL       reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    AND_B           reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    XOR_B           reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    OR_B            reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    AND             reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    QUESTION        reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    OR              reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    ASSIGN          reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    APLUS           reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    AMINUS          reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    AMULTIPLY       reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    ADIVIDE         reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    AXOR            reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    AAND            reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    AOR             reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    ASHIFT_R        reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    ASHIFT_L        reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    R_BRACKET       reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    COMMA           reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    SEMICOLON       reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    R_PAR           reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    COLON           reduce using rule 131 (Op_Equate -> Op_Equate EQUAL Op_Compare .)
    LESS            shift and go to state 200
    GREATER         shift and go to state 201
    LESS_EQUAL      shift and go to state 202
    GREATER_EQUAL   shift and go to state 203


state 265

    (132) Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .
    (134) Op_Compare -> Op_Compare . LESS Op_Shift
    (135) Op_Compare -> Op_Compare . GREATER Op_Shift
    (136) Op_Compare -> Op_Compare . LESS_EQUAL Op_Shift
    (137) Op_Compare -> Op_Compare . GREATER_EQUAL Op_Shift

    EQUAL           reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    NOT_EQUAL       reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    AND_B           reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    XOR_B           reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    OR_B            reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    AND             reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    QUESTION        reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    OR              reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    ASSIGN          reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    APLUS           reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    AMINUS          reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    AMULTIPLY       reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    ADIVIDE         reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    AXOR            reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    AAND            reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    AOR             reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    ASHIFT_R        reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    ASHIFT_L        reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    R_BRACKET       reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    COMMA           reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    SEMICOLON       reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    R_PAR           reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    COLON           reduce using rule 132 (Op_Equate -> Op_Equate NOT_EQUAL Op_Compare .)
    LESS            shift and go to state 200
    GREATER         shift and go to state 201
    LESS_EQUAL      shift and go to state 202
    GREATER_EQUAL   shift and go to state 203


state 266

    (134) Op_Compare -> Op_Compare LESS Op_Shift .
    (139) Op_Shift -> Op_Shift . SHIFT_L Op_Add
    (140) Op_Shift -> Op_Shift . SHIFT_R Op_Add

    LESS            reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    GREATER         reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    LESS_EQUAL      reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    GREATER_EQUAL   reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    EQUAL           reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    NOT_EQUAL       reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    AND_B           reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    XOR_B           reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    OR_B            reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    AND             reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    QUESTION        reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    OR              reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    ASSIGN          reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    APLUS           reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    AMINUS          reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    AMULTIPLY       reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    ADIVIDE         reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    AXOR            reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    AAND            reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    AOR             reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    ASHIFT_R        reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    ASHIFT_L        reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    R_BRACKET       reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    COMMA           reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    SEMICOLON       reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    R_PAR           reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    COLON           reduce using rule 134 (Op_Compare -> Op_Compare LESS Op_Shift .)
    SHIFT_L         shift and go to state 204
    SHIFT_R         shift and go to state 205


state 267

    (135) Op_Compare -> Op_Compare GREATER Op_Shift .
    (139) Op_Shift -> Op_Shift . SHIFT_L Op_Add
    (140) Op_Shift -> Op_Shift . SHIFT_R Op_Add

    LESS            reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    GREATER         reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    LESS_EQUAL      reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    GREATER_EQUAL   reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    EQUAL           reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    NOT_EQUAL       reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    AND_B           reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    XOR_B           reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    OR_B            reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    AND             reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    QUESTION        reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    OR              reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    ASSIGN          reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    APLUS           reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    AMINUS          reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    AMULTIPLY       reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    ADIVIDE         reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    AXOR            reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    AAND            reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    AOR             reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    ASHIFT_R        reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    ASHIFT_L        reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    R_BRACKET       reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    COMMA           reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    SEMICOLON       reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    R_PAR           reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    COLON           reduce using rule 135 (Op_Compare -> Op_Compare GREATER Op_Shift .)
    SHIFT_L         shift and go to state 204
    SHIFT_R         shift and go to state 205


state 268

    (136) Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .
    (139) Op_Shift -> Op_Shift . SHIFT_L Op_Add
    (140) Op_Shift -> Op_Shift . SHIFT_R Op_Add

    LESS            reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    GREATER         reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    LESS_EQUAL      reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    GREATER_EQUAL   reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    EQUAL           reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    NOT_EQUAL       reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    AND_B           reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    XOR_B           reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    OR_B            reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    AND             reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    QUESTION        reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    OR              reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    ASSIGN          reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    APLUS           reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    AMINUS          reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    AMULTIPLY       reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    ADIVIDE         reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    AXOR            reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    AAND            reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    AOR             reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    ASHIFT_R        reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    ASHIFT_L        reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    R_BRACKET       reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    COMMA           reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    SEMICOLON       reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    R_PAR           reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    COLON           reduce using rule 136 (Op_Compare -> Op_Compare LESS_EQUAL Op_Shift .)
    SHIFT_L         shift and go to state 204
    SHIFT_R         shift and go to state 205


state 269

    (137) Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .
    (139) Op_Shift -> Op_Shift . SHIFT_L Op_Add
    (140) Op_Shift -> Op_Shift . SHIFT_R Op_Add

    LESS            reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    GREATER         reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    LESS_EQUAL      reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    GREATER_EQUAL   reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    EQUAL           reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    NOT_EQUAL       reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    AND_B           reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    XOR_B           reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    OR_B            reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    AND             reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    QUESTION        reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    OR              reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    ASSIGN          reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    APLUS           reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    AMINUS          reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    AMULTIPLY       reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    ADIVIDE         reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    AXOR            reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    AAND            reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    AOR             reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    ASHIFT_R        reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    ASHIFT_L        reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    R_BRACKET       reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    COMMA           reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    SEMICOLON       reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    R_PAR           reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    COLON           reduce using rule 137 (Op_Compare -> Op_Compare GREATER_EQUAL Op_Shift .)
    SHIFT_L         shift and go to state 204
    SHIFT_R         shift and go to state 205


state 270

    (139) Op_Shift -> Op_Shift SHIFT_L Op_Add .
    (142) Op_Add -> Op_Add . PLUS Op_Mult
    (143) Op_Add -> Op_Add . MINUS Op_Mult

    SHIFT_L         reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    SHIFT_R         reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    LESS            reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    GREATER         reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    LESS_EQUAL      reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    GREATER_EQUAL   reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    EQUAL           reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    NOT_EQUAL       reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    AND_B           reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    XOR_B           reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    OR_B            reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    AND             reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    QUESTION        reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    OR              reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    ASSIGN          reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    APLUS           reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    AMINUS          reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    AMULTIPLY       reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    ADIVIDE         reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    AXOR            reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    AAND            reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    AOR             reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    ASHIFT_R        reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    ASHIFT_L        reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    R_BRACKET       reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    COMMA           reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    SEMICOLON       reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    R_PAR           reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    COLON           reduce using rule 139 (Op_Shift -> Op_Shift SHIFT_L Op_Add .)
    PLUS            shift and go to state 206
    MINUS           shift and go to state 207


state 271

    (140) Op_Shift -> Op_Shift SHIFT_R Op_Add .
    (142) Op_Add -> Op_Add . PLUS Op_Mult
    (143) Op_Add -> Op_Add . MINUS Op_Mult

    SHIFT_L         reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    SHIFT_R         reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    LESS            reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    GREATER         reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    LESS_EQUAL      reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    GREATER_EQUAL   reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    EQUAL           reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    NOT_EQUAL       reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    AND_B           reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    XOR_B           reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    OR_B            reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    AND             reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    QUESTION        reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    OR              reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    ASSIGN          reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    APLUS           reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    AMINUS          reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    AMULTIPLY       reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    ADIVIDE         reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    AXOR            reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    AAND            reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    AOR             reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    ASHIFT_R        reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    ASHIFT_L        reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    R_BRACKET       reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    COMMA           reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    SEMICOLON       reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    R_PAR           reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    COLON           reduce using rule 140 (Op_Shift -> Op_Shift SHIFT_R Op_Add .)
    PLUS            shift and go to state 206
    MINUS           shift and go to state 207


state 272

    (142) Op_Add -> Op_Add PLUS Op_Mult .
    (145) Op_Mult -> Op_Mult . MULTIPLY Op_Unary
    (146) Op_Mult -> Op_Mult . DIVIDE Op_Unary
    (147) Op_Mult -> Op_Mult . REMAINDER Op_Unary

    PLUS            reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    MINUS           reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    SHIFT_L         reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    SHIFT_R         reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    LESS            reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    GREATER         reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    LESS_EQUAL      reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    GREATER_EQUAL   reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    EQUAL           reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    NOT_EQUAL       reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    AND_B           reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    XOR_B           reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    OR_B            reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    AND             reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    QUESTION        reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    OR              reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    ASSIGN          reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    APLUS           reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    AMINUS          reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    AMULTIPLY       reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    ADIVIDE         reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    AXOR            reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    AAND            reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    AOR             reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    ASHIFT_R        reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    ASHIFT_L        reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    R_BRACKET       reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    COMMA           reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    SEMICOLON       reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    R_PAR           reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    COLON           reduce using rule 142 (Op_Add -> Op_Add PLUS Op_Mult .)
    MULTIPLY        shift and go to state 208
    DIVIDE          shift and go to state 209
    REMAINDER       shift and go to state 210


state 273

    (143) Op_Add -> Op_Add MINUS Op_Mult .
    (145) Op_Mult -> Op_Mult . MULTIPLY Op_Unary
    (146) Op_Mult -> Op_Mult . DIVIDE Op_Unary
    (147) Op_Mult -> Op_Mult . REMAINDER Op_Unary

    PLUS            reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    MINUS           reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    SHIFT_L         reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    SHIFT_R         reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    LESS            reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    GREATER         reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    LESS_EQUAL      reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    GREATER_EQUAL   reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    EQUAL           reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    NOT_EQUAL       reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    AND_B           reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    XOR_B           reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    OR_B            reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    AND             reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    QUESTION        reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    OR              reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    ASSIGN          reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    APLUS           reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    AMINUS          reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    AMULTIPLY       reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    ADIVIDE         reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    AXOR            reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    AAND            reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    AOR             reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    ASHIFT_R        reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    ASHIFT_L        reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    R_BRACKET       reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    COMMA           reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    SEMICOLON       reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    R_PAR           reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    COLON           reduce using rule 143 (Op_Add -> Op_Add MINUS Op_Mult .)
    MULTIPLY        shift and go to state 208
    DIVIDE          shift and go to state 209
    REMAINDER       shift and go to state 210


state 274

    (145) Op_Mult -> Op_Mult MULTIPLY Op_Unary .

    MULTIPLY        reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    DIVIDE          reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    REMAINDER       reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    PLUS            reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    MINUS           reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    SHIFT_L         reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    SHIFT_R         reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    LESS            reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    GREATER         reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    LESS_EQUAL      reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    GREATER_EQUAL   reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    EQUAL           reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    NOT_EQUAL       reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    AND_B           reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    XOR_B           reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    OR_B            reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    AND             reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    QUESTION        reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    OR              reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    ASSIGN          reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    APLUS           reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    AMINUS          reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    AMULTIPLY       reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    ADIVIDE         reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    AXOR            reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    AAND            reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    AOR             reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    ASHIFT_R        reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    ASHIFT_L        reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    R_BRACKET       reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    COMMA           reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    SEMICOLON       reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    R_PAR           reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)
    COLON           reduce using rule 145 (Op_Mult -> Op_Mult MULTIPLY Op_Unary .)


state 275

    (146) Op_Mult -> Op_Mult DIVIDE Op_Unary .

    MULTIPLY        reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    DIVIDE          reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    REMAINDER       reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    PLUS            reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    MINUS           reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    SHIFT_L         reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    SHIFT_R         reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    LESS            reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    GREATER         reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    LESS_EQUAL      reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    GREATER_EQUAL   reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    EQUAL           reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    NOT_EQUAL       reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    AND_B           reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    XOR_B           reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    OR_B            reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    AND             reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    QUESTION        reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    OR              reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    ASSIGN          reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    APLUS           reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    AMINUS          reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    AMULTIPLY       reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    ADIVIDE         reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    AXOR            reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    AAND            reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    AOR             reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    ASHIFT_R        reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    ASHIFT_L        reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    R_BRACKET       reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    COMMA           reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    SEMICOLON       reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    R_PAR           reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)
    COLON           reduce using rule 146 (Op_Mult -> Op_Mult DIVIDE Op_Unary .)


state 276

    (147) Op_Mult -> Op_Mult REMAINDER Op_Unary .

    MULTIPLY        reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    DIVIDE          reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    REMAINDER       reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    PLUS            reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    MINUS           reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    SHIFT_L         reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    SHIFT_R         reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    LESS            reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    GREATER         reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    LESS_EQUAL      reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    GREATER_EQUAL   reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    EQUAL           reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    NOT_EQUAL       reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    AND_B           reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    XOR_B           reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    OR_B            reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    AND             reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    QUESTION        reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    OR              reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    ASSIGN          reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    APLUS           reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    AMINUS          reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    AMULTIPLY       reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    ADIVIDE         reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    AXOR            reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    AAND            reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    AOR             reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    ASHIFT_R        reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    ASHIFT_L        reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    R_BRACKET       reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    COMMA           reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    SEMICOLON       reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    R_PAR           reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)
    COLON           reduce using rule 147 (Op_Mult -> Op_Mult REMAINDER Op_Unary .)


state 277

    (162) Op_Pointer -> Op_Pointer DOT Value .

    PLUSPLUS        reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    MINUSMINUS      reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    DOT             reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    ACCESS          reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    L_BRACKET       reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    MULTIPLY        reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    DIVIDE          reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    REMAINDER       reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    PLUS            reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    MINUS           reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    SHIFT_L         reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    SHIFT_R         reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    LESS            reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    GREATER         reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    LESS_EQUAL      reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    GREATER_EQUAL   reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    EQUAL           reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    NOT_EQUAL       reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    AND_B           reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    XOR_B           reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    OR_B            reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    AND             reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    QUESTION        reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    OR              reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    ASSIGN          reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    APLUS           reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    AMINUS          reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    AMULTIPLY       reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    ADIVIDE         reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    AXOR            reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    AAND            reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    AOR             reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    ASHIFT_R        reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    ASHIFT_L        reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    R_BRACKET       reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    COMMA           reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    SEMICOLON       reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    R_PAR           reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    COLON           reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    INTEGER         reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    STRING          reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    CHARACTER       reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    DECIMAL         reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    NAME            reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)
    L_PAR           reduce using rule 162 (Op_Pointer -> Op_Pointer DOT Value .)


state 278

    (173) Value -> L_PAR . Expr R_PAR
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Expr                           shift and go to state 223
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 279

    (163) Op_Pointer -> Op_Pointer ACCESS Value .

    PLUSPLUS        reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    MINUSMINUS      reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    DOT             reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    ACCESS          reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    L_BRACKET       reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    MULTIPLY        reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    DIVIDE          reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    REMAINDER       reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    PLUS            reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    MINUS           reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    SHIFT_L         reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    SHIFT_R         reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    LESS            reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    GREATER         reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    LESS_EQUAL      reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    GREATER_EQUAL   reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    EQUAL           reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    NOT_EQUAL       reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    AND_B           reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    XOR_B           reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    OR_B            reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    AND             reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    QUESTION        reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    OR              reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    ASSIGN          reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    APLUS           reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    AMINUS          reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    AMULTIPLY       reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    ADIVIDE         reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    AXOR            reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    AAND            reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    AOR             reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    ASHIFT_R        reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    ASHIFT_L        reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    R_BRACKET       reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    COMMA           reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    SEMICOLON       reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    R_PAR           reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    COLON           reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    INTEGER         reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    STRING          reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    CHARACTER       reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    DECIMAL         reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    NAME            reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)
    L_PAR           reduce using rule 163 (Op_Pointer -> Op_Pointer ACCESS Value .)


state 280

    (164) Op_Pointer -> Op_Pointer L_BRACKET Expr . R_BRACKET
    (106) Expr -> Expr . COMMA Op_Assign

    R_BRACKET       shift and go to state 299
    COMMA           shift and go to state 180


state 281

    (158) Op_Unary -> L_PAR Type R_PAR . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Unary                       shift and go to state 300
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 282

    (173) Value -> L_PAR Expr R_PAR .

    PLUSPLUS        reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    MINUSMINUS      reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    DOT             reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    ACCESS          reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    L_BRACKET       reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    MULTIPLY        reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    DIVIDE          reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    REMAINDER       reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    PLUS            reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    MINUS           reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    SHIFT_L         reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    SHIFT_R         reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    LESS            reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    GREATER         reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    LESS_EQUAL      reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    GREATER_EQUAL   reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    EQUAL           reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    NOT_EQUAL       reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    AND_B           reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    XOR_B           reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    OR_B            reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    AND             reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    QUESTION        reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    OR              reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    ASSIGN          reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    APLUS           reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    AMINUS          reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    AMULTIPLY       reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    ADIVIDE         reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    AXOR            reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    AAND            reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    AOR             reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    ASHIFT_R        reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    ASHIFT_L        reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    R_BRACKET       reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    COMMA           reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    SEMICOLON       reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    R_PAR           reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    COLON           reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    INTEGER         reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    STRING          reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    CHARACTER       reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    DECIMAL         reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    NAME            reduce using rule 173 (Value -> L_PAR Expr R_PAR .)
    L_PAR           reduce using rule 173 (Value -> L_PAR Expr R_PAR .)


state 283

    (159) Op_Unary -> SIZEOF L_PAR Type . R_PAR

    R_PAR           shift and go to state 301


state 284

    (160) Op_Unary -> SIZEOF L_PAR NAME . Pointers R_PAR
    (68) Pointers -> . MULTIPLY Pointers
    (69) Pointers -> . empty
    (174) empty -> .

    MULTIPLY        shift and go to state 47
    R_PAR           reduce using rule 174 (empty -> .)

    Pointers                       shift and go to state 302
    empty                          shift and go to state 48

state 285

    (171) Value -> NAME L_PAR Expr . R_PAR
    (106) Expr -> Expr . COMMA Op_Assign

    R_PAR           shift and go to state 303
    COMMA           shift and go to state 180


state 286

    (172) Value -> NAME L_PAR R_PAR .

    PLUSPLUS        reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    MINUSMINUS      reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    DOT             reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    ACCESS          reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    L_BRACKET       reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    MULTIPLY        reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    DIVIDE          reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    REMAINDER       reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    PLUS            reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    MINUS           reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    SHIFT_L         reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    SHIFT_R         reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    LESS            reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    GREATER         reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    LESS_EQUAL      reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    GREATER_EQUAL   reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    EQUAL           reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    NOT_EQUAL       reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    AND_B           reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    XOR_B           reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    OR_B            reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    AND             reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    QUESTION        reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    OR              reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    ASSIGN          reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    APLUS           reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    AMINUS          reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    AMULTIPLY       reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    ADIVIDE         reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    AXOR            reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    AAND            reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    AOR             reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    ASHIFT_R        reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    ASHIFT_L        reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    R_BRACKET       reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    COMMA           reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    SEMICOLON       reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    R_PAR           reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    COLON           reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    INTEGER         reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    STRING          reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    CHARACTER       reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    DECIMAL         reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    NAME            reduce using rule 172 (Value -> NAME L_PAR R_PAR .)
    L_PAR           reduce using rule 172 (Value -> NAME L_PAR R_PAR .)


state 287

    (70) Stm -> PRINTF L_PAR STRING . Printf_Params R_PAR SEMICOLON
    (71) Printf_Params -> . COMMA Printf_Param Printf_Params
    (72) Printf_Params -> . Printf_Param
    (73) Printf_Params -> . empty
    (74) Printf_Param -> . Op_Pointer
    (174) empty -> .
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    COMMA           shift and go to state 305
    R_PAR           reduce using rule 174 (empty -> .)
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132
    L_PAR           shift and go to state 278

    Printf_Params                  shift and go to state 304
    Printf_Param                   shift and go to state 306
    empty                          shift and go to state 307
    Op_Pointer                     shift and go to state 308
    Value                          shift and go to state 133

state 288

    (75) Stm -> SCANF L_PAR STRING . COMMA Scanf_Param R_PAR SEMICOLON

    COMMA           shift and go to state 309


state 289

    (80) Stm -> IF L_PAR Expr . R_PAR Then_Stm ELSE Stm
    (81) Stm -> IF L_PAR Expr . R_PAR Stm
    (106) Expr -> Expr . COMMA Op_Assign

    R_PAR           shift and go to state 310
    COMMA           shift and go to state 180


state 290

    (82) Stm -> WHILE L_PAR Expr . R_PAR Stm
    (106) Expr -> Expr . COMMA Op_Assign

    R_PAR           shift and go to state 311
    COMMA           shift and go to state 180


state 291

    (83) Stm -> FOR L_PAR Arg . SEMICOLON Arg SEMICOLON Arg R_PAR Stm

    SEMICOLON       shift and go to state 312


state 292

    (98) Arg -> Expr .
    (106) Expr -> Expr . COMMA Op_Assign

    SEMICOLON       reduce using rule 98 (Arg -> Expr .)
    R_PAR           reduce using rule 98 (Arg -> Expr .)
    COMMA           shift and go to state 180


state 293

    (99) Arg -> empty .

    SEMICOLON       reduce using rule 99 (Arg -> empty .)
    R_PAR           reduce using rule 99 (Arg -> empty .)


state 294

    (89) Normal_Stm -> DO Stm WHILE . L_PAR Expr R_PAR

    L_PAR           shift and go to state 313


state 295

    (90) Normal_Stm -> SWITCH L_PAR Expr . R_PAR L_CURLY Case_Stms R_CURLY
    (106) Expr -> Expr . COMMA Op_Assign

    R_PAR           shift and go to state 314
    COMMA           shift and go to state 180


state 296

    (93) Normal_Stm -> GOTO NAME SEMICOLON .

    PRINTF          reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    SCANF           reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    NAME            reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    IF              reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    WHILE           reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    FOR             reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    DO              reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    SWITCH          reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    GOTO            reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    BREAK           reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    CONTINUE        reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    RETURN          reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    SEMICOLON       reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    EXTERN          reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    STATIC          reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    REGISTER        reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    AUTO            reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    VOLATILE        reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    CONST           reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    L_CURLY         reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    STRUCT          reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    UNION           reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    ENUM            reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    SIGNED          reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    UNSIGNED        reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    NOT             reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    NOT_B           reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    UMINUS          reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    MULTIPLY        reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    AND_B           reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    PLUSPLUS        reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    MINUSMINUS      reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    L_PAR           reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    SIZEOF          reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    INTEGER         reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    STRING          reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    CHARACTER       reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    DECIMAL         reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    CHAR            reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    INT             reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    FLOAT           reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    DOUBLE          reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    VOID            reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    R_CURLY         reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    CASE            reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    DEFAULT         reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)
    ELSE            reduce using rule 93 (Normal_Stm -> GOTO NAME SEMICOLON .)


state 297

    (96) Normal_Stm -> RETURN Expr SEMICOLON .

    PRINTF          reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    SCANF           reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    NAME            reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    IF              reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    WHILE           reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    FOR             reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    DO              reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    SWITCH          reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    GOTO            reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    BREAK           reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    CONTINUE        reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    RETURN          reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    SEMICOLON       reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    EXTERN          reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    STATIC          reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    REGISTER        reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    AUTO            reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    VOLATILE        reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    CONST           reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    L_CURLY         reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    STRUCT          reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    UNION           reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    ENUM            reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    SIGNED          reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    UNSIGNED        reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    NOT             reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    NOT_B           reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    UMINUS          reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    MULTIPLY        reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    AND_B           reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    PLUSPLUS        reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    MINUSMINUS      reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    L_PAR           reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    SIZEOF          reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    INTEGER         reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    STRING          reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    CHARACTER       reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    DECIMAL         reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    CHAR            reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    INT             reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    FLOAT           reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    DOUBLE          reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    VOID            reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    R_CURLY         reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    CASE            reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    DEFAULT         reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)
    ELSE            reduce using rule 96 (Normal_Stm -> RETURN Expr SEMICOLON .)


state 298

    (119) Op_If -> Op_Or QUESTION Op_If COLON . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Op_Or                          shift and go to state 111
    Op_If                          shift and go to state 315
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 299

    (164) Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .

    PLUSPLUS        reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    MINUSMINUS      reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    DOT             reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    ACCESS          reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    L_BRACKET       reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    MULTIPLY        reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    DIVIDE          reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    REMAINDER       reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    PLUS            reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    MINUS           reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    SHIFT_L         reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    SHIFT_R         reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    LESS            reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    GREATER         reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    LESS_EQUAL      reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    GREATER_EQUAL   reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    EQUAL           reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    NOT_EQUAL       reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    AND_B           reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    XOR_B           reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    OR_B            reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    AND             reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    QUESTION        reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    OR              reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    ASSIGN          reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    APLUS           reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    AMINUS          reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    AMULTIPLY       reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    ADIVIDE         reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    AXOR            reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    AAND            reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    AOR             reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    ASHIFT_R        reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    ASHIFT_L        reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    R_BRACKET       reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    COMMA           reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    SEMICOLON       reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    R_PAR           reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    COLON           reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    INTEGER         reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    STRING          reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    CHARACTER       reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    DECIMAL         reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    NAME            reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)
    L_PAR           reduce using rule 164 (Op_Pointer -> Op_Pointer L_BRACKET Expr R_BRACKET .)


state 300

    (158) Op_Unary -> L_PAR Type R_PAR Op_Unary .

    MULTIPLY        reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    DIVIDE          reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    REMAINDER       reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    PLUS            reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    MINUS           reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    SHIFT_L         reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    SHIFT_R         reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    LESS            reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    GREATER         reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    LESS_EQUAL      reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    GREATER_EQUAL   reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    EQUAL           reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    NOT_EQUAL       reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    AND_B           reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    XOR_B           reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    OR_B            reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    AND             reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    QUESTION        reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    OR              reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    ASSIGN          reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    APLUS           reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    AMINUS          reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    AMULTIPLY       reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    ADIVIDE         reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    AXOR            reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    AAND            reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    AOR             reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    ASHIFT_R        reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    ASHIFT_L        reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    R_BRACKET       reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    COMMA           reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    SEMICOLON       reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    R_PAR           reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)
    COLON           reduce using rule 158 (Op_Unary -> L_PAR Type R_PAR Op_Unary .)


state 301

    (159) Op_Unary -> SIZEOF L_PAR Type R_PAR .

    MULTIPLY        reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    DIVIDE          reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    REMAINDER       reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    PLUS            reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    MINUS           reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    SHIFT_L         reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    SHIFT_R         reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    LESS            reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    GREATER         reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    LESS_EQUAL      reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    GREATER_EQUAL   reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    EQUAL           reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    NOT_EQUAL       reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    AND_B           reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    XOR_B           reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    OR_B            reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    AND             reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    QUESTION        reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    OR              reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    ASSIGN          reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    APLUS           reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    AMINUS          reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    AMULTIPLY       reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    ADIVIDE         reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    AXOR            reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    AAND            reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    AOR             reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    ASHIFT_R        reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    ASHIFT_L        reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    R_BRACKET       reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    COMMA           reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    SEMICOLON       reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    R_PAR           reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)
    COLON           reduce using rule 159 (Op_Unary -> SIZEOF L_PAR Type R_PAR .)


state 302

    (160) Op_Unary -> SIZEOF L_PAR NAME Pointers . R_PAR

    R_PAR           shift and go to state 316


state 303

    (171) Value -> NAME L_PAR Expr R_PAR .

    PLUSPLUS        reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    MINUSMINUS      reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    DOT             reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    ACCESS          reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    L_BRACKET       reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    MULTIPLY        reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    DIVIDE          reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    REMAINDER       reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    PLUS            reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    MINUS           reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    SHIFT_L         reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    SHIFT_R         reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    LESS            reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    GREATER         reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    LESS_EQUAL      reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    GREATER_EQUAL   reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    EQUAL           reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    NOT_EQUAL       reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    AND_B           reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    XOR_B           reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    OR_B            reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    AND             reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    QUESTION        reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    OR              reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    ASSIGN          reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    APLUS           reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    AMINUS          reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    AMULTIPLY       reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    ADIVIDE         reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    AXOR            reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    AAND            reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    AOR             reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    ASHIFT_R        reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    ASHIFT_L        reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    R_BRACKET       reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    COMMA           reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    SEMICOLON       reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    R_PAR           reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    COLON           reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    INTEGER         reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    STRING          reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    CHARACTER       reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    DECIMAL         reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    NAME            reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)
    L_PAR           reduce using rule 171 (Value -> NAME L_PAR Expr R_PAR .)


state 304

    (70) Stm -> PRINTF L_PAR STRING Printf_Params . R_PAR SEMICOLON

    R_PAR           shift and go to state 317


state 305

    (71) Printf_Params -> COMMA . Printf_Param Printf_Params
    (74) Printf_Param -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132
    L_PAR           shift and go to state 278

    Printf_Param                   shift and go to state 318
    Op_Pointer                     shift and go to state 308
    Value                          shift and go to state 133

state 306

    (72) Printf_Params -> Printf_Param .

    R_PAR           reduce using rule 72 (Printf_Params -> Printf_Param .)


state 307

    (73) Printf_Params -> empty .

    R_PAR           reduce using rule 73 (Printf_Params -> empty .)


state 308

    (74) Printf_Param -> Op_Pointer .
    (162) Op_Pointer -> Op_Pointer . DOT Value
    (163) Op_Pointer -> Op_Pointer . ACCESS Value
    (164) Op_Pointer -> Op_Pointer . L_BRACKET Expr R_BRACKET

    R_PAR           reduce using rule 74 (Printf_Param -> Op_Pointer .)
    COMMA           reduce using rule 74 (Printf_Param -> Op_Pointer .)
    INTEGER         reduce using rule 74 (Printf_Param -> Op_Pointer .)
    STRING          reduce using rule 74 (Printf_Param -> Op_Pointer .)
    CHARACTER       reduce using rule 74 (Printf_Param -> Op_Pointer .)
    DECIMAL         reduce using rule 74 (Printf_Param -> Op_Pointer .)
    NAME            reduce using rule 74 (Printf_Param -> Op_Pointer .)
    L_PAR           reduce using rule 74 (Printf_Param -> Op_Pointer .)
    DOT             shift and go to state 219
    ACCESS          shift and go to state 220
    L_BRACKET       shift and go to state 221


state 309

    (75) Stm -> SCANF L_PAR STRING COMMA . Scanf_Param R_PAR SEMICOLON
    (76) Scanf_Param -> . AND_B NAME
    (77) Scanf_Param -> . NAME

    AND_B           shift and go to state 320
    NAME            shift and go to state 321

    Scanf_Param                    shift and go to state 319

state 310

    (80) Stm -> IF L_PAR Expr R_PAR . Then_Stm ELSE Stm
    (81) Stm -> IF L_PAR Expr R_PAR . Stm
    (85) Then_Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Then_Stm
    (86) Then_Stm -> . WHILE L_PAR Expr R_PAR Then_Stm
    (87) Then_Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Then_Stm
    (88) Then_Stm -> . Normal_Stm
    (70) Stm -> . PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
    (75) Stm -> . SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
    (78) Stm -> . Var_Decl
    (79) Stm -> . NAME COLON
    (80) Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> . IF L_PAR Expr R_PAR Stm
    (82) Stm -> . WHILE L_PAR Expr R_PAR Stm
    (83) Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (84) Stm -> . Normal_Stm
    (89) Normal_Stm -> . DO Stm WHILE L_PAR Expr R_PAR
    (90) Normal_Stm -> . SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
    (91) Normal_Stm -> . Block
    (92) Normal_Stm -> . Expr SEMICOLON
    (93) Normal_Stm -> . GOTO NAME SEMICOLON
    (94) Normal_Stm -> . BREAK SEMICOLON
    (95) Normal_Stm -> . CONTINUE SEMICOLON
    (96) Normal_Stm -> . RETURN Expr SEMICOLON
    (97) Normal_Stm -> . SEMICOLON
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (103) Block -> . L_CURLY Stm_List R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (174) empty -> .
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    IF              shift and go to state 322
    WHILE           shift and go to state 325
    FOR             shift and go to state 326
    PRINTF          shift and go to state 145
    SCANF           shift and go to state 147
    NAME            shift and go to state 149
    DO              shift and go to state 155
    SWITCH          shift and go to state 156
    GOTO            shift and go to state 158
    BREAK           shift and go to state 159
    CONTINUE        shift and go to state 160
    RETURN          shift and go to state 161
    SEMICOLON       shift and go to state 146
    L_CURLY         shift and go to state 86
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137

    Expr                           shift and go to state 151
    Then_Stm                       shift and go to state 323
    Stm                            shift and go to state 324
    Normal_Stm                     shift and go to state 327
    Var_Decl                       shift and go to state 148
    Block                          shift and go to state 157
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Op_Assign                      shift and go to state 109
    Base                           shift and go to state 25
    Op_If                          shift and go to state 110
    Sign                           shift and go to state 26
    Op_Or                          shift and go to state 111
    empty                          shift and go to state 42
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 311

    (82) Stm -> WHILE L_PAR Expr R_PAR . Stm
    (70) Stm -> . PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
    (75) Stm -> . SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
    (78) Stm -> . Var_Decl
    (79) Stm -> . NAME COLON
    (80) Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> . IF L_PAR Expr R_PAR Stm
    (82) Stm -> . WHILE L_PAR Expr R_PAR Stm
    (83) Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (84) Stm -> . Normal_Stm
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (89) Normal_Stm -> . DO Stm WHILE L_PAR Expr R_PAR
    (90) Normal_Stm -> . SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
    (91) Normal_Stm -> . Block
    (92) Normal_Stm -> . Expr SEMICOLON
    (93) Normal_Stm -> . GOTO NAME SEMICOLON
    (94) Normal_Stm -> . BREAK SEMICOLON
    (95) Normal_Stm -> . CONTINUE SEMICOLON
    (96) Normal_Stm -> . RETURN Expr SEMICOLON
    (97) Normal_Stm -> . SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (103) Block -> . L_CURLY Stm_List R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (174) empty -> .
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    PRINTF          shift and go to state 145
    SCANF           shift and go to state 147
    NAME            shift and go to state 149
    IF              shift and go to state 150
    WHILE           shift and go to state 152
    FOR             shift and go to state 153
    DO              shift and go to state 155
    SWITCH          shift and go to state 156
    GOTO            shift and go to state 158
    BREAK           shift and go to state 159
    CONTINUE        shift and go to state 160
    RETURN          shift and go to state 161
    SEMICOLON       shift and go to state 146
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    L_CURLY         shift and go to state 86
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137

    Expr                           shift and go to state 151
    Stm                            shift and go to state 328
    Var_Decl                       shift and go to state 148
    Normal_Stm                     shift and go to state 154
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Block                          shift and go to state 157
    Base                           shift and go to state 25
    Op_Assign                      shift and go to state 109
    Sign                           shift and go to state 26
    Op_If                          shift and go to state 110
    empty                          shift and go to state 42
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 312

    (83) Stm -> FOR L_PAR Arg SEMICOLON . Arg SEMICOLON Arg R_PAR Stm
    (98) Arg -> . Expr
    (99) Arg -> . empty
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (174) empty -> .
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    SEMICOLON       reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Arg                            shift and go to state 329
    Expr                           shift and go to state 292
    empty                          shift and go to state 293
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 313

    (89) Normal_Stm -> DO Stm WHILE L_PAR . Expr R_PAR
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Expr                           shift and go to state 330
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 314

    (90) Normal_Stm -> SWITCH L_PAR Expr R_PAR . L_CURLY Case_Stms R_CURLY

    L_CURLY         shift and go to state 331


state 315

    (119) Op_If -> Op_Or QUESTION Op_If COLON Op_If .

    ASSIGN          reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    APLUS           reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    AMINUS          reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    AMULTIPLY       reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    ADIVIDE         reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    AXOR            reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    AAND            reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    AOR             reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    ASHIFT_R        reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    ASHIFT_L        reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    R_BRACKET       reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    COMMA           reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    SEMICOLON       reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    R_PAR           reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)
    COLON           reduce using rule 119 (Op_If -> Op_Or QUESTION Op_If COLON Op_If .)


state 316

    (160) Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .

    MULTIPLY        reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    DIVIDE          reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    REMAINDER       reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    PLUS            reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    MINUS           reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    SHIFT_L         reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    SHIFT_R         reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    LESS            reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    GREATER         reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    LESS_EQUAL      reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    GREATER_EQUAL   reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    EQUAL           reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    NOT_EQUAL       reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    AND_B           reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    XOR_B           reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    OR_B            reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    AND             reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    QUESTION        reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    OR              reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    ASSIGN          reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    APLUS           reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    AMINUS          reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    AMULTIPLY       reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    ADIVIDE         reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    AXOR            reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    AAND            reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    AOR             reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    ASHIFT_R        reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    ASHIFT_L        reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    R_BRACKET       reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    COMMA           reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    SEMICOLON       reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    R_PAR           reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)
    COLON           reduce using rule 160 (Op_Unary -> SIZEOF L_PAR NAME Pointers R_PAR .)


state 317

    (70) Stm -> PRINTF L_PAR STRING Printf_Params R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 332


state 318

    (71) Printf_Params -> COMMA Printf_Param . Printf_Params
    (71) Printf_Params -> . COMMA Printf_Param Printf_Params
    (72) Printf_Params -> . Printf_Param
    (73) Printf_Params -> . empty
    (74) Printf_Param -> . Op_Pointer
    (174) empty -> .
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    COMMA           shift and go to state 305
    R_PAR           reduce using rule 174 (empty -> .)
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132
    L_PAR           shift and go to state 278

    Printf_Param                   shift and go to state 306
    Printf_Params                  shift and go to state 333
    empty                          shift and go to state 307
    Op_Pointer                     shift and go to state 308
    Value                          shift and go to state 133

state 319

    (75) Stm -> SCANF L_PAR STRING COMMA Scanf_Param . R_PAR SEMICOLON

    R_PAR           shift and go to state 334


state 320

    (76) Scanf_Param -> AND_B . NAME

    NAME            shift and go to state 335


state 321

    (77) Scanf_Param -> NAME .

    R_PAR           reduce using rule 77 (Scanf_Param -> NAME .)


state 322

    (85) Then_Stm -> IF . L_PAR Expr R_PAR Then_Stm ELSE Then_Stm
    (80) Stm -> IF . L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> IF . L_PAR Expr R_PAR Stm

    L_PAR           shift and go to state 336


state 323

    (80) Stm -> IF L_PAR Expr R_PAR Then_Stm . ELSE Stm

    ELSE            shift and go to state 337


state 324

    (81) Stm -> IF L_PAR Expr R_PAR Stm .

    PRINTF          reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    SCANF           reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    NAME            reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    IF              reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    WHILE           reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    FOR             reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    DO              reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    SWITCH          reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    GOTO            reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    BREAK           reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    CONTINUE        reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    RETURN          reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    SEMICOLON       reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    EXTERN          reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    STATIC          reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    REGISTER        reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    AUTO            reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    VOLATILE        reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    CONST           reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    L_CURLY         reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    STRUCT          reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    UNION           reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    ENUM            reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    SIGNED          reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    UNSIGNED        reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    NOT             reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    NOT_B           reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    UMINUS          reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    MULTIPLY        reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    AND_B           reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    PLUSPLUS        reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    MINUSMINUS      reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    L_PAR           reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    SIZEOF          reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    INTEGER         reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    STRING          reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    CHARACTER       reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    DECIMAL         reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    CHAR            reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    INT             reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    FLOAT           reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    DOUBLE          reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    VOID            reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    R_CURLY         reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    CASE            reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)
    DEFAULT         reduce using rule 81 (Stm -> IF L_PAR Expr R_PAR Stm .)


state 325

    (86) Then_Stm -> WHILE . L_PAR Expr R_PAR Then_Stm
    (82) Stm -> WHILE . L_PAR Expr R_PAR Stm

    L_PAR           shift and go to state 338


state 326

    (87) Then_Stm -> FOR . L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Then_Stm
    (83) Stm -> FOR . L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm

    L_PAR           shift and go to state 339


state 327

    (88) Then_Stm -> Normal_Stm .
    (84) Stm -> Normal_Stm .

    ELSE            reduce using rule 88 (Then_Stm -> Normal_Stm .)
    PRINTF          reduce using rule 84 (Stm -> Normal_Stm .)
    SCANF           reduce using rule 84 (Stm -> Normal_Stm .)
    NAME            reduce using rule 84 (Stm -> Normal_Stm .)
    IF              reduce using rule 84 (Stm -> Normal_Stm .)
    WHILE           reduce using rule 84 (Stm -> Normal_Stm .)
    FOR             reduce using rule 84 (Stm -> Normal_Stm .)
    DO              reduce using rule 84 (Stm -> Normal_Stm .)
    SWITCH          reduce using rule 84 (Stm -> Normal_Stm .)
    GOTO            reduce using rule 84 (Stm -> Normal_Stm .)
    BREAK           reduce using rule 84 (Stm -> Normal_Stm .)
    CONTINUE        reduce using rule 84 (Stm -> Normal_Stm .)
    RETURN          reduce using rule 84 (Stm -> Normal_Stm .)
    SEMICOLON       reduce using rule 84 (Stm -> Normal_Stm .)
    EXTERN          reduce using rule 84 (Stm -> Normal_Stm .)
    STATIC          reduce using rule 84 (Stm -> Normal_Stm .)
    REGISTER        reduce using rule 84 (Stm -> Normal_Stm .)
    AUTO            reduce using rule 84 (Stm -> Normal_Stm .)
    VOLATILE        reduce using rule 84 (Stm -> Normal_Stm .)
    CONST           reduce using rule 84 (Stm -> Normal_Stm .)
    L_CURLY         reduce using rule 84 (Stm -> Normal_Stm .)
    STRUCT          reduce using rule 84 (Stm -> Normal_Stm .)
    UNION           reduce using rule 84 (Stm -> Normal_Stm .)
    ENUM            reduce using rule 84 (Stm -> Normal_Stm .)
    SIGNED          reduce using rule 84 (Stm -> Normal_Stm .)
    UNSIGNED        reduce using rule 84 (Stm -> Normal_Stm .)
    NOT             reduce using rule 84 (Stm -> Normal_Stm .)
    NOT_B           reduce using rule 84 (Stm -> Normal_Stm .)
    UMINUS          reduce using rule 84 (Stm -> Normal_Stm .)
    MULTIPLY        reduce using rule 84 (Stm -> Normal_Stm .)
    AND_B           reduce using rule 84 (Stm -> Normal_Stm .)
    PLUSPLUS        reduce using rule 84 (Stm -> Normal_Stm .)
    MINUSMINUS      reduce using rule 84 (Stm -> Normal_Stm .)
    L_PAR           reduce using rule 84 (Stm -> Normal_Stm .)
    SIZEOF          reduce using rule 84 (Stm -> Normal_Stm .)
    INTEGER         reduce using rule 84 (Stm -> Normal_Stm .)
    STRING          reduce using rule 84 (Stm -> Normal_Stm .)
    CHARACTER       reduce using rule 84 (Stm -> Normal_Stm .)
    DECIMAL         reduce using rule 84 (Stm -> Normal_Stm .)
    CHAR            reduce using rule 84 (Stm -> Normal_Stm .)
    INT             reduce using rule 84 (Stm -> Normal_Stm .)
    FLOAT           reduce using rule 84 (Stm -> Normal_Stm .)
    DOUBLE          reduce using rule 84 (Stm -> Normal_Stm .)
    VOID            reduce using rule 84 (Stm -> Normal_Stm .)
    R_CURLY         reduce using rule 84 (Stm -> Normal_Stm .)
    CASE            reduce using rule 84 (Stm -> Normal_Stm .)
    DEFAULT         reduce using rule 84 (Stm -> Normal_Stm .)


state 328

    (82) Stm -> WHILE L_PAR Expr R_PAR Stm .

    PRINTF          reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    SCANF           reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    NAME            reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    IF              reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    WHILE           reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    FOR             reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    DO              reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    SWITCH          reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    GOTO            reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    BREAK           reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    CONTINUE        reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    RETURN          reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    SEMICOLON       reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    EXTERN          reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    STATIC          reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    REGISTER        reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    AUTO            reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    VOLATILE        reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    CONST           reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    L_CURLY         reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    STRUCT          reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    UNION           reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    ENUM            reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    SIGNED          reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    UNSIGNED        reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    NOT             reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    NOT_B           reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    UMINUS          reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    MULTIPLY        reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    AND_B           reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    PLUSPLUS        reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    MINUSMINUS      reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    L_PAR           reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    SIZEOF          reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    INTEGER         reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    STRING          reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    CHARACTER       reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    DECIMAL         reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    CHAR            reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    INT             reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    FLOAT           reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    DOUBLE          reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    VOID            reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    R_CURLY         reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    CASE            reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)
    DEFAULT         reduce using rule 82 (Stm -> WHILE L_PAR Expr R_PAR Stm .)


state 329

    (83) Stm -> FOR L_PAR Arg SEMICOLON Arg . SEMICOLON Arg R_PAR Stm

    SEMICOLON       shift and go to state 340


state 330

    (89) Normal_Stm -> DO Stm WHILE L_PAR Expr . R_PAR
    (106) Expr -> Expr . COMMA Op_Assign

    R_PAR           shift and go to state 341
    COMMA           shift and go to state 180


state 331

    (90) Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY . Case_Stms R_CURLY
    (100) Case_Stms -> . CASE Value COLON Stm_List Case_Stms
    (101) Case_Stms -> . DEFAULT COLON Stm_List
    (102) Case_Stms -> . empty
    (174) empty -> .

    CASE            shift and go to state 343
    DEFAULT         shift and go to state 344
    R_CURLY         reduce using rule 174 (empty -> .)

    Case_Stms                      shift and go to state 342
    empty                          shift and go to state 345

state 332

    (70) Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .

    PRINTF          reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    SCANF           reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    NAME            reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    IF              reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    WHILE           reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    FOR             reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    DO              reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    SWITCH          reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    GOTO            reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    BREAK           reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    CONTINUE        reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    RETURN          reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    SEMICOLON       reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    EXTERN          reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    STATIC          reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    REGISTER        reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    AUTO            reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    VOLATILE        reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    CONST           reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    L_CURLY         reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    STRUCT          reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    UNION           reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    ENUM            reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    SIGNED          reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    UNSIGNED        reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    NOT             reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    NOT_B           reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    UMINUS          reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    MULTIPLY        reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    AND_B           reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    PLUSPLUS        reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    MINUSMINUS      reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    L_PAR           reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    SIZEOF          reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    INTEGER         reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    STRING          reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    CHARACTER       reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    DECIMAL         reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    CHAR            reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    INT             reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    FLOAT           reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    DOUBLE          reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    VOID            reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    R_CURLY         reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    CASE            reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)
    DEFAULT         reduce using rule 70 (Stm -> PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON .)


state 333

    (71) Printf_Params -> COMMA Printf_Param Printf_Params .

    R_PAR           reduce using rule 71 (Printf_Params -> COMMA Printf_Param Printf_Params .)


state 334

    (75) Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 346


state 335

    (76) Scanf_Param -> AND_B NAME .

    R_PAR           reduce using rule 76 (Scanf_Param -> AND_B NAME .)


state 336

    (85) Then_Stm -> IF L_PAR . Expr R_PAR Then_Stm ELSE Then_Stm
    (80) Stm -> IF L_PAR . Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> IF L_PAR . Expr R_PAR Stm
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Expr                           shift and go to state 347
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 337

    (80) Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE . Stm
    (70) Stm -> . PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
    (75) Stm -> . SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
    (78) Stm -> . Var_Decl
    (79) Stm -> . NAME COLON
    (80) Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> . IF L_PAR Expr R_PAR Stm
    (82) Stm -> . WHILE L_PAR Expr R_PAR Stm
    (83) Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (84) Stm -> . Normal_Stm
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (89) Normal_Stm -> . DO Stm WHILE L_PAR Expr R_PAR
    (90) Normal_Stm -> . SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
    (91) Normal_Stm -> . Block
    (92) Normal_Stm -> . Expr SEMICOLON
    (93) Normal_Stm -> . GOTO NAME SEMICOLON
    (94) Normal_Stm -> . BREAK SEMICOLON
    (95) Normal_Stm -> . CONTINUE SEMICOLON
    (96) Normal_Stm -> . RETURN Expr SEMICOLON
    (97) Normal_Stm -> . SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (103) Block -> . L_CURLY Stm_List R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (174) empty -> .
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    PRINTF          shift and go to state 145
    SCANF           shift and go to state 147
    NAME            shift and go to state 149
    IF              shift and go to state 150
    WHILE           shift and go to state 152
    FOR             shift and go to state 153
    DO              shift and go to state 155
    SWITCH          shift and go to state 156
    GOTO            shift and go to state 158
    BREAK           shift and go to state 159
    CONTINUE        shift and go to state 160
    RETURN          shift and go to state 161
    SEMICOLON       shift and go to state 146
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    L_CURLY         shift and go to state 86
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137

    Expr                           shift and go to state 151
    Stm                            shift and go to state 348
    Var_Decl                       shift and go to state 148
    Normal_Stm                     shift and go to state 154
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Block                          shift and go to state 157
    Base                           shift and go to state 25
    Op_Assign                      shift and go to state 109
    Sign                           shift and go to state 26
    Op_If                          shift and go to state 110
    empty                          shift and go to state 42
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 338

    (86) Then_Stm -> WHILE L_PAR . Expr R_PAR Then_Stm
    (82) Stm -> WHILE L_PAR . Expr R_PAR Stm
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Expr                           shift and go to state 349
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 339

    (87) Then_Stm -> FOR L_PAR . Arg SEMICOLON Arg SEMICOLON Arg R_PAR Then_Stm
    (83) Stm -> FOR L_PAR . Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (98) Arg -> . Expr
    (99) Arg -> . empty
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (174) empty -> .
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    SEMICOLON       reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Arg                            shift and go to state 350
    Expr                           shift and go to state 292
    empty                          shift and go to state 293
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 340

    (83) Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON . Arg R_PAR Stm
    (98) Arg -> . Expr
    (99) Arg -> . empty
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (174) empty -> .
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    R_PAR           reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Arg                            shift and go to state 351
    Expr                           shift and go to state 292
    empty                          shift and go to state 293
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 341

    (89) Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .

    PRINTF          reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    SCANF           reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    NAME            reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    IF              reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    WHILE           reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    FOR             reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    DO              reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    SWITCH          reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    GOTO            reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    BREAK           reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    CONTINUE        reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    RETURN          reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    SEMICOLON       reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    EXTERN          reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    STATIC          reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    REGISTER        reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    AUTO            reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    VOLATILE        reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    CONST           reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    L_CURLY         reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    STRUCT          reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    UNION           reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    ENUM            reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    SIGNED          reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    UNSIGNED        reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    NOT             reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    NOT_B           reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    UMINUS          reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    MULTIPLY        reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    AND_B           reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    PLUSPLUS        reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    MINUSMINUS      reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    L_PAR           reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    SIZEOF          reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    INTEGER         reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    STRING          reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    CHARACTER       reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    DECIMAL         reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    CHAR            reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    INT             reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    FLOAT           reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    DOUBLE          reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    VOID            reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    R_CURLY         reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    CASE            reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    DEFAULT         reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)
    ELSE            reduce using rule 89 (Normal_Stm -> DO Stm WHILE L_PAR Expr R_PAR .)


state 342

    (90) Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms . R_CURLY

    R_CURLY         shift and go to state 352


state 343

    (100) Case_Stms -> CASE . Value COLON Stm_List Case_Stms
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132
    L_PAR           shift and go to state 278

    Value                          shift and go to state 353

state 344

    (101) Case_Stms -> DEFAULT . COLON Stm_List

    COLON           shift and go to state 354


state 345

    (102) Case_Stms -> empty .

    R_CURLY         reduce using rule 102 (Case_Stms -> empty .)


state 346

    (75) Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .

    PRINTF          reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    SCANF           reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    NAME            reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    IF              reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    WHILE           reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    FOR             reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    DO              reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    SWITCH          reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    GOTO            reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    BREAK           reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    CONTINUE        reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    RETURN          reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    SEMICOLON       reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    EXTERN          reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    STATIC          reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    REGISTER        reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    AUTO            reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    VOLATILE        reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    CONST           reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    L_CURLY         reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    STRUCT          reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    UNION           reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    ENUM            reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    SIGNED          reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    UNSIGNED        reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    NOT             reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    NOT_B           reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    UMINUS          reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    MULTIPLY        reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    AND_B           reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    PLUSPLUS        reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    MINUSMINUS      reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    L_PAR           reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    SIZEOF          reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    INTEGER         reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    STRING          reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    CHARACTER       reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    DECIMAL         reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    CHAR            reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    INT             reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    FLOAT           reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    DOUBLE          reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    VOID            reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    R_CURLY         reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    CASE            reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)
    DEFAULT         reduce using rule 75 (Stm -> SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON .)


state 347

    (85) Then_Stm -> IF L_PAR Expr . R_PAR Then_Stm ELSE Then_Stm
    (80) Stm -> IF L_PAR Expr . R_PAR Then_Stm ELSE Stm
    (81) Stm -> IF L_PAR Expr . R_PAR Stm
    (106) Expr -> Expr . COMMA Op_Assign

    R_PAR           shift and go to state 355
    COMMA           shift and go to state 180


state 348

    (80) Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .

    PRINTF          reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    SCANF           reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    NAME            reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    IF              reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    WHILE           reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    FOR             reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    DO              reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    SWITCH          reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    GOTO            reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    BREAK           reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    CONTINUE        reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    RETURN          reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    SEMICOLON       reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    EXTERN          reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    STATIC          reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    REGISTER        reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    AUTO            reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    VOLATILE        reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    CONST           reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    L_CURLY         reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    STRUCT          reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    UNION           reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    ENUM            reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    SIGNED          reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    UNSIGNED        reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    NOT             reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    NOT_B           reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    UMINUS          reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    MULTIPLY        reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    AND_B           reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    PLUSPLUS        reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    MINUSMINUS      reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    L_PAR           reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    SIZEOF          reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    INTEGER         reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    STRING          reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    CHARACTER       reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    DECIMAL         reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    CHAR            reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    INT             reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    FLOAT           reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    DOUBLE          reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    VOID            reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    R_CURLY         reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    CASE            reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)
    DEFAULT         reduce using rule 80 (Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Stm .)


state 349

    (86) Then_Stm -> WHILE L_PAR Expr . R_PAR Then_Stm
    (82) Stm -> WHILE L_PAR Expr . R_PAR Stm
    (106) Expr -> Expr . COMMA Op_Assign

    R_PAR           shift and go to state 356
    COMMA           shift and go to state 180


state 350

    (87) Then_Stm -> FOR L_PAR Arg . SEMICOLON Arg SEMICOLON Arg R_PAR Then_Stm
    (83) Stm -> FOR L_PAR Arg . SEMICOLON Arg SEMICOLON Arg R_PAR Stm

    SEMICOLON       shift and go to state 357


state 351

    (83) Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg . R_PAR Stm

    R_PAR           shift and go to state 358


state 352

    (90) Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .

    PRINTF          reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    SCANF           reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    NAME            reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    IF              reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    WHILE           reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    FOR             reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    DO              reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    SWITCH          reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    GOTO            reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    BREAK           reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    CONTINUE        reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    RETURN          reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    SEMICOLON       reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    EXTERN          reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    STATIC          reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    REGISTER        reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    AUTO            reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    VOLATILE        reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    CONST           reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    L_CURLY         reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    STRUCT          reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    UNION           reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    ENUM            reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    SIGNED          reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    UNSIGNED        reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    NOT             reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    NOT_B           reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    UMINUS          reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    MULTIPLY        reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    AND_B           reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    PLUSPLUS        reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    MINUSMINUS      reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    L_PAR           reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    SIZEOF          reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    INTEGER         reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    STRING          reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    CHARACTER       reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    DECIMAL         reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    CHAR            reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    INT             reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    FLOAT           reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    DOUBLE          reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    VOID            reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    R_CURLY         reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    CASE            reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    DEFAULT         reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)
    ELSE            reduce using rule 90 (Normal_Stm -> SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY .)


state 353

    (100) Case_Stms -> CASE Value . COLON Stm_List Case_Stms

    COLON           shift and go to state 359


state 354

    (101) Case_Stms -> DEFAULT COLON . Stm_List
    (104) Stm_List -> . Stm Stm_List
    (105) Stm_List -> . empty
    (70) Stm -> . PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
    (75) Stm -> . SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
    (78) Stm -> . Var_Decl
    (79) Stm -> . NAME COLON
    (80) Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> . IF L_PAR Expr R_PAR Stm
    (82) Stm -> . WHILE L_PAR Expr R_PAR Stm
    (83) Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (84) Stm -> . Normal_Stm
    (174) empty -> .
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (89) Normal_Stm -> . DO Stm WHILE L_PAR Expr R_PAR
    (90) Normal_Stm -> . SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
    (91) Normal_Stm -> . Block
    (92) Normal_Stm -> . Expr SEMICOLON
    (93) Normal_Stm -> . GOTO NAME SEMICOLON
    (94) Normal_Stm -> . BREAK SEMICOLON
    (95) Normal_Stm -> . CONTINUE SEMICOLON
    (96) Normal_Stm -> . RETURN Expr SEMICOLON
    (97) Normal_Stm -> . SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (103) Block -> . L_CURLY Stm_List R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    PRINTF          shift and go to state 145
    SCANF           shift and go to state 147
    NAME            shift and go to state 149
    IF              shift and go to state 150
    WHILE           shift and go to state 152
    FOR             shift and go to state 153
    R_CURLY         reduce using rule 174 (empty -> .)
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    DO              shift and go to state 155
    SWITCH          shift and go to state 156
    GOTO            shift and go to state 158
    BREAK           shift and go to state 159
    CONTINUE        shift and go to state 160
    RETURN          shift and go to state 161
    SEMICOLON       shift and go to state 146
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    L_CURLY         shift and go to state 86
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137

    Stm_List                       shift and go to state 360
    Stm                            shift and go to state 143
    empty                          shift and go to state 144
    Var_Decl                       shift and go to state 148
    Expr                           shift and go to state 151
    Normal_Stm                     shift and go to state 154
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Block                          shift and go to state 157
    Base                           shift and go to state 25
    Op_Assign                      shift and go to state 109
    Sign                           shift and go to state 26
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 355

    (85) Then_Stm -> IF L_PAR Expr R_PAR . Then_Stm ELSE Then_Stm
    (80) Stm -> IF L_PAR Expr R_PAR . Then_Stm ELSE Stm
    (81) Stm -> IF L_PAR Expr R_PAR . Stm
    (85) Then_Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Then_Stm
    (86) Then_Stm -> . WHILE L_PAR Expr R_PAR Then_Stm
    (87) Then_Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Then_Stm
    (88) Then_Stm -> . Normal_Stm
    (70) Stm -> . PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
    (75) Stm -> . SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
    (78) Stm -> . Var_Decl
    (79) Stm -> . NAME COLON
    (80) Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> . IF L_PAR Expr R_PAR Stm
    (82) Stm -> . WHILE L_PAR Expr R_PAR Stm
    (83) Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (84) Stm -> . Normal_Stm
    (89) Normal_Stm -> . DO Stm WHILE L_PAR Expr R_PAR
    (90) Normal_Stm -> . SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
    (91) Normal_Stm -> . Block
    (92) Normal_Stm -> . Expr SEMICOLON
    (93) Normal_Stm -> . GOTO NAME SEMICOLON
    (94) Normal_Stm -> . BREAK SEMICOLON
    (95) Normal_Stm -> . CONTINUE SEMICOLON
    (96) Normal_Stm -> . RETURN Expr SEMICOLON
    (97) Normal_Stm -> . SEMICOLON
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (103) Block -> . L_CURLY Stm_List R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (174) empty -> .
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    IF              shift and go to state 322
    WHILE           shift and go to state 325
    FOR             shift and go to state 326
    PRINTF          shift and go to state 145
    SCANF           shift and go to state 147
    NAME            shift and go to state 149
    DO              shift and go to state 155
    SWITCH          shift and go to state 156
    GOTO            shift and go to state 158
    BREAK           shift and go to state 159
    CONTINUE        shift and go to state 160
    RETURN          shift and go to state 161
    SEMICOLON       shift and go to state 146
    L_CURLY         shift and go to state 86
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137

    Expr                           shift and go to state 151
    Then_Stm                       shift and go to state 361
    Stm                            shift and go to state 324
    Normal_Stm                     shift and go to state 327
    Var_Decl                       shift and go to state 148
    Block                          shift and go to state 157
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Op_Assign                      shift and go to state 109
    Base                           shift and go to state 25
    Op_If                          shift and go to state 110
    Sign                           shift and go to state 26
    Op_Or                          shift and go to state 111
    empty                          shift and go to state 42
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 356

    (86) Then_Stm -> WHILE L_PAR Expr R_PAR . Then_Stm
    (82) Stm -> WHILE L_PAR Expr R_PAR . Stm
    (85) Then_Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Then_Stm
    (86) Then_Stm -> . WHILE L_PAR Expr R_PAR Then_Stm
    (87) Then_Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Then_Stm
    (88) Then_Stm -> . Normal_Stm
    (70) Stm -> . PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
    (75) Stm -> . SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
    (78) Stm -> . Var_Decl
    (79) Stm -> . NAME COLON
    (80) Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> . IF L_PAR Expr R_PAR Stm
    (82) Stm -> . WHILE L_PAR Expr R_PAR Stm
    (83) Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (84) Stm -> . Normal_Stm
    (89) Normal_Stm -> . DO Stm WHILE L_PAR Expr R_PAR
    (90) Normal_Stm -> . SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
    (91) Normal_Stm -> . Block
    (92) Normal_Stm -> . Expr SEMICOLON
    (93) Normal_Stm -> . GOTO NAME SEMICOLON
    (94) Normal_Stm -> . BREAK SEMICOLON
    (95) Normal_Stm -> . CONTINUE SEMICOLON
    (96) Normal_Stm -> . RETURN Expr SEMICOLON
    (97) Normal_Stm -> . SEMICOLON
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (103) Block -> . L_CURLY Stm_List R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (174) empty -> .
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    IF              shift and go to state 322
    WHILE           shift and go to state 325
    FOR             shift and go to state 326
    PRINTF          shift and go to state 145
    SCANF           shift and go to state 147
    NAME            shift and go to state 149
    DO              shift and go to state 155
    SWITCH          shift and go to state 156
    GOTO            shift and go to state 158
    BREAK           shift and go to state 159
    CONTINUE        shift and go to state 160
    RETURN          shift and go to state 161
    SEMICOLON       shift and go to state 146
    L_CURLY         shift and go to state 86
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137

    Expr                           shift and go to state 151
    Then_Stm                       shift and go to state 362
    Stm                            shift and go to state 328
    Normal_Stm                     shift and go to state 327
    Var_Decl                       shift and go to state 148
    Block                          shift and go to state 157
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Op_Assign                      shift and go to state 109
    Base                           shift and go to state 25
    Op_If                          shift and go to state 110
    Sign                           shift and go to state 26
    Op_Or                          shift and go to state 111
    empty                          shift and go to state 42
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 357

    (87) Then_Stm -> FOR L_PAR Arg SEMICOLON . Arg SEMICOLON Arg R_PAR Then_Stm
    (83) Stm -> FOR L_PAR Arg SEMICOLON . Arg SEMICOLON Arg R_PAR Stm
    (98) Arg -> . Expr
    (99) Arg -> . empty
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (174) empty -> .
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    SEMICOLON       reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Arg                            shift and go to state 363
    Expr                           shift and go to state 292
    empty                          shift and go to state 293
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 358

    (83) Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR . Stm
    (70) Stm -> . PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
    (75) Stm -> . SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
    (78) Stm -> . Var_Decl
    (79) Stm -> . NAME COLON
    (80) Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> . IF L_PAR Expr R_PAR Stm
    (82) Stm -> . WHILE L_PAR Expr R_PAR Stm
    (83) Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (84) Stm -> . Normal_Stm
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (89) Normal_Stm -> . DO Stm WHILE L_PAR Expr R_PAR
    (90) Normal_Stm -> . SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
    (91) Normal_Stm -> . Block
    (92) Normal_Stm -> . Expr SEMICOLON
    (93) Normal_Stm -> . GOTO NAME SEMICOLON
    (94) Normal_Stm -> . BREAK SEMICOLON
    (95) Normal_Stm -> . CONTINUE SEMICOLON
    (96) Normal_Stm -> . RETURN Expr SEMICOLON
    (97) Normal_Stm -> . SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (103) Block -> . L_CURLY Stm_List R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (174) empty -> .
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    PRINTF          shift and go to state 145
    SCANF           shift and go to state 147
    NAME            shift and go to state 149
    IF              shift and go to state 150
    WHILE           shift and go to state 152
    FOR             shift and go to state 153
    DO              shift and go to state 155
    SWITCH          shift and go to state 156
    GOTO            shift and go to state 158
    BREAK           shift and go to state 159
    CONTINUE        shift and go to state 160
    RETURN          shift and go to state 161
    SEMICOLON       shift and go to state 146
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    L_CURLY         shift and go to state 86
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137

    Stm                            shift and go to state 364
    Var_Decl                       shift and go to state 148
    Expr                           shift and go to state 151
    Normal_Stm                     shift and go to state 154
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Block                          shift and go to state 157
    Base                           shift and go to state 25
    Op_Assign                      shift and go to state 109
    Sign                           shift and go to state 26
    Op_If                          shift and go to state 110
    empty                          shift and go to state 42
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 359

    (100) Case_Stms -> CASE Value COLON . Stm_List Case_Stms
    (104) Stm_List -> . Stm Stm_List
    (105) Stm_List -> . empty
    (70) Stm -> . PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
    (75) Stm -> . SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
    (78) Stm -> . Var_Decl
    (79) Stm -> . NAME COLON
    (80) Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> . IF L_PAR Expr R_PAR Stm
    (82) Stm -> . WHILE L_PAR Expr R_PAR Stm
    (83) Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (84) Stm -> . Normal_Stm
    (174) empty -> .
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (89) Normal_Stm -> . DO Stm WHILE L_PAR Expr R_PAR
    (90) Normal_Stm -> . SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
    (91) Normal_Stm -> . Block
    (92) Normal_Stm -> . Expr SEMICOLON
    (93) Normal_Stm -> . GOTO NAME SEMICOLON
    (94) Normal_Stm -> . BREAK SEMICOLON
    (95) Normal_Stm -> . CONTINUE SEMICOLON
    (96) Normal_Stm -> . RETURN Expr SEMICOLON
    (97) Normal_Stm -> . SEMICOLON
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (103) Block -> . L_CURLY Stm_List R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    PRINTF          shift and go to state 145
    SCANF           shift and go to state 147
    NAME            shift and go to state 149
    IF              shift and go to state 150
    WHILE           shift and go to state 152
    FOR             shift and go to state 153
    CASE            reduce using rule 174 (empty -> .)
    DEFAULT         reduce using rule 174 (empty -> .)
    R_CURLY         reduce using rule 174 (empty -> .)
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    DO              shift and go to state 155
    SWITCH          shift and go to state 156
    GOTO            shift and go to state 158
    BREAK           shift and go to state 159
    CONTINUE        shift and go to state 160
    RETURN          shift and go to state 161
    SEMICOLON       shift and go to state 146
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    L_CURLY         shift and go to state 86
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137

    Value                          shift and go to state 133
    Stm_List                       shift and go to state 365
    Stm                            shift and go to state 143
    empty                          shift and go to state 144
    Var_Decl                       shift and go to state 148
    Expr                           shift and go to state 151
    Normal_Stm                     shift and go to state 154
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Block                          shift and go to state 157
    Base                           shift and go to state 25
    Op_Assign                      shift and go to state 109
    Sign                           shift and go to state 26
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129

state 360

    (101) Case_Stms -> DEFAULT COLON Stm_List .

    R_CURLY         reduce using rule 101 (Case_Stms -> DEFAULT COLON Stm_List .)


state 361

    (85) Then_Stm -> IF L_PAR Expr R_PAR Then_Stm . ELSE Then_Stm
    (80) Stm -> IF L_PAR Expr R_PAR Then_Stm . ELSE Stm

    ELSE            shift and go to state 366


state 362

    (86) Then_Stm -> WHILE L_PAR Expr R_PAR Then_Stm .

    ELSE            reduce using rule 86 (Then_Stm -> WHILE L_PAR Expr R_PAR Then_Stm .)


state 363

    (87) Then_Stm -> FOR L_PAR Arg SEMICOLON Arg . SEMICOLON Arg R_PAR Then_Stm
    (83) Stm -> FOR L_PAR Arg SEMICOLON Arg . SEMICOLON Arg R_PAR Stm

    SEMICOLON       shift and go to state 367


state 364

    (83) Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .

    PRINTF          reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    SCANF           reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    NAME            reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    IF              reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    WHILE           reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    FOR             reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    DO              reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    SWITCH          reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    GOTO            reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    BREAK           reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    CONTINUE        reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    RETURN          reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    SEMICOLON       reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    EXTERN          reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    STATIC          reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    REGISTER        reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    AUTO            reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    VOLATILE        reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    CONST           reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    L_CURLY         reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    STRUCT          reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    UNION           reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    ENUM            reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    SIGNED          reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    UNSIGNED        reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    NOT             reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    NOT_B           reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    UMINUS          reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    MULTIPLY        reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    AND_B           reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    PLUSPLUS        reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    MINUSMINUS      reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    L_PAR           reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    SIZEOF          reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    INTEGER         reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    STRING          reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    CHARACTER       reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    DECIMAL         reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    CHAR            reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    INT             reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    FLOAT           reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    DOUBLE          reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    VOID            reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    R_CURLY         reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    CASE            reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)
    DEFAULT         reduce using rule 83 (Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm .)


state 365

    (100) Case_Stms -> CASE Value COLON Stm_List . Case_Stms
    (100) Case_Stms -> . CASE Value COLON Stm_List Case_Stms
    (101) Case_Stms -> . DEFAULT COLON Stm_List
    (102) Case_Stms -> . empty
    (174) empty -> .

    CASE            shift and go to state 343
    DEFAULT         shift and go to state 344
    R_CURLY         reduce using rule 174 (empty -> .)

    Case_Stms                      shift and go to state 368
    empty                          shift and go to state 345

state 366

    (85) Then_Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE . Then_Stm
    (80) Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE . Stm
    (85) Then_Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Then_Stm
    (86) Then_Stm -> . WHILE L_PAR Expr R_PAR Then_Stm
    (87) Then_Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Then_Stm
    (88) Then_Stm -> . Normal_Stm
    (70) Stm -> . PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
    (75) Stm -> . SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
    (78) Stm -> . Var_Decl
    (79) Stm -> . NAME COLON
    (80) Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> . IF L_PAR Expr R_PAR Stm
    (82) Stm -> . WHILE L_PAR Expr R_PAR Stm
    (83) Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (84) Stm -> . Normal_Stm
    (89) Normal_Stm -> . DO Stm WHILE L_PAR Expr R_PAR
    (90) Normal_Stm -> . SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
    (91) Normal_Stm -> . Block
    (92) Normal_Stm -> . Expr SEMICOLON
    (93) Normal_Stm -> . GOTO NAME SEMICOLON
    (94) Normal_Stm -> . BREAK SEMICOLON
    (95) Normal_Stm -> . CONTINUE SEMICOLON
    (96) Normal_Stm -> . RETURN Expr SEMICOLON
    (97) Normal_Stm -> . SEMICOLON
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (103) Block -> . L_CURLY Stm_List R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (174) empty -> .
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    IF              shift and go to state 322
    WHILE           shift and go to state 325
    FOR             shift and go to state 326
    PRINTF          shift and go to state 145
    SCANF           shift and go to state 147
    NAME            shift and go to state 149
    DO              shift and go to state 155
    SWITCH          shift and go to state 156
    GOTO            shift and go to state 158
    BREAK           shift and go to state 159
    CONTINUE        shift and go to state 160
    RETURN          shift and go to state 161
    SEMICOLON       shift and go to state 146
    L_CURLY         shift and go to state 86
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137

    Expr                           shift and go to state 151
    Then_Stm                       shift and go to state 369
    Stm                            shift and go to state 348
    Normal_Stm                     shift and go to state 327
    Var_Decl                       shift and go to state 148
    Block                          shift and go to state 157
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Op_Assign                      shift and go to state 109
    Base                           shift and go to state 25
    Op_If                          shift and go to state 110
    Sign                           shift and go to state 26
    Op_Or                          shift and go to state 111
    empty                          shift and go to state 42
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 367

    (87) Then_Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON . Arg R_PAR Then_Stm
    (83) Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON . Arg R_PAR Stm
    (98) Arg -> . Expr
    (99) Arg -> . empty
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (174) empty -> .
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    R_PAR           reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137
    NAME            shift and go to state 132

    Arg                            shift and go to state 370
    Expr                           shift and go to state 292
    empty                          shift and go to state 293
    Op_Assign                      shift and go to state 109
    Op_If                          shift and go to state 110
    Op_Or                          shift and go to state 111
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 368

    (100) Case_Stms -> CASE Value COLON Stm_List Case_Stms .

    R_CURLY         reduce using rule 100 (Case_Stms -> CASE Value COLON Stm_List Case_Stms .)


state 369

    (85) Then_Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Then_Stm .

    ELSE            reduce using rule 85 (Then_Stm -> IF L_PAR Expr R_PAR Then_Stm ELSE Then_Stm .)


state 370

    (87) Then_Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg . R_PAR Then_Stm
    (83) Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg . R_PAR Stm

    R_PAR           shift and go to state 371


state 371

    (87) Then_Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR . Then_Stm
    (83) Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR . Stm
    (85) Then_Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Then_Stm
    (86) Then_Stm -> . WHILE L_PAR Expr R_PAR Then_Stm
    (87) Then_Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Then_Stm
    (88) Then_Stm -> . Normal_Stm
    (70) Stm -> . PRINTF L_PAR STRING Printf_Params R_PAR SEMICOLON
    (75) Stm -> . SCANF L_PAR STRING COMMA Scanf_Param R_PAR SEMICOLON
    (78) Stm -> . Var_Decl
    (79) Stm -> . NAME COLON
    (80) Stm -> . IF L_PAR Expr R_PAR Then_Stm ELSE Stm
    (81) Stm -> . IF L_PAR Expr R_PAR Stm
    (82) Stm -> . WHILE L_PAR Expr R_PAR Stm
    (83) Stm -> . FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Stm
    (84) Stm -> . Normal_Stm
    (89) Normal_Stm -> . DO Stm WHILE L_PAR Expr R_PAR
    (90) Normal_Stm -> . SWITCH L_PAR Expr R_PAR L_CURLY Case_Stms R_CURLY
    (91) Normal_Stm -> . Block
    (92) Normal_Stm -> . Expr SEMICOLON
    (93) Normal_Stm -> . GOTO NAME SEMICOLON
    (94) Normal_Stm -> . BREAK SEMICOLON
    (95) Normal_Stm -> . CONTINUE SEMICOLON
    (96) Normal_Stm -> . RETURN Expr SEMICOLON
    (97) Normal_Stm -> . SEMICOLON
    (31) Var_Decl -> . Mod Type Var Var_List SEMICOLON
    (32) Var_Decl -> . Type Var Var_List SEMICOLON
    (33) Var_Decl -> . Mod Var Var_List SEMICOLON
    (103) Block -> . L_CURLY Stm_List R_CURLY
    (106) Expr -> . Expr COMMA Op_Assign
    (107) Expr -> . Op_Assign
    (42) Mod -> . EXTERN
    (43) Mod -> . STATIC
    (44) Mod -> . REGISTER
    (45) Mod -> . AUTO
    (46) Mod -> . VOLATILE
    (47) Mod -> . CONST
    (53) Type -> . Base Pointers
    (108) Op_Assign -> . Op_If ASSIGN Op_Assign
    (109) Op_Assign -> . Op_If APLUS Op_Assign
    (110) Op_Assign -> . Op_If AMINUS Op_Assign
    (111) Op_Assign -> . Op_If AMULTIPLY Op_Assign
    (112) Op_Assign -> . Op_If ADIVIDE Op_Assign
    (113) Op_Assign -> . Op_If AXOR Op_Assign
    (114) Op_Assign -> . Op_If AAND Op_Assign
    (115) Op_Assign -> . Op_If AOR Op_Assign
    (116) Op_Assign -> . Op_If ASHIFT_R Op_Assign
    (117) Op_Assign -> . Op_If ASHIFT_L Op_Assign
    (118) Op_Assign -> . Op_If
    (54) Base -> . Sign Scalar
    (55) Base -> . STRUCT NAME
    (56) Base -> . STRUCT L_CURLY Struct_Def R_CURLY
    (57) Base -> . UNION NAME
    (58) Base -> . UNION L_CURLY Struct_Def R_CURLY
    (59) Base -> . ENUM NAME
    (119) Op_If -> . Op_Or QUESTION Op_If COLON Op_If
    (120) Op_If -> . Op_Or
    (60) Sign -> . SIGNED
    (61) Sign -> . UNSIGNED
    (62) Sign -> . empty
    (121) Op_Or -> . Op_Or OR Op_And
    (122) Op_Or -> . Op_And
    (174) empty -> .
    (123) Op_And -> . Op_And AND Op_BinOR
    (124) Op_And -> . Op_BinOR
    (125) Op_BinOR -> . Op_BinOR OR_B Op_BinXOR
    (126) Op_BinOR -> . Op_BinXOR
    (127) Op_BinXOR -> . Op_BinXOR XOR_B Op_BinAND
    (128) Op_BinXOR -> . Op_BinAND
    (129) Op_BinAND -> . Op_BinAND AND_B Op_Equate
    (130) Op_BinAND -> . Op_Equate
    (131) Op_Equate -> . Op_Equate EQUAL Op_Compare
    (132) Op_Equate -> . Op_Equate NOT_EQUAL Op_Compare
    (133) Op_Equate -> . Op_Compare
    (134) Op_Compare -> . Op_Compare LESS Op_Shift
    (135) Op_Compare -> . Op_Compare GREATER Op_Shift
    (136) Op_Compare -> . Op_Compare LESS_EQUAL Op_Shift
    (137) Op_Compare -> . Op_Compare GREATER_EQUAL Op_Shift
    (138) Op_Compare -> . Op_Shift
    (139) Op_Shift -> . Op_Shift SHIFT_L Op_Add
    (140) Op_Shift -> . Op_Shift SHIFT_R Op_Add
    (141) Op_Shift -> . Op_Add
    (142) Op_Add -> . Op_Add PLUS Op_Mult
    (143) Op_Add -> . Op_Add MINUS Op_Mult
    (144) Op_Add -> . Op_Mult
    (145) Op_Mult -> . Op_Mult MULTIPLY Op_Unary
    (146) Op_Mult -> . Op_Mult DIVIDE Op_Unary
    (147) Op_Mult -> . Op_Mult REMAINDER Op_Unary
    (148) Op_Mult -> . Op_Unary
    (149) Op_Unary -> . NOT Op_Unary
    (150) Op_Unary -> . NOT_B Op_Unary
    (151) Op_Unary -> . UMINUS Op_Unary
    (152) Op_Unary -> . MULTIPLY Op_Unary
    (153) Op_Unary -> . AND_B Op_Unary
    (154) Op_Unary -> . PLUSPLUS Op_Unary
    (155) Op_Unary -> . MINUSMINUS Op_Unary
    (156) Op_Unary -> . Op_Pointer PLUSPLUS
    (157) Op_Unary -> . Op_Pointer MINUSMINUS
    (158) Op_Unary -> . L_PAR Type R_PAR Op_Unary
    (159) Op_Unary -> . SIZEOF L_PAR Type R_PAR
    (160) Op_Unary -> . SIZEOF L_PAR NAME Pointers R_PAR
    (161) Op_Unary -> . Op_Pointer
    (162) Op_Pointer -> . Op_Pointer DOT Value
    (163) Op_Pointer -> . Op_Pointer ACCESS Value
    (164) Op_Pointer -> . Op_Pointer L_BRACKET Expr R_BRACKET
    (165) Op_Pointer -> . Value
    (166) Value -> . INTEGER
    (167) Value -> . STRING
    (168) Value -> . CHARACTER
    (169) Value -> . DECIMAL
    (170) Value -> . NAME
    (171) Value -> . NAME L_PAR Expr R_PAR
    (172) Value -> . NAME L_PAR R_PAR
    (173) Value -> . L_PAR Expr R_PAR

    IF              shift and go to state 322
    WHILE           shift and go to state 325
    FOR             shift and go to state 326
    PRINTF          shift and go to state 145
    SCANF           shift and go to state 147
    NAME            shift and go to state 149
    DO              shift and go to state 155
    SWITCH          shift and go to state 156
    GOTO            shift and go to state 158
    BREAK           shift and go to state 159
    CONTINUE        shift and go to state 160
    RETURN          shift and go to state 161
    SEMICOLON       shift and go to state 146
    L_CURLY         shift and go to state 86
    EXTERN          shift and go to state 19
    STATIC          shift and go to state 20
    REGISTER        shift and go to state 21
    AUTO            shift and go to state 22
    VOLATILE        shift and go to state 23
    CONST           shift and go to state 24
    STRUCT          shift and go to state 39
    UNION           shift and go to state 40
    ENUM            shift and go to state 41
    SIGNED          shift and go to state 27
    UNSIGNED        shift and go to state 28
    CHAR            reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    NOT             shift and go to state 124
    NOT_B           shift and go to state 125
    UMINUS          shift and go to state 126
    MULTIPLY        shift and go to state 122
    AND_B           shift and go to state 116
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    L_PAR           shift and go to state 130
    SIZEOF          shift and go to state 131
    INTEGER         shift and go to state 134
    STRING          shift and go to state 135
    CHARACTER       shift and go to state 136
    DECIMAL         shift and go to state 137

    Then_Stm                       shift and go to state 372
    Stm                            shift and go to state 364
    Expr                           shift and go to state 151
    Normal_Stm                     shift and go to state 327
    Var_Decl                       shift and go to state 148
    Block                          shift and go to state 157
    Mod                            shift and go to state 16
    Type                           shift and go to state 66
    Op_Assign                      shift and go to state 109
    Base                           shift and go to state 25
    Op_If                          shift and go to state 110
    Sign                           shift and go to state 26
    Op_Or                          shift and go to state 111
    empty                          shift and go to state 42
    Op_And                         shift and go to state 112
    Op_BinOR                       shift and go to state 113
    Op_BinXOR                      shift and go to state 114
    Op_BinAND                      shift and go to state 115
    Op_Equate                      shift and go to state 117
    Op_Compare                     shift and go to state 118
    Op_Shift                       shift and go to state 119
    Op_Add                         shift and go to state 120
    Op_Mult                        shift and go to state 121
    Op_Unary                       shift and go to state 123
    Op_Pointer                     shift and go to state 129
    Value                          shift and go to state 133

state 372

    (87) Then_Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Then_Stm .

    ELSE            reduce using rule 87 (Then_Stm -> FOR L_PAR Arg SEMICOLON Arg SEMICOLON Arg R_PAR Then_Stm .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for L_PAR in state 132 resolved as shift
